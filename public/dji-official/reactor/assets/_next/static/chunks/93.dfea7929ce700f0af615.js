(window.webpackJsonp = window.webpackJsonp || []).push([
    [93], {
        D9Jf: function(t, e, n) {
            "use strict";
            n.r(e);
            var i = n("1OyB"),
                r = n("vuIU"),
                s = n("JX7q"),
                o = n("Ji7U"),
                a = n("md7G"),
                l = n("foSv"),
                c = n("iKuz"),
                h = n.n(c),
                u = n("q1tI"),
                d = n.n(u),
                p = n("XnI8"),
                m = n("TSYQ"),
                f = n.n(m),
                g = (n("Wymu"), n("YovF"), d.a.createElement);

            function v(t) {
                var e = function() {
                    if ("undefined" === typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" === typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
                    } catch (t) {
                        return !1
                    }
                }();
                return function() {
                    var n, i = Object(l.a)(t);
                    if (e) {
                        var r = Object(l.a)(this).constructor;
                        n = Reflect.construct(i, arguments, r)
                    } else n = i.apply(this, arguments);
                    return Object(a.a)(this, n)
                }
            }
            var y = {
                    "./style.css": {
                        "wm161-model-container": "style__wm161-model-container___17bBU",
                        hidden: "style__hidden___3U51Z",
                        "fade-up-title": "style__fade-up-title___1oEza",
                        "fade-up-text": "style__fade-up-text___s9RAO",
                        "fade-up-reverse": "style__fade-up-reverse___3Ffmw",
                        reverse: "style__reverse___2G2Ys",
                        rotate: "style__rotate___3y-Li",
                        "top-animation": "style__top-animation___2Sqbv",
                        "bottom-animation": "style__bottom-animation___3aU5w",
                        "front-animation": "style__front-animation___2od4a",
                        "back-animation": "style__back-animation___v7X_u",
                        "left-animation": "style__left-animation___KcuUK",
                        "right-animation": "style__right-animation___-FV_o",
                        "model-wrapper": "style__model-wrapper___3KRq2",
                        "model-title": "style__model-title___2UrJl",
                        "model-tabs": "style__model-tabs___tUzLq",
                        "model-tabs-back-mask": "style__model-tabs-back-mask___1zPkE",
                        "model-tabs-panel": "style__model-tabs-panel___39W1C",
                        "model-block": "style__model-block___1Yk9k",
                        "model-desc": "style__model-desc___ksMoi",
                        "model-qc-code": "style__model-qc-code___32K79",
                        "qc-active": "style__qc-active___O6vGA",
                        "unfold-tabs-panel": "style__unfold-tabs-panel___3-Vep",
                        "fold-tabs-panel": "style__fold-tabs-panel___3Vmup",
                        "model-content": "style__model-content___MhwPT",
                        "model-ie-img": "style__model-ie-img___9Zry2",
                        "model-progress": "style__model-progress___3ZHjt",
                        cube: "style__cube___1n9AS",
                        sides: "style__sides___1Kt_u",
                        top: "style__top___3Jy_d",
                        bottom: "style__bottom___321L8",
                        front: "style__front___3QhDu",
                        back: "style__back___2q48n",
                        left: "style__left___2SWKs",
                        right: "style__right___2x5Tx",
                        "cube-box": "style__cube-box___MrewK",
                        text: "style__text___3ireS",
                        "bar-wrapper": "style__bar-wrapper___1v6sT",
                        bar: "style__bar___2kDyi",
                        "flex-box": "style__flex-box___2heey",
                        "model-error": "style__model-error___3RyIi",
                        "model-retry-btn": "style__model-retry-btn___3BCvF",
                        "model-retry-logo": "style__model-retry-logo___hfW1Y",
                        "model-error-logo": "style__model-error-logo___1Ns95",
                        "progress-show": "style__progress-show___2-G45",
                        "model-active": "style__model-active___1k12E",
                        "model-ar-img": "style__model-ar-img___35I2Z",
                        "model-ar-tips": "style__model-ar-tips___dUwjr",
                        "wm161-model-container-in-modal": "style__wm161-model-container-in-modal___kKLsO",
                        "model-block-3d": "style__model-block-3d___2fudz",
                        "switch-tabs": "style__switch-tabs___28KKA",
                        "model-block-ar": "style__model-block-ar___xAZuZ",
                        tip: "style__tip___234JL",
                        "wm161-model-container-light-theme": "style__wm161-model-container-light-theme___216_A",
                        "quark-tab-default-tab-container": "style__quark-tab-default-tab-container___24CB6",
                        "aos-animate": "style__aos-animate___2Ky33",
                        "switch-tabs-panel": "style__switch-tabs-panel___1B1wi",
                        "switch-active": "style__switch-active___1NdeD",
                        _8wsGN: "style___8wsGN___aWYFD",
                        "quark-tab-default-tab-bar": "style__quark-tab-default-tab-bar___1NrXy",
                        _28KUW: "style___28KUW___1htnN",
                        _1Ltud: "style___1Ltud___Pce63"
                    }
                },
                x = function(t) {
                    var e = t.ctx,
                        n = t.isLoading,
                        i = t.loadDesc;
                    return g("div", {
                        className: h()(f()({
                            "model-progress": !0,
                            "progress-show": n
                        }), y, {
                            autoResolveMultipleImports: !0,
                            handleMissingStyleName: "warn"
                        })
                    }, g("div", {
                        className: "style__flex-box___2heey"
                    }, g("div", {
                        className: "style__cube-box___MrewK"
                    }, g("div", {
                        className: "style__cube___1n9AS"
                    }, g("div", {
                        className: "style__sides___1Kt_u"
                    }, g("div", {
                        className: "style__top___3Jy_d"
                    }), g("div", {
                        className: "style__right___2x5Tx"
                    }), g("div", {
                        className: "style__bottom___321L8"
                    }), g("div", {
                        className: "style__left___2SWKs"
                    }), g("div", {
                        className: "style__front___3QhDu"
                    }), g("div", {
                        className: "style__back___2q48n"
                    })))), g("div", {
                        className: "style__bar-wrapper___1v6sT"
                    }, g("div", {
                        className: "style__bar___2kDyi",
                        ref: function(t) {
                            e.progressBar = t
                        }
                    })), g("div", {
                        className: "style__text___3ireS"
                    }, i)))
                },
                b = function(t) {
                    Object(o.a)(n, t);
                    var e = v(n);

                    function n(t) {
                        var r;
                        Object(i.default)(this, n), r = e.call(this, t);
                        var o = t.normalArModelUrl;
                        return r.state = {
                            isLoading: !0,
                            isLoaded: !1,
                            loadError: !1,
                            modelUrl: "object" === typeof o ? o.path : o
                        }, r.handleProgressEvent = r.handleProgressEvent.bind(Object(s.a)(r)), r.handleError = r.handleError.bind(Object(s.a)(r)), r.handleRetry = r.handleRetry.bind(Object(s.a)(r)), r.modelViewer = null, r.isRevealed = !1, r.retry = 0, r
                    }
                    return Object(r.default)(n, [{
                        key: "handleProgressEvent",
                        value: function(t) {
                            var e = t.detail.totalProgress,
                                n = this.state,
                                i = n.isLoading,
                                r = n.isLoaded,
                                s = i,
                                o = r;
                            if (n.loadError) return this.setState({
                                isLoading: !1
                            });
                            if (e < 1) {
                                if ("number" === typeof e && this.progressBar) {
                                    var a = e / .7;
                                    this.progressBar.style.transform = "scaleX(".concat(100 * a, "%)")
                                }
                                s = !0
                            } else 1 === e ? (this.progressBar && (this.progressBar.style.transform = "scaleX(100%)"), o = !0, s = !1) : s = !1;
                            s === i && o === r || this.setState({
                                isLoading: s,
                                isLoaded: o
                            })
                        }
                    }, {
                        key: "handleError",
                        value: function(t) {
                            if (t) {
                                var e = t.detail,
                                    n = (void 0 === e ? {} : e).message,
                                    i = void 0 === n ? "" : n;
                                console.log(t), "string" === typeof i && i.indexOf("Could not set model source to") >= 0 && this.setState({
                                    loadError: !0,
                                    isLoading: !1
                                })
                            }
                        }
                    }, {
                        key: "handleRetry",
                        value: function() {
                            var t = this.props.normalArModelUrl,
                                e = void 0 === t ? "" : t;
                            "object" === typeof e && (e = e.path), this.retry += 1, e = e.indexOf("?") >= 0 ? "".concat(e, "&retry=").concat(this.retry) : "".concat(e, "?retry=").concat(this.retry), this.setState({
                                loadError: !1,
                                modelUrl: e
                            })
                        }
                    }, {
                        key: "componentDidMount",
                        value: function() {
                            this.modelViewer ? (this.modelViewer.addEventListener("progress", this.handleProgressEvent), this.modelViewer.addEventListener("error", this.handleError)) : console.log("NO ModelViewer")
                        }
                    }, {
                        key: "componentWillUnmount",
                        value: function() {
                            this.modelViewer.removeEventListener("progress", this.handleProgressEvent), this.modelViewer.removeEventListener("error", this.handleError)
                        }
                    }, {
                        key: "render",
                        value: function() {
                            var t = this,
                                e = this.props,
                                n = e.modelLoadDesc,
                                i = e.modelLightUrl,
                                r = e.modelIdName,
                                s = e.modelCameraOrbit,
                                o = e.modelCameraDist,
                                a = e.modelExposure,
                                l = e.isActived,
                                c = (e.theme, e.t),
                                h = this.state,
                                u = h.isLoading,
                                p = h.isLoaded,
                                m = h.loadError,
                                f = h.modelUrl,
                                v = "auto auto ".concat(o),
                                y = "object" === typeof i ? i.path : i;
                            return y = "string" === typeof y && y.startsWith("https://") ? y : void 0, !this.isRevealed && l && p && this.modelViewer && (this.modelViewer.dismissPoster(), this.isRevealed = !0), g(d.a.Fragment, null, g(x, {
                                isLoading: u,
                                loadDesc: n,
                                ctx: this
                            }), g("model-viewer", {
                                id: r,
                                ref: function(e) {
                                    t.modelViewer = e
                                },
                                src: f,
                                exposure: a,
                                "environment-image": y,
                                "shadow-intensity": "1",
                                "camera-controls": !0,
                                "data-js-focus-visible": !0,
                                "interaction-policy": "allow-when-focused",
                                "camera-orbit": s,
                                "min-camera-orbit": v,
                                "max-camera-orbit": v,
                                "max-field-of-view": "10deg",
                                loading: "eager",
                                reveal: "manual"
                            }, g("div", {
                                slot: "progress-bar"
                            })), g("div", {
                                className: "style__model-error___3RyIi",
                                style: {
                                    display: m ? "flex" : "none"
                                }
                            }, g("figure", {
                                className: "style__model-error-logo___1Ns95",
                                role: "img"
                            }), g("p", {
                                dangerouslySetInnerHTML: {
                                    __html: c("v4.common.3dmodel.loadind_error.tip")
                                }
                            }), g("button", {
                                type: "button",
                                className: "style__model-retry-btn___3BCvF",
                                onClick: this.handleRetry
                            }, g("i", {
                                className: "style__model-retry-logo___hfW1Y"
                            }), g("span", null, c("v4.common.3dmodel.loadind_error.reload")))))
                        }
                    }]), n
                }(d.a.Component);
            e.default = Object(p.a)(b)
        },
        Wymu: function(t, e, n) {
            "use strict";
            String(Math.random()).slice(2), window.trustedTypes && trustedTypes.createPolicy("lit-html", {
                createHTML: t => t
            });
            let i = !1;
            (() => {
                try {
                    const t = {
                        get capture() {
                            return i = !0, !1
                        }
                    };
                    window.addEventListener("test", t, t), window.removeEventListener("test", t, t)
                } catch (Dp) {}
            })(), "undefined" !== typeof window && (window.litHtmlVersions || (window.litHtmlVersions = [])).push("1.3.0"), "undefined" === typeof window.ShadyCSS || "undefined" === typeof window.ShadyCSS.prepareTemplateDom && console.warn("Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1."), window.JSCompiler_renameProperty = (t, e) => t;
            const r = {
                    toAttribute(t, e) {
                        switch (e) {
                            case Boolean:
                                return t ? "" : null;
                            case Object:
                            case Array:
                                return null == t ? t : JSON.stringify(t)
                        }
                        return t
                    },
                    fromAttribute(t, e) {
                        switch (e) {
                            case Boolean:
                                return null !== t;
                            case Number:
                                return null === t ? null : Number(t);
                            case Object:
                            case Array:
                                return JSON.parse(t)
                        }
                        return t
                    }
                },
                s = (t, e) => e !== t && (e === e || t === t),
                o = {
                    attribute: !0,
                    type: String,
                    converter: r,
                    reflect: !1,
                    hasChanged: s
                },
                a = 1,
                l = 4,
                c = 8,
                h = 16,
                u = "finalized";
            class d extends HTMLElement {
                constructor() {
                    super(), this.initialize()
                }
                static get observedAttributes() {
                    this.finalize();
                    const t = [];
                    return this._classProperties.forEach((e, n) => {
                        const i = this._attributeNameForProperty(n, e);
                        void 0 !== i && (this._attributeToPropertyMap.set(i, n), t.push(i))
                    }), t
                }
                static _ensureClassProperties() {
                    if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) {
                        this._classProperties = new Map;
                        const t = Object.getPrototypeOf(this)._classProperties;
                        void 0 !== t && t.forEach((t, e) => this._classProperties.set(e, t))
                    }
                }
                static createProperty(t, e = o) {
                    if (this._ensureClassProperties(), this._classProperties.set(t, e), e.noAccessor || this.prototype.hasOwnProperty(t)) return;
                    const n = "symbol" === typeof t ? Symbol() : `__${t}`,
                        i = this.getPropertyDescriptor(t, n, e);
                    void 0 !== i && Object.defineProperty(this.prototype, t, i)
                }
                static getPropertyDescriptor(t, e, n) {
                    return {
                        get() {
                            return this[e]
                        },
                        set(i) {
                            const r = this[t];
                            this[e] = i, this.requestUpdateInternal(t, r, n)
                        },
                        configurable: !0,
                        enumerable: !0
                    }
                }
                static getPropertyOptions(t) {
                    return this._classProperties && this._classProperties.get(t) || o
                }
                static finalize() {
                    const t = Object.getPrototypeOf(this);
                    if (t.hasOwnProperty(u) || t.finalize(), this[u] = !0, this._ensureClassProperties(), this._attributeToPropertyMap = new Map, this.hasOwnProperty(JSCompiler_renameProperty("properties", this))) {
                        const t = this.properties,
                            e = [...Object.getOwnPropertyNames(t), ..."function" === typeof Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(t) : []];
                        for (const n of e) this.createProperty(n, t[n])
                    }
                }
                static _attributeNameForProperty(t, e) {
                    const n = e.attribute;
                    return !1 === n ? void 0 : "string" === typeof n ? n : "string" === typeof t ? t.toLowerCase() : void 0
                }
                static _valueHasChanged(t, e, n = s) {
                    return n(t, e)
                }
                static _propertyValueFromAttribute(t, e) {
                    const n = e.type,
                        i = e.converter || r,
                        s = "function" === typeof i ? i : i.fromAttribute;
                    return s ? s(t, n) : t
                }
                static _propertyValueToAttribute(t, e) {
                    if (void 0 === e.reflect) return;
                    const n = e.type,
                        i = e.converter;
                    return (i && i.toAttribute || r.toAttribute)(t, n)
                }
                initialize() {
                    this._updateState = 0, this._updatePromise = new Promise(t => this._enableUpdatingResolver = t), this._changedProperties = new Map, this._saveInstanceProperties(), this.requestUpdateInternal()
                }
                _saveInstanceProperties() {
                    this.constructor._classProperties.forEach((t, e) => {
                        if (this.hasOwnProperty(e)) {
                            const t = this[e];
                            delete this[e], this._instanceProperties || (this._instanceProperties = new Map), this._instanceProperties.set(e, t)
                        }
                    })
                }
                _applyInstanceProperties() {
                    this._instanceProperties.forEach((t, e) => this[e] = t), this._instanceProperties = void 0
                }
                connectedCallback() {
                    this.enableUpdating()
                }
                enableUpdating() {
                    void 0 !== this._enableUpdatingResolver && (this._enableUpdatingResolver(), this._enableUpdatingResolver = void 0)
                }
                disconnectedCallback() {}
                attributeChangedCallback(t, e, n) {
                    e !== n && this._attributeToProperty(t, n)
                }
                _propertyToAttribute(t, e, n = o) {
                    const i = this.constructor,
                        r = i._attributeNameForProperty(t, n);
                    if (void 0 !== r) {
                        const t = i._propertyValueToAttribute(e, n);
                        if (void 0 === t) return;
                        this._updateState = this._updateState | c, null == t ? this.removeAttribute(r) : this.setAttribute(r, t), this._updateState = this._updateState & ~c
                    }
                }
                _attributeToProperty(t, e) {
                    if (this._updateState & c) return;
                    const n = this.constructor,
                        i = n._attributeToPropertyMap.get(t);
                    if (void 0 !== i) {
                        const t = n.getPropertyOptions(i);
                        this._updateState = this._updateState | h, this[i] = n._propertyValueFromAttribute(e, t), this._updateState = this._updateState & ~h
                    }
                }
                requestUpdateInternal(t, e, n) {
                    let i = !0;
                    if (void 0 !== t) {
                        const r = this.constructor;
                        n = n || r.getPropertyOptions(t), r._valueHasChanged(this[t], e, n.hasChanged) ? (this._changedProperties.has(t) || this._changedProperties.set(t, e), !0 !== n.reflect || this._updateState & h || (void 0 === this._reflectingProperties && (this._reflectingProperties = new Map), this._reflectingProperties.set(t, n))) : i = !1
                    }!this._hasRequestedUpdate && i && (this._updatePromise = this._enqueueUpdate())
                }
                requestUpdate(t, e) {
                    return this.requestUpdateInternal(t, e), this.updateComplete
                }
                async _enqueueUpdate() {
                    this._updateState = this._updateState | l;
                    try {
                        await this._updatePromise
                    } catch (e) {}
                    const t = this.performUpdate();
                    return null != t && await t, !this._hasRequestedUpdate
                }
                get _hasRequestedUpdate() {
                    return this._updateState & l
                }
                get hasUpdated() {
                    return this._updateState & a
                }
                performUpdate() {
                    if (!this._hasRequestedUpdate) return;
                    this._instanceProperties && this._applyInstanceProperties();
                    let t = !1;
                    const e = this._changedProperties;
                    try {
                        t = this.shouldUpdate(e), t ? this.update(e) : this._markUpdated()
                    } catch (n) {
                        throw t = !1, this._markUpdated(), n
                    }
                    t && (this._updateState & a || (this._updateState = this._updateState | a, this.firstUpdated(e)), this.updated(e))
                }
                _markUpdated() {
                    this._changedProperties = new Map, this._updateState = this._updateState & ~l
                }
                get updateComplete() {
                    return this._getUpdateComplete()
                }
                _getUpdateComplete() {
                    return this._updatePromise
                }
                shouldUpdate(t) {
                    return !0
                }
                update(t) {
                    void 0 !== this._reflectingProperties && this._reflectingProperties.size > 0 && (this._reflectingProperties.forEach((t, e) => this._propertyToAttribute(e, this[e], t)), this._reflectingProperties = void 0), this._markUpdated()
                }
                updated(t) {}
                firstUpdated(t) {}
            }
            d[u] = !0;
            const p = (t, e) => "method" !== e.kind || !e.descriptor || "value" in e.descriptor ? {
                    kind: "field",
                    key: Symbol(),
                    placement: "own",
                    descriptor: {},
                    initializer() {
                        "function" === typeof e.initializer && (this[e.key] = e.initializer.call(this))
                    },
                    finisher(n) {
                        n.createProperty(e.key, t)
                    }
                } : Object.assign(Object.assign({}, e), {
                    finisher(n) {
                        n.createProperty(e.key, t)
                    }
                }),
                m = (t, e, n) => {
                    e.constructor.createProperty(n, t)
                };

            function f(t) {
                return (e, n) => void 0 !== n ? m(t, e, n) : p(t, e)
            }
            window.ShadowRoot && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && CSSStyleSheet.prototype;
            (window.litElementVersions || (window.litElementVersions = [])).push("2.4.0");
            const g = null != navigator.xr && null != self.XRSession && null != navigator.xr.isSessionSupported,
                v = g && self.XRSession.prototype.requestHitTestSource,
                y = null != self.ResizeObserver,
                x = null != self.IntersectionObserver,
                b = v,
                _ = ((() => {
                    const t = navigator.userAgent || navigator.vendor || self.opera;
                    let e = !1;
                    (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0)
                })(), /\bCrOS\b/.test(navigator.userAgent), !1),
                w = /android/i.test(navigator.userAgent),
                M = /iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1,
                S = (() => {
                    const t = document.createElement("a");
                    return Boolean(t.relList && t.relList.supports && t.relList.supports("ar"))
                })(),
                T = /Safari\//.test(navigator.userAgent),
                E = /firefox/i.test(navigator.userAgent),
                A = /OculusBrowser/.test(navigator.userAgent),
                L = M && /CriOS\//.test(navigator.userAgent),
                R = M && T,
                P = w && !E && !A;
            const C = document.createElement("template");
            C.innerHTML = '\n<style>\n:host {\n  display: block;\n  position: relative;\n  contain: strict;\n  width: 300px;\n  height: 150px;\n}\n\n/* NOTE: This ruleset is our integration surface area with the\n * :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196 */\n:host([data-js-focus-visible]:focus:not(.focus-visible)),\n:host([data-js-focus-visible]) :focus:not(.focus-visible) {\n  outline: none;\n}\n\n.container {\n  position: relative;\n}\n\n.userInput {\n  width: 100%;\n  height: 100%;\n  display: block;\n  position: relative;\n  overflow: hidden;\n}\n\ncanvas {\n  position: absolute;\n  display: none;\n  pointer-events: none;\n  /* NOTE(cdata): Chrome 76 and below apparently have a bug\n   * that causes our canvas not to display pixels unless it is\n   * on its own render layer\n   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893\n   */\n  transform: translateZ(0);\n}\n\ncanvas.show {\n  display: block;\n}\n\n/* Adapted from HTML5 Boilerplate\n *\n * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */\n.screen-reader-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  white-space: nowrap;\n  width: 1px;\n}\n\n.slot {\n  position: absolute;\n  pointer-events: none;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.slot > * {\n  pointer-events: initial;\n}\n\n.annotation-wrapper ::slotted(*) {\n  opacity: var(--max-hotspot-opacity, 1);\n  transition: opacity 0.3s;\n}\n\n.pointer-tumbling .annotation-wrapper ::slotted(*) {\n  pointer-events: none;\n}\n\n.annotation-wrapper ::slotted(*) {\n  pointer-events: initial;\n}\n\n.annotation-wrapper.hide ::slotted(*) {\n  opacity: var(--min-hotspot-opacity, 0.25);\n}\n\n.slot.poster {\n  opacity: 0;\n  transition: opacity 0.3s 0.3s;\n  background-color: inherit;\n}\n\n.slot.poster.show {\n  opacity: 1;\n  transition: none;\n}\n\n.slot.poster > * {\n  pointer-events: initial;\n}\n\n.slot.poster:not(.show) > * {\n  pointer-events: none;\n}\n\n#default-poster {\n  width: 100%;\n  height: 100%;\n  /* The default poster is a <button> so we need to set display\n   * to prevent it from being affected by text-align: */\n  display: block;\n  position: absolute;\n  border: none;\n  padding: 0;\n  background-size: contain;\n  background-repeat: no-repeat;\n  background-position: center;\n  background-color: var(--poster-color, #fff);\n  background-image: var(--poster-image, none);\n}\n\n#default-progress-bar {\n  display: block;\n  position: relative;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  overflow: hidden;\n}\n\n#default-progress-bar > .mask {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: var(--progress-mask, #fff);\n  transition: opacity 0.3s;\n  opacity: 0.2;\n}\n\n#default-progress-bar > .bar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: var(--progress-bar-height, 5px);\n  transition: transform 0.09s;\n  transform-origin: top left;\n  transform: scaleX(0);\n  overflow: hidden;\n}\n\n#default-progress-bar > .bar:before {\n  content: \'\';\n  display: block;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n\n  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));\n\n  transition: none;\n  transform-origin: top left;\n  transform: translateY(0);\n}\n\n#default-progress-bar > .bar.hide:before {\n  transition: transform 0.3s 1s;\n  transform: translateY(-100%);\n}\n\n.slot.interaction-prompt {\n  display: var(--interaction-prompt-display, flex);\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  align-items: center;\n  justify-content: center;\n\n  opacity: 0;\n  will-change: opacity;\n  overflow: hidden;\n  transition: opacity 0.3s;\n}\n\n.slot.interaction-prompt.visible {\n  opacity: 1;\n}\n\n.slot.interaction-prompt > .animated-container {\n  will-change: transform, opacity;\n}\n\n.slot.interaction-prompt > * {\n  pointer-events: none;\n}\n\n.slot.ar-button {\n  -moz-user-select: none;\n  -webkit-tap-highlight-color: transparent;\n  user-select: none;\n\n  display: var(--ar-button-display, block);\n}\n\n.slot.ar-button:not(.enabled) {\n  display: none;\n}\n\n.fab {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  width: 40px;\n  height: 40px;\n  cursor: pointer;\n  background-color: #fff;\n  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);\n  border-radius: 100px;\n}\n\n.fab > * {\n  opacity: 0.87;\n}\n\n#default-ar-button {\n  position: absolute;\n  bottom: 16px;\n  right: 16px;\n  transform: scale(var(--ar-button-scale, 1));\n  transform-origin: bottom right;\n}\n\n.slot.default {\n  pointer-events: none;\n}\n\n.slot.progress-bar {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button:not(.enabled) {\n  display: none;\n}\n\n#default-exit-webxr-ar-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  top: 16px;\n  left: 16px;\n  width: 40px;\n  height: 40px;\n  box-sizing: border-box;\n}\n\n#default-exit-webxr-ar-button > svg {\n  fill: #fff;\n}\n</style>\n<div class="container">\n  <div class="userInput" tabindex="0" role="img"\n      aria-label="A depiction of a 3D model"\n      aria-live="polite">\n    <canvas></canvas>\n  </div>\n\n  \x3c!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM\n        will have their <slot> elements removed by ShadyCSS --\x3e\n  <div class="slot poster">\n    <slot name="poster">\n      <button type="button" id="default-poster" aria-hidden="true" aria-label="Activate to view in 3D!"></button>\n    </slot>\n  </div>\n\n  <div class="slot ar-button">\n    <slot name="ar-button">\n      <a id="default-ar-button" class="fab"\n          tabindex="2"\n          aria-label="View this 3D model up close">\n        \n<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"\n\t xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"\n\t viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">\n<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>\n<g id="Art_layer">\n\t<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>\n\t<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>\n\t<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>\n\t<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>\n\t<g>\n\t\t<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3\n\t\t\tl5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62\n\t\t\tl4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>\n\t</g>\n</g>\n</svg>\n      </a>\n    </slot>\n  </div>\n\n  <div class="slot interaction-prompt">\n    <div class="animated-container" part="interaction-prompt">\n      <slot name="interaction-prompt" aria-hidden="true">\n        \n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">\n    <defs>\n        <path id="A" d="M.001.232h24.997V36H.001z" />\n    </defs>\n    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">\n        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />\n        <g transform="translate(11 3)">\n            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />\n            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />\n            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />\n            <g transform="translate(0 .769)">\n                <mask id="B" fill="#fff">\n                    <use xlink:href="#A" />\n                </mask>\n                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />\n            </g>\n        </g>\n    </g>\n</svg>\n      </slot>\n    </div>\n  </div>\n\n  <div class="slot default">\n    <slot></slot>\n\n    <div class="slot progress-bar">\n      <slot name="progress-bar">\n        <div id="default-progress-bar" aria-hidden="true">\n          <div class="mask"></div>\n          <div class="bar"></div>\n        </div>\n      </slot>\n    </div>\n    \n    <div class="slot exit-webxr-ar-button">\n      <slot name="exit-webxr-ar-button">\n        <a id="default-exit-webxr-ar-button"\n            tabindex="3"\n            aria-label="Exit AR"\n            aria-hidden="true">\n          \n<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">\n    \x3c!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement\n         support for dynamic re-coloring of UI components --\x3e\n    <defs>\n      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">\n        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>\n        <feOffset dx="0" dy="0" result="offsetblur"/>\n        <feFlood flood-color="#000000"/>\n        <feComposite in2="offsetblur" operator="in"/>\n        <feMerge>\n          <feMergeNode/>\n          <feMergeNode in="SourceGraphic"/>\n        </feMerge>\n      </filter>\n    </defs>\n    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>\n        </a>\n      </slot>\n    </div>\n  </div>\n</div>';
            const O = t => {
                    const e = document.createElement("template");
                    return e.innerHTML = C.innerHTML, window.ShadyCSS && window.ShadyCSS.prepareTemplate(e, t), e
                },
                I = 0,
                N = 1,
                D = 2,
                F = 1,
                U = 2,
                z = 3,
                k = 0,
                B = 1,
                H = 2,
                G = 0,
                V = 1,
                j = 2,
                W = 3,
                q = 4,
                X = 5,
                Y = 100,
                J = 101,
                Z = 102,
                K = 103,
                $ = 104,
                Q = 200,
                tt = 201,
                et = 202,
                nt = 203,
                it = 204,
                rt = 205,
                st = 206,
                ot = 207,
                at = 208,
                lt = 209,
                ct = 210,
                ht = 0,
                ut = 1,
                dt = 2,
                pt = 3,
                mt = 4,
                ft = 5,
                gt = 6,
                vt = 7,
                yt = 0,
                xt = 1,
                bt = 2,
                _t = 0,
                wt = 1,
                Mt = 2,
                St = 3,
                Tt = 4,
                Et = 5,
                At = 301,
                Lt = 302,
                Rt = 303,
                Pt = 304,
                Ct = 306,
                Ot = 307,
                It = 1e3,
                Nt = 1001,
                Dt = 1002,
                Ft = 1003,
                Ut = 1004,
                zt = 1005,
                kt = 1006,
                Bt = 1007,
                Ht = 1008,
                Gt = 1009,
                Vt = 1010,
                jt = 1011,
                Wt = 1012,
                qt = 1013,
                Xt = 1014,
                Yt = 1015,
                Jt = 1016,
                Zt = 1017,
                Kt = 1018,
                $t = 1019,
                Qt = 1020,
                te = 1021,
                ee = 1022,
                ne = 1023,
                ie = 1024,
                re = 1025,
                se = ne,
                oe = 1026,
                ae = 1027,
                le = 1028,
                ce = 1029,
                he = 1030,
                ue = 1031,
                de = 1032,
                pe = 1033,
                me = 33776,
                fe = 33777,
                ge = 33778,
                ve = 33779,
                ye = 35840,
                xe = 35841,
                be = 35842,
                _e = 35843,
                we = 36196,
                Me = 37492,
                Se = 37496,
                Te = 37808,
                Ee = 37809,
                Ae = 37810,
                Le = 37811,
                Re = 37812,
                Pe = 37813,
                Ce = 37814,
                Oe = 37815,
                Ie = 37816,
                Ne = 37817,
                De = 37818,
                Fe = 37819,
                Ue = 37820,
                ze = 37821,
                ke = 36492,
                Be = 37840,
                He = 37841,
                Ge = 37842,
                Ve = 37843,
                je = 37844,
                We = 37845,
                qe = 37846,
                Xe = 37847,
                Ye = 37848,
                Je = 37849,
                Ze = 37850,
                Ke = 37851,
                $e = 37852,
                Qe = 37853,
                tn = 2200,
                en = 2201,
                nn = 2202,
                rn = 2300,
                sn = 2400,
                on = 2401,
                an = 2402,
                ln = 2500,
                cn = 2501,
                hn = 2,
                un = 3e3,
                dn = 3001,
                pn = 3007,
                mn = 3002,
                fn = 3003,
                gn = 3004,
                vn = 3005,
                yn = 3006,
                xn = 3200,
                bn = 3201,
                _n = 0,
                wn = 1,
                Mn = 7680,
                Sn = 519,
                Tn = 35044,
                En = "300 es";

            function An() {}
            Object.assign(An.prototype, {
                addEventListener: function(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    const n = this._listeners;
                    void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                },
                hasEventListener: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    const n = this._listeners;
                    return void 0 !== n[t] && -1 !== n[t].indexOf(e)
                },
                removeEventListener: function(t, e) {
                    if (void 0 === this._listeners) return;
                    const n = this._listeners[t];
                    if (void 0 !== n) {
                        const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                    }
                },
                dispatchEvent: function(t) {
                    if (void 0 === this._listeners) return;
                    const e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        const n = e.slice(0);
                        for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t)
                    }
                }
            });
            const Ln = [];
            for (let MM = 0; MM < 256; MM++) Ln[MM] = (MM < 16 ? "0" : "") + MM.toString(16);
            let Rn = 1234567;
            const Pn = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function() {
                    const t = 4294967295 * Math.random() | 0,
                        e = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        i = 4294967295 * Math.random() | 0;
                    return (Ln[255 & t] + Ln[t >> 8 & 255] + Ln[t >> 16 & 255] + Ln[t >> 24 & 255] + "-" + Ln[255 & e] + Ln[e >> 8 & 255] + "-" + Ln[e >> 16 & 15 | 64] + Ln[e >> 24 & 255] + "-" + Ln[63 & n | 128] + Ln[n >> 8 & 255] + "-" + Ln[n >> 16 & 255] + Ln[n >> 24 & 255] + Ln[255 & i] + Ln[i >> 8 & 255] + Ln[i >> 16 & 255] + Ln[i >> 24 & 255]).toUpperCase()
                },
                clamp: function(t, e, n) {
                    return Math.max(e, Math.min(n, t))
                },
                euclideanModulo: function(t, e) {
                    return (t % e + e) % e
                },
                mapLinear: function(t, e, n, i, r) {
                    return i + (t - e) * (r - i) / (n - e)
                },
                lerp: function(t, e, n) {
                    return (1 - n) * t + n * e
                },
                smoothstep: function(t, e, n) {
                    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
                },
                smootherstep: function(t, e, n) {
                    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
                },
                randInt: function(t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1))
                },
                randFloat: function(t, e) {
                    return t + Math.random() * (e - t)
                },
                randFloatSpread: function(t) {
                    return t * (.5 - Math.random())
                },
                seededRandom: function(t) {
                    return void 0 !== t && (Rn = t % 2147483647), Rn = 16807 * Rn % 2147483647, (Rn - 1) / 2147483646
                },
                degToRad: function(t) {
                    return t * Pn.DEG2RAD
                },
                radToDeg: function(t) {
                    return t * Pn.RAD2DEG
                },
                isPowerOfTwo: function(t) {
                    return 0 === (t & t - 1) && 0 !== t
                },
                ceilPowerOfTwo: function(t) {
                    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                },
                floorPowerOfTwo: function(t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                },
                setQuaternionFromProperEuler: function(t, e, n, i, r) {
                    const s = Math.cos,
                        o = Math.sin,
                        a = s(n / 2),
                        l = o(n / 2),
                        c = s((e + i) / 2),
                        h = o((e + i) / 2),
                        u = s((e - i) / 2),
                        d = o((e - i) / 2),
                        p = s((i - e) / 2),
                        m = o((i - e) / 2);
                    switch (r) {
                        case "XYX":
                            t.set(a * h, l * u, l * d, a * c);
                            break;
                        case "YZY":
                            t.set(l * d, a * h, l * u, a * c);
                            break;
                        case "ZXZ":
                            t.set(l * u, l * d, a * h, a * c);
                            break;
                        case "XZX":
                            t.set(a * h, l * m, l * p, a * c);
                            break;
                        case "YXY":
                            t.set(l * p, a * h, l * m, a * c);
                            break;
                        case "ZYZ":
                            t.set(l * m, l * p, a * h, a * c);
                            break;
                        default:
                            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                    }
                }
            };
            class Cn {
                constructor(t = 0, e = 0) {
                    Object.defineProperty(this, "isVector2", {
                        value: !0
                    }), this.x = t, this.y = e
                }
                get width() {
                    return this.x
                }
                set width(t) {
                    this.x = t
                }
                get height() {
                    return this.y
                }
                set height(t) {
                    this.y = t
                }
                set(t, e) {
                    return this.x = t, this.y = e, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this
                }
                multiply(t) {
                    return this.x *= t.x, this.y *= t.y, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                applyMatrix3(t) {
                    const e = this.x,
                        n = this.y,
                        i = t.elements;
                    return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
                }
                clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y
                }
                cross(t) {
                    return this.x * t.y - this.y * t.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        n = this.y - t.y;
                    return e * e + n * n
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                }
                lerpVectors(t, e, n) {
                    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y
                }
                fromArray(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
                }
                toArray(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
                }
                fromBufferAttribute(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                }
                rotateAround(t, e) {
                    const n = Math.cos(e),
                        i = Math.sin(e),
                        r = this.x - t.x,
                        s = this.y - t.y;
                    return this.x = r * n - s * i + t.x, this.y = r * i + s * n + t.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }
            }
            class On {
                constructor() {
                    Object.defineProperty(this, "isMatrix3", {
                        value: !0
                    }), this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                }
                set(t, e, n, i, r, s, o, a, l) {
                    const c = this.elements;
                    return c[0] = t, c[1] = i, c[2] = o, c[3] = e, c[4] = r, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                clone() {
                    return (new this.constructor).fromArray(this.elements)
                }
                copy(t) {
                    const e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
                }
                extractBasis(t, e, n) {
                    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(t) {
                    const e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                }
                multiply(t) {
                    return this.multiplyMatrices(this, t)
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this)
                }
                multiplyMatrices(t, e) {
                    const n = t.elements,
                        i = e.elements,
                        r = this.elements,
                        s = n[0],
                        o = n[3],
                        a = n[6],
                        l = n[1],
                        c = n[4],
                        h = n[7],
                        u = n[2],
                        d = n[5],
                        p = n[8],
                        m = i[0],
                        f = i[3],
                        g = i[6],
                        v = i[1],
                        y = i[4],
                        x = i[7],
                        b = i[2],
                        _ = i[5],
                        w = i[8];
                    return r[0] = s * m + o * v + a * b, r[3] = s * f + o * y + a * _, r[6] = s * g + o * x + a * w, r[1] = l * m + c * v + h * b, r[4] = l * f + c * y + h * _, r[7] = l * g + c * x + h * w, r[2] = u * m + d * v + p * b, r[5] = u * f + d * y + p * _, r[8] = u * g + d * x + p * w, this
                }
                multiplyScalar(t) {
                    const e = this.elements;
                    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3],
                        s = t[4],
                        o = t[5],
                        a = t[6],
                        l = t[7],
                        c = t[8];
                    return e * s * c - e * o * l - n * r * c + n * o * a + i * r * l - i * s * a
                }
                getInverse(t, e) {
                    void 0 !== e && console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
                    const n = t.elements,
                        i = this.elements,
                        r = n[0],
                        s = n[1],
                        o = n[2],
                        a = n[3],
                        l = n[4],
                        c = n[5],
                        h = n[6],
                        u = n[7],
                        d = n[8],
                        p = d * l - c * u,
                        m = c * h - d * a,
                        f = u * a - l * h,
                        g = r * p + s * m + o * f;
                    if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const v = 1 / g;
                    return i[0] = p * v, i[1] = (o * u - d * s) * v, i[2] = (c * s - o * l) * v, i[3] = m * v, i[4] = (d * r - o * h) * v, i[5] = (o * a - c * r) * v, i[6] = f * v, i[7] = (s * h - u * r) * v, i[8] = (l * r - s * a) * v, this
                }
                transpose() {
                    let t;
                    const e = this.elements;
                    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                }
                getNormalMatrix(t) {
                    return this.setFromMatrix4(t).getInverse(this).transpose()
                }
                transposeIntoArray(t) {
                    const e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                }
                setUvTransform(t, e, n, i, r, s, o) {
                    const a = Math.cos(r),
                        l = Math.sin(r);
                    this.set(n * a, n * l, -n * (a * s + l * o) + s + t, -i * l, i * a, -i * (-l * s + a * o) + o + e, 0, 0, 1)
                }
                scale(t, e) {
                    const n = this.elements;
                    return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
                }
                rotate(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t),
                        i = this.elements,
                        r = i[0],
                        s = i[3],
                        o = i[6],
                        a = i[1],
                        l = i[4],
                        c = i[7];
                    return i[0] = e * r + n * a, i[3] = e * s + n * l, i[6] = e * o + n * c, i[1] = -n * r + e * a, i[4] = -n * s + e * l, i[7] = -n * o + e * c, this
                }
                translate(t, e) {
                    const n = this.elements;
                    return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
                }
                equals(t) {
                    const e = this.elements,
                        n = t.elements;
                    for (let i = 0; i < 9; i++)
                        if (e[i] !== n[i]) return !1;
                    return !0
                }
                fromArray(t, e) {
                    void 0 === e && (e = 0);
                    for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                    return this
                }
                toArray(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    const n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                }
            }
            let In;
            const Nn = {
                getDataURL: function(t) {
                    if (/^data:/i.test(t.src)) return t.src;
                    if ("undefined" == typeof HTMLCanvasElement) return t.src;
                    let e;
                    if (t instanceof HTMLCanvasElement) e = t;
                    else {
                        void 0 === In && (In = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), In.width = t.width, In.height = t.height;
                        const n = In.getContext("2d");
                        t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = In
                    }
                    return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                }
            };
            let Dn = 0;

            function Fn(t, e, n, i, r, s, o, a, l, c) {
                Object.defineProperty(this, "id", {
                    value: Dn++
                }), this.uuid = Pn.generateUUID(), this.name = "", this.image = void 0 !== t ? t : Fn.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : Fn.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : Nt, this.wrapT = void 0 !== i ? i : Nt, this.magFilter = void 0 !== r ? r : kt, this.minFilter = void 0 !== s ? s : Ht, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== o ? o : ne, this.internalFormat = null, this.type = void 0 !== a ? a : Gt, this.offset = new Cn(0, 0), this.repeat = new Cn(1, 1), this.center = new Cn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new On, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== c ? c : un, this.version = 0, this.onUpdate = null
            }
            Fn.DEFAULT_IMAGE = void 0, Fn.DEFAULT_MAPPING = 300, Fn.prototype = Object.assign(Object.create(An.prototype), {
                constructor: Fn,
                isTexture: !0,
                updateMatrix: function() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
                },
                toJSON: function(t) {
                    const e = void 0 === t || "string" === typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    const n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    if (void 0 !== this.image) {
                        const i = this.image;
                        if (void 0 === i.uuid && (i.uuid = Pn.generateUUID()), !e && void 0 === t.images[i.uuid]) {
                            let e;
                            if (Array.isArray(i)) {
                                e = [];
                                for (let t = 0, n = i.length; t < n; t++) e.push(Nn.getDataURL(i[t]))
                            } else e = Nn.getDataURL(i);
                            t.images[i.uuid] = {
                                uuid: i.uuid,
                                url: e
                            }
                        }
                        n.image = i.uuid
                    }
                    return e || (t.textures[this.uuid] = n), n
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(t) {
                    if (300 !== this.mapping) return t;
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case It:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case Nt:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case Dt:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case It:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case Nt:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case Dt:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    return this.flipY && (t.y = 1 - t.y), t
                }
            }), Object.defineProperty(Fn.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            });
            class Un {
                constructor(t = 0, e = 0, n = 0, i = 1) {
                    Object.defineProperty(this, "isVector4", {
                        value: !0
                    }), this.x = t, this.y = e, this.z = n, this.w = i
                }
                get width() {
                    return this.z
                }
                set width(t) {
                    this.z = t
                }
                get height() {
                    return this.w
                }
                set height(t) {
                    this.w = t
                }
                set(t, e, n, i) {
                    return this.x = t, this.y = e, this.z = n, this.w = i, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setZ(t) {
                    return this.z = t, this
                }
                setW(t) {
                    return this.w = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this.z += t, this.w += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                }
                applyMatrix4(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w,
                        s = t.elements;
                    return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                setAxisAngleFromQuaternion(t) {
                    this.w = 2 * Math.acos(t.w);
                    const e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                }
                setAxisAngleFromRotationMatrix(t) {
                    let e, n, i, r;
                    const s = t.elements,
                        o = s[0],
                        a = s[4],
                        l = s[8],
                        c = s[1],
                        h = s[5],
                        u = s[9],
                        d = s[2],
                        p = s[6],
                        m = s[10];
                    if (Math.abs(a - c) < .01 && Math.abs(l - d) < .01 && Math.abs(u - p) < .01) {
                        if (Math.abs(a + c) < .1 && Math.abs(l + d) < .1 && Math.abs(u + p) < .1 && Math.abs(o + h + m - 3) < .1) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        const t = (o + 1) / 2,
                            s = (h + 1) / 2,
                            f = (m + 1) / 2,
                            g = (a + c) / 4,
                            v = (l + d) / 4,
                            y = (u + p) / 4;
                        return t > s && t > f ? t < .01 ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = g / n, r = v / n) : s > f ? s < .01 ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(s), n = g / i, r = y / i) : f < .01 ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(f), n = v / r, i = y / r), this.set(n, i, r, e), this
                    }
                    let f = Math.sqrt((p - u) * (p - u) + (l - d) * (l - d) + (c - a) * (c - a));
                    return Math.abs(f) < .001 && (f = 1), this.x = (p - u) / f, this.y = (l - d) / f, this.z = (c - a) / f, this.w = Math.acos((o + h + m - 1) / 2), this
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
                }
                clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                }
                lerpVectors(t, e, n) {
                    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                }
                fromArray(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                }
                toArray(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                }
                fromBufferAttribute(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }
            }

            function zn(t, e, n) {
                this.width = t, this.height = e, this.scissor = new Un(0, 0, t, e), this.scissorTest = !1, this.viewport = new Un(0, 0, t, e), n = n || {}, this.texture = new Fn(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : kt, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }

            function kn(t, e, n) {
                zn.call(this, t, e, n), this.samples = 4
            }
            zn.prototype = Object.assign(Object.create(An.prototype), {
                constructor: zn,
                isWebGLRenderTarget: !0,
                setSize: function(t, e) {
                    this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), kn.prototype = Object.assign(Object.create(zn.prototype), {
                constructor: kn,
                isWebGLMultisampleRenderTarget: !0,
                copy: function(t) {
                    return zn.prototype.copy.call(this, t), this.samples = t.samples, this
                }
            });
            class Bn {
                constructor(t = 0, e = 0, n = 0, i = 1) {
                    Object.defineProperty(this, "isQuaternion", {
                        value: !0
                    }), this._x = t, this._y = e, this._z = n, this._w = i
                }
                static slerp(t, e, n, i) {
                    return n.copy(t).slerp(e, i)
                }
                static slerpFlat(t, e, n, i, r, s, o) {
                    let a = n[i + 0],
                        l = n[i + 1],
                        c = n[i + 2],
                        h = n[i + 3];
                    const u = r[s + 0],
                        d = r[s + 1],
                        p = r[s + 2],
                        m = r[s + 3];
                    if (h !== m || a !== u || l !== d || c !== p) {
                        let t = 1 - o;
                        const e = a * u + l * d + c * p + h * m,
                            n = e >= 0 ? 1 : -1,
                            i = 1 - e * e;
                        if (i > Number.EPSILON) {
                            const r = Math.sqrt(i),
                                s = Math.atan2(r, e * n);
                            t = Math.sin(t * s) / r, o = Math.sin(o * s) / r
                        }
                        const r = o * n;
                        if (a = a * t + u * r, l = l * t + d * r, c = c * t + p * r, h = h * t + m * r, t === 1 - o) {
                            const t = 1 / Math.sqrt(a * a + l * l + c * c + h * h);
                            a *= t, l *= t, c *= t, h *= t
                        }
                    }
                    t[e] = a, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h
                }
                static multiplyQuaternionsFlat(t, e, n, i, r, s) {
                    const o = n[i],
                        a = n[i + 1],
                        l = n[i + 2],
                        c = n[i + 3],
                        h = r[s],
                        u = r[s + 1],
                        d = r[s + 2],
                        p = r[s + 3];
                    return t[e] = o * p + c * h + a * d - l * u, t[e + 1] = a * p + c * u + l * h - o * d, t[e + 2] = l * p + c * d + o * u - a * h, t[e + 3] = c * p - o * h - a * u - l * d, t
                }
                get x() {
                    return this._x
                }
                set x(t) {
                    this._x = t, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(t) {
                    this._y = t, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(t) {
                    this._z = t, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(t) {
                    this._w = t, this._onChangeCallback()
                }
                set(t, e, n, i) {
                    return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                }
                setFromEuler(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    const n = t._x,
                        i = t._y,
                        r = t._z,
                        s = t._order,
                        o = Math.cos,
                        a = Math.sin,
                        l = o(n / 2),
                        c = o(i / 2),
                        h = o(r / 2),
                        u = a(n / 2),
                        d = a(i / 2),
                        p = a(r / 2);
                    switch (s) {
                        case "XYZ":
                            this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                            break;
                        case "YXZ":
                            this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                            break;
                        case "ZXY":
                            this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                            break;
                        case "ZYX":
                            this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                            break;
                        case "YZX":
                            this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
                            break;
                        case "XZY":
                            this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p;
                            break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                    }
                    return !1 !== e && this._onChangeCallback(), this
                }
                setFromAxisAngle(t, e) {
                    const n = e / 2,
                        i = Math.sin(n);
                    return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
                }
                setFromRotationMatrix(t) {
                    const e = t.elements,
                        n = e[0],
                        i = e[4],
                        r = e[8],
                        s = e[1],
                        o = e[5],
                        a = e[9],
                        l = e[2],
                        c = e[6],
                        h = e[10],
                        u = n + o + h;
                    if (u > 0) {
                        const t = .5 / Math.sqrt(u + 1);
                        this._w = .25 / t, this._x = (c - a) * t, this._y = (r - l) * t, this._z = (s - i) * t
                    } else if (n > o && n > h) {
                        const t = 2 * Math.sqrt(1 + n - o - h);
                        this._w = (c - a) / t, this._x = .25 * t, this._y = (i + s) / t, this._z = (r + l) / t
                    } else if (o > h) {
                        const t = 2 * Math.sqrt(1 + o - n - h);
                        this._w = (r - l) / t, this._x = (i + s) / t, this._y = .25 * t, this._z = (a + c) / t
                    } else {
                        const t = 2 * Math.sqrt(1 + h - n - o);
                        this._w = (s - i) / t, this._x = (r + l) / t, this._y = (a + c) / t, this._z = .25 * t
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(t, e) {
                    let n = t.dot(e) + 1;
                    return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
                }
                angleTo(t) {
                    return 2 * Math.acos(Math.abs(Pn.clamp(this.dot(t), -1, 1)))
                }
                rotateTowards(t, e) {
                    const n = this.angleTo(t);
                    if (0 === n) return this;
                    const i = Math.min(1, e / n);
                    return this.slerp(t, i), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                inverse() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                }
                premultiply(t) {
                    return this.multiplyQuaternions(t, this)
                }
                multiplyQuaternions(t, e) {
                    const n = t._x,
                        i = t._y,
                        r = t._z,
                        s = t._w,
                        o = e._x,
                        a = e._y,
                        l = e._z,
                        c = e._w;
                    return this._x = n * c + s * o + i * l - r * a, this._y = i * c + s * a + r * o - n * l, this._z = r * c + s * l + n * a - i * o, this._w = s * c - n * o - i * a - r * l, this._onChangeCallback(), this
                }
                slerp(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    const n = this._x,
                        i = this._y,
                        r = this._z,
                        s = this._w;
                    let o = s * t._w + n * t._x + i * t._y + r * t._z;
                    if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
                    const a = 1 - o * o;
                    if (a <= Number.EPSILON) {
                        const t = 1 - e;
                        return this._w = t * s + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    const l = Math.sqrt(a),
                        c = Math.atan2(l, o),
                        h = Math.sin((1 - e) * c) / l,
                        u = Math.sin(e * c) / l;
                    return this._w = s * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                }
                fromArray(t, e) {
                    return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                }
                toArray(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                }
                fromBufferAttribute(t, e) {
                    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
                }
                _onChange(t) {
                    return this._onChangeCallback = t, this
                }
                _onChangeCallback() {}
            }
            class Hn {
                constructor(t = 0, e = 0, n = 0) {
                    Object.defineProperty(this, "isVector3", {
                        value: !0
                    }), this.x = t, this.y = e, this.z = n
                }
                set(t, e, n) {
                    return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this.z = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setZ(t) {
                    return this.z = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this.z += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this
                }
                multiplyVectors(t, e) {
                    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                }
                applyEuler(t) {
                    return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Vn.setFromEuler(t))
                }
                applyAxisAngle(t, e) {
                    return this.applyQuaternion(Vn.setFromAxisAngle(t, e))
                }
                applyMatrix3(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
                }
                applyNormalMatrix(t) {
                    return this.applyMatrix3(t).normalize()
                }
                applyMatrix4(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements,
                        s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                    return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s, this
                }
                applyQuaternion(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.x,
                        s = t.y,
                        o = t.z,
                        a = t.w,
                        l = a * e + s * i - o * n,
                        c = a * n + o * e - r * i,
                        h = a * i + r * n - s * e,
                        u = -r * e - s * n - o * i;
                    return this.x = l * a + u * -r + c * -o - h * -s, this.y = c * a + u * -s + h * -r - l * -o, this.z = h * a + u * -o + l * -s - c * -r, this
                }
                project(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                }
                unproject(t) {
                    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                }
                transformDirection(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
                }
                clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                }
                lerpVectors(t, e, n) {
                    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
                }
                cross(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                }
                crossVectors(t, e) {
                    const n = t.x,
                        i = t.y,
                        r = t.z,
                        s = e.x,
                        o = e.y,
                        a = e.z;
                    return this.x = i * a - r * o, this.y = r * s - n * a, this.z = n * o - i * s, this
                }
                projectOnVector(t) {
                    const e = t.lengthSq();
                    if (0 === e) return this.set(0, 0, 0);
                    const n = t.dot(this) / e;
                    return this.copy(t).multiplyScalar(n)
                }
                projectOnPlane(t) {
                    return Gn.copy(this).projectOnVector(t), this.sub(Gn)
                }
                reflect(t) {
                    return this.sub(Gn.copy(t).multiplyScalar(2 * this.dot(t)))
                }
                angleTo(t) {
                    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                    if (0 === e) return Math.PI / 2;
                    const n = this.dot(t) / e;
                    return Math.acos(Pn.clamp(n, -1, 1))
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        n = this.y - t.y,
                        i = this.z - t.z;
                    return e * e + n * n + i * i
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                }
                setFromSpherical(t) {
                    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                }
                setFromSphericalCoords(t, e, n) {
                    const i = Math.sin(e) * t;
                    return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
                }
                setFromCylindrical(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                }
                setFromCylindricalCoords(t, e, n) {
                    return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
                }
                setFromMatrixPosition(t) {
                    const e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                }
                setFromMatrixScale(t) {
                    const e = this.setFromMatrixColumn(t, 0).length(),
                        n = this.setFromMatrixColumn(t, 1).length(),
                        i = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e, this.y = n, this.z = i, this
                }
                setFromMatrixColumn(t, e) {
                    return this.fromArray(t.elements, 4 * e)
                }
                setFromMatrix3Column(t, e) {
                    return this.fromArray(t.elements, 3 * e)
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                }
                fromArray(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                }
                toArray(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                }
                fromBufferAttribute(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
            }
            const Gn = new Hn,
                Vn = new Bn;
            class jn {
                constructor(t, e) {
                    Object.defineProperty(this, "isBox3", {
                        value: !0
                    }), this.min = void 0 !== t ? t : new Hn(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Hn(-1 / 0, -1 / 0, -1 / 0)
                }
                set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                }
                setFromArray(t) {
                    let e = 1 / 0,
                        n = 1 / 0,
                        i = 1 / 0,
                        r = -1 / 0,
                        s = -1 / 0,
                        o = -1 / 0;
                    for (let a = 0, l = t.length; a < l; a += 3) {
                        const l = t[a],
                            c = t[a + 1],
                            h = t[a + 2];
                        l < e && (e = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > s && (s = c), h > o && (o = h)
                    }
                    return this.min.set(e, n, i), this.max.set(r, s, o), this
                }
                setFromBufferAttribute(t) {
                    let e = 1 / 0,
                        n = 1 / 0,
                        i = 1 / 0,
                        r = -1 / 0,
                        s = -1 / 0,
                        o = -1 / 0;
                    for (let a = 0, l = t.count; a < l; a++) {
                        const l = t.getX(a),
                            c = t.getY(a),
                            h = t.getZ(a);
                        l < e && (e = l), c < n && (n = c), h < i && (i = h), l > r && (r = l), c > s && (s = c), h > o && (o = h)
                    }
                    return this.min.set(e, n, i), this.max.set(r, s, o), this
                }
                setFromPoints(t) {
                    this.makeEmpty();
                    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this
                }
                setFromCenterAndSize(t, e) {
                    const n = Xn.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                }
                setFromObject(t) {
                    return this.makeEmpty(), this.expandByObject(t)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new Hn), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new Hn), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                }
                expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this
                }
                expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this
                }
                expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                }
                expandByObject(t) {
                    t.updateWorldMatrix(!1, !1);
                    const e = t.geometry;
                    void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), Yn.copy(e.boundingBox), Yn.applyMatrix4(t.matrixWorld), this.union(Yn));
                    const n = t.children;
                    for (let i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
                    return this
                }
                containsPoint(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                }
                containsBox(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                }
                getParameter(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new Hn), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                }
                intersectsSphere(t) {
                    return this.clampPoint(t.center, Xn), Xn.distanceToSquared(t.center) <= t.radius * t.radius
                }
                intersectsPlane(t) {
                    let e, n;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
                }
                intersectsTriangle(t) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(ei), ni.subVectors(this.max, ei), Jn.subVectors(t.a, ei), Zn.subVectors(t.b, ei), Kn.subVectors(t.c, ei), $n.subVectors(Zn, Jn), Qn.subVectors(Kn, Zn), ti.subVectors(Jn, Kn);
                    let e = [0, -$n.z, $n.y, 0, -Qn.z, Qn.y, 0, -ti.z, ti.y, $n.z, 0, -$n.x, Qn.z, 0, -Qn.x, ti.z, 0, -ti.x, -$n.y, $n.x, 0, -Qn.y, Qn.x, 0, -ti.y, ti.x, 0];
                    return !!Wn(e, Jn, Zn, Kn, ni) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Wn(e, Jn, Zn, Kn, ni) && (ii.crossVectors($n, Qn), e = [ii.x, ii.y, ii.z], Wn(e, Jn, Zn, Kn, ni)))
                }
                clampPoint(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new Hn), e.copy(t).clamp(this.min, this.max)
                }
                distanceToPoint(t) {
                    return Xn.copy(t).clamp(this.min, this.max).sub(t).length()
                }
                getBoundingSphere(t) {
                    return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(Xn).length(), t
                }
                intersect(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                }
                applyMatrix4(t) {
                    return this.isEmpty() ? this : (qn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), qn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), qn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), qn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), qn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), qn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), qn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), qn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(qn), this)
                }
                translate(t) {
                    return this.min.add(t), this.max.add(t), this
                }
                equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }

            function Wn(t, e, n, i, r) {
                for (let s = 0, o = t.length - 3; s <= o; s += 3) {
                    ri.fromArray(t, s);
                    const o = r.x * Math.abs(ri.x) + r.y * Math.abs(ri.y) + r.z * Math.abs(ri.z),
                        a = e.dot(ri),
                        l = n.dot(ri),
                        c = i.dot(ri);
                    if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1
                }
                return !0
            }
            const qn = [new Hn, new Hn, new Hn, new Hn, new Hn, new Hn, new Hn, new Hn],
                Xn = new Hn,
                Yn = new jn,
                Jn = new Hn,
                Zn = new Hn,
                Kn = new Hn,
                $n = new Hn,
                Qn = new Hn,
                ti = new Hn,
                ei = new Hn,
                ni = new Hn,
                ii = new Hn,
                ri = new Hn,
                si = new jn;
            class oi {
                constructor(t, e) {
                    this.center = void 0 !== t ? t : new Hn, this.radius = void 0 !== e ? e : -1
                }
                set(t, e) {
                    return this.center.copy(t), this.radius = e, this
                }
                setFromPoints(t, e) {
                    const n = this.center;
                    void 0 !== e ? n.copy(e) : si.setFromPoints(t).getCenter(n);
                    let i = 0;
                    for (let r = 0, s = t.length; r < s; r++) i = Math.max(i, n.distanceToSquared(t[r]));
                    return this.radius = Math.sqrt(i), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.center.copy(t.center), this.radius = t.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(t) {
                    return t.distanceTo(this.center) - this.radius
                }
                intersectsSphere(t) {
                    const e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                }
                intersectsBox(t) {
                    return t.intersectsSphere(this)
                }
                intersectsPlane(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(t, e) {
                    const n = this.center.distanceToSquared(t);
                    return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new Hn), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                }
                getBoundingBox(t) {
                    return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new jn), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
                }
                applyMatrix4(t) {
                    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                }
                translate(t) {
                    return this.center.add(t), this
                }
                equals(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
            }
            const ai = new Hn,
                li = new Hn,
                ci = new Hn,
                hi = new Hn,
                ui = new Hn,
                di = new Hn,
                pi = new Hn;
            class mi {
                constructor(t, e) {
                    this.origin = void 0 !== t ? t : new Hn, this.direction = void 0 !== e ? e : new Hn(0, 0, -1)
                }
                set(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                }
                at(t, e) {
                    return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new Hn), e.copy(this.direction).multiplyScalar(t).add(this.origin)
                }
                lookAt(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this
                }
                recast(t) {
                    return this.origin.copy(this.at(t, ai)), this
                }
                closestPointToPoint(t, e) {
                    void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new Hn), e.subVectors(t, this.origin);
                    const n = e.dot(this.direction);
                    return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
                }
                distanceToPoint(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                }
                distanceSqToPoint(t) {
                    const e = ai.subVectors(t, this.origin).dot(this.direction);
                    return e < 0 ? this.origin.distanceToSquared(t) : (ai.copy(this.direction).multiplyScalar(e).add(this.origin), ai.distanceToSquared(t))
                }
                distanceSqToSegment(t, e, n, i) {
                    li.copy(t).add(e).multiplyScalar(.5), ci.copy(e).sub(t).normalize(), hi.copy(this.origin).sub(li);
                    const r = .5 * t.distanceTo(e),
                        s = -this.direction.dot(ci),
                        o = hi.dot(this.direction),
                        a = -hi.dot(ci),
                        l = hi.lengthSq(),
                        c = Math.abs(1 - s * s);
                    let h, u, d, p;
                    if (c > 0)
                        if (h = s * a - o, u = s * o - a, p = r * c, h >= 0)
                            if (u >= -p)
                                if (u <= p) {
                                    const t = 1 / c;
                                    h *= t, u *= t, d = h * (h + s * u + 2 * o) + u * (s * h + u + 2 * a) + l
                                } else u = r, h = Math.max(0, -(s * u + o)), d = -h * h + u * (u + 2 * a) + l;
                    else u = -r, h = Math.max(0, -(s * u + o)), d = -h * h + u * (u + 2 * a) + l;
                    else u <= -p ? (h = Math.max(0, -(-s * r + o)), u = h > 0 ? -r : Math.min(Math.max(-r, -a), r), d = -h * h + u * (u + 2 * a) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -a), r), d = u * (u + 2 * a) + l) : (h = Math.max(0, -(s * r + o)), u = h > 0 ? r : Math.min(Math.max(-r, -a), r), d = -h * h + u * (u + 2 * a) + l);
                    else u = s > 0 ? -r : r, h = Math.max(0, -(s * u + o)), d = -h * h + u * (u + 2 * a) + l;
                    return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(ci).multiplyScalar(u).add(li), d
                }
                intersectSphere(t, e) {
                    ai.subVectors(t.center, this.origin);
                    const n = ai.dot(this.direction),
                        i = ai.dot(ai) - n * n,
                        r = t.radius * t.radius;
                    if (i > r) return null;
                    const s = Math.sqrt(r - i),
                        o = n - s,
                        a = n + s;
                    return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
                }
                intersectsSphere(t) {
                    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                }
                distanceToPlane(t) {
                    const e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    const n = -(this.origin.dot(t.normal) + t.constant) / e;
                    return n >= 0 ? n : null
                }
                intersectPlane(t, e) {
                    const n = this.distanceToPlane(t);
                    return null === n ? null : this.at(n, e)
                }
                intersectsPlane(t) {
                    const e = t.distanceToPoint(this.origin);
                    return 0 === e || t.normal.dot(this.direction) * e < 0
                }
                intersectBox(t, e) {
                    let n, i, r, s, o, a;
                    const l = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        h = 1 / this.direction.z,
                        u = this.origin;
                    return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, s = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, s = (t.min.y - u.y) * c), n > s || r > i ? null : ((r > n || n !== n) && (n = r), (s < i || i !== i) && (i = s), h >= 0 ? (o = (t.min.z - u.z) * h, a = (t.max.z - u.z) * h) : (o = (t.max.z - u.z) * h, a = (t.min.z - u.z) * h), n > a || o > i ? null : ((o > n || n !== n) && (n = o), (a < i || i !== i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                }
                intersectsBox(t) {
                    return null !== this.intersectBox(t, ai)
                }
                intersectTriangle(t, e, n, i, r) {
                    ui.subVectors(e, t), di.subVectors(n, t), pi.crossVectors(ui, di);
                    let s, o = this.direction.dot(pi);
                    if (o > 0) {
                        if (i) return null;
                        s = 1
                    } else {
                        if (!(o < 0)) return null;
                        s = -1, o = -o
                    }
                    hi.subVectors(this.origin, t);
                    const a = s * this.direction.dot(di.crossVectors(hi, di));
                    if (a < 0) return null;
                    const l = s * this.direction.dot(ui.cross(hi));
                    if (l < 0) return null;
                    if (a + l > o) return null;
                    const c = -s * hi.dot(pi);
                    return c < 0 ? null : this.at(c / o, r)
                }
                applyMatrix4(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                }
                equals(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
            }
            class fi {
                constructor() {
                    Object.defineProperty(this, "isMatrix4", {
                        value: !0
                    }), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                }
                set(t, e, n, i, r, s, o, a, l, c, h, u, d, p, m, f) {
                    const g = this.elements;
                    return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = o, g[13] = a, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = m, g[15] = f, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return (new fi).fromArray(this.elements)
                }
                copy(t) {
                    const e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                }
                copyPosition(t) {
                    const e = this.elements,
                        n = t.elements;
                    return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
                }
                extractBasis(t, e, n) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                }
                makeBasis(t, e, n) {
                    return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(t) {
                    const e = this.elements,
                        n = t.elements,
                        i = 1 / gi.setFromMatrixColumn(t, 0).length(),
                        r = 1 / gi.setFromMatrixColumn(t, 1).length(),
                        s = 1 / gi.setFromMatrixColumn(t, 2).length();
                    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
                makeRotationFromEuler(t) {
                    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    const e = this.elements,
                        n = t.x,
                        i = t.y,
                        r = t.z,
                        s = Math.cos(n),
                        o = Math.sin(n),
                        a = Math.cos(i),
                        l = Math.sin(i),
                        c = Math.cos(r),
                        h = Math.sin(r);
                    if ("XYZ" === t.order) {
                        const t = s * c,
                            n = s * h,
                            i = o * c,
                            r = o * h;
                        e[0] = a * c, e[4] = -a * h, e[8] = l, e[1] = n + i * l, e[5] = t - r * l, e[9] = -o * a, e[2] = r - t * l, e[6] = i + n * l, e[10] = s * a
                    } else if ("YXZ" === t.order) {
                        const t = a * c,
                            n = a * h,
                            i = l * c,
                            r = l * h;
                        e[0] = t + r * o, e[4] = i * o - n, e[8] = s * l, e[1] = s * h, e[5] = s * c, e[9] = -o, e[2] = n * o - i, e[6] = r + t * o, e[10] = s * a
                    } else if ("ZXY" === t.order) {
                        const t = a * c,
                            n = a * h,
                            i = l * c,
                            r = l * h;
                        e[0] = t - r * o, e[4] = -s * h, e[8] = i + n * o, e[1] = n + i * o, e[5] = s * c, e[9] = r - t * o, e[2] = -s * l, e[6] = o, e[10] = s * a
                    } else if ("ZYX" === t.order) {
                        const t = s * c,
                            n = s * h,
                            i = o * c,
                            r = o * h;
                        e[0] = a * c, e[4] = i * l - n, e[8] = t * l + r, e[1] = a * h, e[5] = r * l + t, e[9] = n * l - i, e[2] = -l, e[6] = o * a, e[10] = s * a
                    } else if ("YZX" === t.order) {
                        const t = s * a,
                            n = s * l,
                            i = o * a,
                            r = o * l;
                        e[0] = a * c, e[4] = r - t * h, e[8] = i * h + n, e[1] = h, e[5] = s * c, e[9] = -o * c, e[2] = -l * c, e[6] = n * h + i, e[10] = t - r * h
                    } else if ("XZY" === t.order) {
                        const t = s * a,
                            n = s * l,
                            i = o * a,
                            r = o * l;
                        e[0] = a * c, e[4] = -h, e[8] = l * c, e[1] = t * h + r, e[5] = s * c, e[9] = n * h - i, e[2] = i * h - n, e[6] = o * c, e[10] = r * h + t
                    }
                    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
                makeRotationFromQuaternion(t) {
                    return this.compose(yi, t, xi)
                }
                lookAt(t, e, n) {
                    const i = this.elements;
                    return wi.subVectors(t, e), 0 === wi.lengthSq() && (wi.z = 1), wi.normalize(), bi.crossVectors(n, wi), 0 === bi.lengthSq() && (1 === Math.abs(n.z) ? wi.x += 1e-4 : wi.z += 1e-4, wi.normalize(), bi.crossVectors(n, wi)), bi.normalize(), _i.crossVectors(wi, bi), i[0] = bi.x, i[4] = _i.x, i[8] = wi.x, i[1] = bi.y, i[5] = _i.y, i[9] = wi.y, i[2] = bi.z, i[6] = _i.z, i[10] = wi.z, this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this)
                }
                multiplyMatrices(t, e) {
                    const n = t.elements,
                        i = e.elements,
                        r = this.elements,
                        s = n[0],
                        o = n[4],
                        a = n[8],
                        l = n[12],
                        c = n[1],
                        h = n[5],
                        u = n[9],
                        d = n[13],
                        p = n[2],
                        m = n[6],
                        f = n[10],
                        g = n[14],
                        v = n[3],
                        y = n[7],
                        x = n[11],
                        b = n[15],
                        _ = i[0],
                        w = i[4],
                        M = i[8],
                        S = i[12],
                        T = i[1],
                        E = i[5],
                        A = i[9],
                        L = i[13],
                        R = i[2],
                        P = i[6],
                        C = i[10],
                        O = i[14],
                        I = i[3],
                        N = i[7],
                        D = i[11],
                        F = i[15];
                    return r[0] = s * _ + o * T + a * R + l * I, r[4] = s * w + o * E + a * P + l * N, r[8] = s * M + o * A + a * C + l * D, r[12] = s * S + o * L + a * O + l * F, r[1] = c * _ + h * T + u * R + d * I, r[5] = c * w + h * E + u * P + d * N, r[9] = c * M + h * A + u * C + d * D, r[13] = c * S + h * L + u * O + d * F, r[2] = p * _ + m * T + f * R + g * I, r[6] = p * w + m * E + f * P + g * N, r[10] = p * M + m * A + f * C + g * D, r[14] = p * S + m * L + f * O + g * F, r[3] = v * _ + y * T + x * R + b * I, r[7] = v * w + y * E + x * P + b * N, r[11] = v * M + y * A + x * C + b * D, r[15] = v * S + y * L + x * O + b * F, this
                }
                multiplyScalar(t) {
                    const e = this.elements;
                    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        n = t[4],
                        i = t[8],
                        r = t[12],
                        s = t[1],
                        o = t[5],
                        a = t[9],
                        l = t[13],
                        c = t[2],
                        h = t[6],
                        u = t[10],
                        d = t[14];
                    return t[3] * (+r * a * h - i * l * h - r * o * u + n * l * u + i * o * d - n * a * d) + t[7] * (+e * a * d - e * l * u + r * s * u - i * s * d + i * l * c - r * a * c) + t[11] * (+e * l * h - e * o * d - r * s * h + n * s * d + r * o * c - n * l * c) + t[15] * (-i * o * c - e * a * h + e * o * u + i * s * h - n * s * u + n * a * c)
                }
                transpose() {
                    const t = this.elements;
                    let e;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                }
                setPosition(t, e, n) {
                    const i = this.elements;
                    return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
                }
                getInverse(t, e) {
                    void 0 !== e && console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
                    const n = this.elements,
                        i = t.elements,
                        r = i[0],
                        s = i[1],
                        o = i[2],
                        a = i[3],
                        l = i[4],
                        c = i[5],
                        h = i[6],
                        u = i[7],
                        d = i[8],
                        p = i[9],
                        m = i[10],
                        f = i[11],
                        g = i[12],
                        v = i[13],
                        y = i[14],
                        x = i[15],
                        b = p * y * u - v * m * u + v * h * f - c * y * f - p * h * x + c * m * x,
                        _ = g * m * u - d * y * u - g * h * f + l * y * f + d * h * x - l * m * x,
                        w = d * v * u - g * p * u + g * c * f - l * v * f - d * c * x + l * p * x,
                        M = g * p * h - d * v * h - g * c * m + l * v * m + d * c * y - l * p * y,
                        S = r * b + s * _ + o * w + a * M;
                    if (0 === S) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const T = 1 / S;
                    return n[0] = b * T, n[1] = (v * m * a - p * y * a - v * o * f + s * y * f + p * o * x - s * m * x) * T, n[2] = (c * y * a - v * h * a + v * o * u - s * y * u - c * o * x + s * h * x) * T, n[3] = (p * h * a - c * m * a - p * o * u + s * m * u + c * o * f - s * h * f) * T, n[4] = _ * T, n[5] = (d * y * a - g * m * a + g * o * f - r * y * f - d * o * x + r * m * x) * T, n[6] = (g * h * a - l * y * a - g * o * u + r * y * u + l * o * x - r * h * x) * T, n[7] = (l * m * a - d * h * a + d * o * u - r * m * u - l * o * f + r * h * f) * T, n[8] = w * T, n[9] = (g * p * a - d * v * a - g * s * f + r * v * f + d * s * x - r * p * x) * T, n[10] = (l * v * a - g * c * a + g * s * u - r * v * u - l * s * x + r * c * x) * T, n[11] = (d * c * a - l * p * a - d * s * u + r * p * u + l * s * f - r * c * f) * T, n[12] = M * T, n[13] = (d * v * o - g * p * o + g * s * m - r * v * m - d * s * y + r * p * y) * T, n[14] = (g * c * o - l * v * o - g * s * h + r * v * h + l * s * y - r * c * y) * T, n[15] = (l * p * o - d * c * o + d * s * h - r * p * h - l * s * m + r * c * m) * T, this
                }
                scale(t) {
                    const e = this.elements,
                        n = t.x,
                        i = t.y,
                        r = t.z;
                    return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
                }
                getMaxScaleOnAxis() {
                    const t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, n, i))
                }
                makeTranslation(t, e, n) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
                }
                makeRotationX(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
                }
                makeRotationY(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(t, e) {
                    const n = Math.cos(e),
                        i = Math.sin(e),
                        r = 1 - n,
                        s = t.x,
                        o = t.y,
                        a = t.z,
                        l = r * s,
                        c = r * o;
                    return this.set(l * s + n, l * o - i * a, l * a + i * o, 0, l * o + i * a, c * o + n, c * a - i * s, 0, l * a - i * o, c * a + i * s, r * a * a + n, 0, 0, 0, 0, 1), this
                }
                makeScale(t, e, n) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                }
                makeShear(t, e, n) {
                    return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
                }
                compose(t, e, n) {
                    const i = this.elements,
                        r = e._x,
                        s = e._y,
                        o = e._z,
                        a = e._w,
                        l = r + r,
                        c = s + s,
                        h = o + o,
                        u = r * l,
                        d = r * c,
                        p = r * h,
                        m = s * c,
                        f = s * h,
                        g = o * h,
                        v = a * l,
                        y = a * c,
                        x = a * h,
                        b = n.x,
                        _ = n.y,
                        w = n.z;
                    return i[0] = (1 - (m + g)) * b, i[1] = (d + x) * b, i[2] = (p - y) * b, i[3] = 0, i[4] = (d - x) * _, i[5] = (1 - (u + g)) * _, i[6] = (f + v) * _, i[7] = 0, i[8] = (p + y) * w, i[9] = (f - v) * w, i[10] = (1 - (u + m)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
                }
                decompose(t, e, n) {
                    const i = this.elements;
                    let r = gi.set(i[0], i[1], i[2]).length();
                    const s = gi.set(i[4], i[5], i[6]).length(),
                        o = gi.set(i[8], i[9], i[10]).length();
                    this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], vi.copy(this);
                    const a = 1 / r,
                        l = 1 / s,
                        c = 1 / o;
                    return vi.elements[0] *= a, vi.elements[1] *= a, vi.elements[2] *= a, vi.elements[4] *= l, vi.elements[5] *= l, vi.elements[6] *= l, vi.elements[8] *= c, vi.elements[9] *= c, vi.elements[10] *= c, e.setFromRotationMatrix(vi), n.x = r, n.y = s, n.z = o, this
                }
                makePerspective(t, e, n, i, r, s) {
                    void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    const o = this.elements,
                        a = 2 * r / (e - t),
                        l = 2 * r / (n - i),
                        c = (e + t) / (e - t),
                        h = (n + i) / (n - i),
                        u = -(s + r) / (s - r),
                        d = -2 * s * r / (s - r);
                    return o[0] = a, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = h, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                }
                makeOrthographic(t, e, n, i, r, s) {
                    const o = this.elements,
                        a = 1 / (e - t),
                        l = 1 / (n - i),
                        c = 1 / (s - r),
                        h = (e + t) * a,
                        u = (n + i) * l,
                        d = (s + r) * c;
                    return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -h, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                }
                equals(t) {
                    const e = this.elements,
                        n = t.elements;
                    for (let i = 0; i < 16; i++)
                        if (e[i] !== n[i]) return !1;
                    return !0
                }
                fromArray(t, e) {
                    void 0 === e && (e = 0);
                    for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                    return this
                }
                toArray(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    const n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                }
            }
            const gi = new Hn,
                vi = new fi,
                yi = new Hn(0, 0, 0),
                xi = new Hn(1, 1, 1),
                bi = new Hn,
                _i = new Hn,
                wi = new Hn;
            class Mi {
                constructor(t = 0, e = 0, n = 0, i = Mi.DefaultOrder) {
                    Object.defineProperty(this, "isEuler", {
                        value: !0
                    }), this._x = t, this._y = e, this._z = n, this._order = i
                }
                get x() {
                    return this._x
                }
                set x(t) {
                    this._x = t, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(t) {
                    this._y = t, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(t) {
                    this._z = t, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(t) {
                    this._order = t, this._onChangeCallback()
                }
                set(t, e, n, i) {
                    return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(t) {
                    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(t, e, n) {
                    const i = Pn.clamp,
                        r = t.elements,
                        s = r[0],
                        o = r[4],
                        a = r[8],
                        l = r[1],
                        c = r[5],
                        h = r[9],
                        u = r[2],
                        d = r[6],
                        p = r[10];
                    switch (e = e || this._order) {
                        case "XYZ":
                            this._y = Math.asin(i(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, p), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(d, c), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-i(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, s), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(i(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, s));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-i(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, c));
                            break;
                        case "YZX":
                            this._z = Math.asin(i(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-u, s)) : (this._x = 0, this._y = Math.atan2(a, p));
                            break;
                        case "XZY":
                            this._z = Math.asin(-i(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-h, p), this._y = 0);
                            break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                    }
                    return this._order = e, !1 !== n && this._onChangeCallback(), this
                }
                setFromQuaternion(t, e, n) {
                    return Si.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Si, e, n)
                }
                setFromVector3(t, e) {
                    return this.set(t.x, t.y, t.z, e || this._order)
                }
                reorder(t) {
                    return Ti.setFromEuler(this), this.setFromQuaternion(Ti, t)
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                }
                fromArray(t) {
                    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                }
                toArray(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                }
                toVector3(t) {
                    return t ? t.set(this._x, this._y, this._z) : new Hn(this._x, this._y, this._z)
                }
                _onChange(t) {
                    return this._onChangeCallback = t, this
                }
                _onChangeCallback() {}
            }
            Mi.DefaultOrder = "XYZ", Mi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            const Si = new fi,
                Ti = new Bn;
            class Ei {
                constructor() {
                    this.mask = 1
                }
                set(t) {
                    this.mask = 1 << t | 0
                }
                enable(t) {
                    this.mask |= 1 << t | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(t) {
                    this.mask ^= 1 << t | 0
                }
                disable(t) {
                    this.mask &= ~(1 << t | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(t) {
                    return 0 !== (this.mask & t.mask)
                }
            }
            let Ai = 0;
            const Li = new Hn,
                Ri = new Bn,
                Pi = new fi,
                Ci = new Hn,
                Oi = new Hn,
                Ii = new Hn,
                Ni = new Bn,
                Di = new Hn(1, 0, 0),
                Fi = new Hn(0, 1, 0),
                Ui = new Hn(0, 0, 1),
                zi = {
                    type: "added"
                },
                ki = {
                    type: "removed"
                };

            function Bi() {
                Object.defineProperty(this, "id", {
                    value: Ai++
                }), this.uuid = Pn.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Bi.DefaultUp.clone();
                const t = new Hn,
                    e = new Mi,
                    n = new Bn,
                    i = new Hn(1, 1, 1);
                e._onChange((function() {
                    n.setFromEuler(e, !1)
                })), n._onChange((function() {
                    e.setFromQuaternion(n, void 0, !1)
                })), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new fi
                    },
                    normalMatrix: {
                        value: new On
                    }
                }), this.matrix = new fi, this.matrixWorld = new fi, this.matrixAutoUpdate = Bi.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Ei, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }
            Bi.DefaultUp = new Hn(0, 1, 0), Bi.DefaultMatrixAutoUpdate = !0, Bi.prototype = Object.assign(Object.create(An.prototype), {
                constructor: Bi,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix4: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(t) {
                    return this.quaternion.premultiply(t), this
                },
                setRotationFromAxisAngle: function(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                },
                setRotationFromEuler: function(t) {
                    this.quaternion.setFromEuler(t, !0)
                },
                setRotationFromMatrix: function(t) {
                    this.quaternion.setFromRotationMatrix(t)
                },
                setRotationFromQuaternion: function(t) {
                    this.quaternion.copy(t)
                },
                rotateOnAxis: function(t, e) {
                    return Ri.setFromAxisAngle(t, e), this.quaternion.multiply(Ri), this
                },
                rotateOnWorldAxis: function(t, e) {
                    return Ri.setFromAxisAngle(t, e), this.quaternion.premultiply(Ri), this
                },
                rotateX: function(t) {
                    return this.rotateOnAxis(Di, t)
                },
                rotateY: function(t) {
                    return this.rotateOnAxis(Fi, t)
                },
                rotateZ: function(t) {
                    return this.rotateOnAxis(Ui, t)
                },
                translateOnAxis: function(t, e) {
                    return Li.copy(t).applyQuaternion(this.quaternion), this.position.add(Li.multiplyScalar(e)), this
                },
                translateX: function(t) {
                    return this.translateOnAxis(Di, t)
                },
                translateY: function(t) {
                    return this.translateOnAxis(Fi, t)
                },
                translateZ: function(t) {
                    return this.translateOnAxis(Ui, t)
                },
                localToWorld: function(t) {
                    return t.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function(t) {
                    return t.applyMatrix4(Pi.getInverse(this.matrixWorld))
                },
                lookAt: function(t, e, n) {
                    t.isVector3 ? Ci.copy(t) : Ci.set(t, e, n);
                    const i = this.parent;
                    this.updateWorldMatrix(!0, !1), Oi.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Pi.lookAt(Oi, Ci, this.up) : Pi.lookAt(Ci, Oi, this.up), this.quaternion.setFromRotationMatrix(Pi), i && (Pi.extractRotation(i.matrixWorld), Ri.setFromRotationMatrix(Pi), this.quaternion.premultiply(Ri.inverse()))
                },
                add: function(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this
                    }
                    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(zi)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                },
                remove: function(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this
                    }
                    const e = this.children.indexOf(t);
                    return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(ki)), this
                },
                attach: function(t) {
                    return this.updateWorldMatrix(!0, !1), Pi.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Pi.multiply(t.parent.matrixWorld)), t.applyMatrix4(Pi), t.updateWorldMatrix(!1, !1), this.add(t), this
                },
                getObjectById: function(t) {
                    return this.getObjectByProperty("id", t)
                },
                getObjectByName: function(t) {
                    return this.getObjectByProperty("name", t)
                },
                getObjectByProperty: function(t, e) {
                    if (this[t] === e) return this;
                    for (let n = 0, i = this.children.length; n < i; n++) {
                        const i = this.children[n].getObjectByProperty(t, e);
                        if (void 0 !== i) return i
                    }
                },
                getWorldPosition: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new Hn), this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new Bn), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Oi, t, Ii), t
                },
                getWorldScale: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new Hn), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Oi, Ni, t), t
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new Hn), this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                },
                raycast: function() {},
                traverse: function(t) {
                    t(this);
                    const e = this.children;
                    for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
                },
                traverseVisible: function(t) {
                    if (!1 === this.visible) return;
                    t(this);
                    const e = this.children;
                    for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
                },
                traverseAncestors: function(t) {
                    const e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                    const e = this.children;
                    for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
                },
                updateWorldMatrix: function(t, e) {
                    const n = this.parent;
                    if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                        const t = this.children;
                        for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0)
                    }
                },
                toJSON: function(t) {
                    const e = void 0 === t || "string" === typeof t,
                        n = {};
                    e && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    }, n.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    const i = {};

                    function r(e, n) {
                        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                        i.geometry = r(t.geometries, this.geometry);
                        const e = this.geometry.parameters;
                        if (void 0 !== e && void 0 !== e.shapes) {
                            const n = e.shapes;
                            if (Array.isArray(n))
                                for (let e = 0, i = n.length; e < i; e++) {
                                    const i = n[e];
                                    r(t.shapes, i)
                                } else r(t.shapes, n)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            const e = [];
                            for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));
                            i.material = e
                        } else i.material = r(t.materials, this.material);
                    if (this.children.length > 0) {
                        i.children = [];
                        for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object)
                    }
                    if (e) {
                        const e = s(t.geometries),
                            i = s(t.materials),
                            r = s(t.textures),
                            o = s(t.images),
                            a = s(t.shapes);
                        e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a)
                    }
                    return n.object = i, n;

                    function s(t) {
                        const e = [];
                        for (const n in t) {
                            const i = t[n];
                            delete i.metadata, e.push(i)
                        }
                        return e
                    }
                },
                clone: function(t) {
                    return (new this.constructor).copy(this, t)
                },
                copy: function(t, e) {
                    if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                        for (let n = 0; n < t.children.length; n++) {
                            const e = t.children[n];
                            this.add(e.clone())
                        }
                    return this
                }
            });
            const Hi = new Hn,
                Gi = new Hn,
                Vi = new On;
            class ji {
                constructor(t, e) {
                    Object.defineProperty(this, "isPlane", {
                        value: !0
                    }), this.normal = void 0 !== t ? t : new Hn(1, 0, 0), this.constant = void 0 !== e ? e : 0
                }
                set(t, e) {
                    return this.normal.copy(t), this.constant = e, this
                }
                setComponents(t, e, n, i) {
                    return this.normal.set(t, e, n), this.constant = i, this
                }
                setFromNormalAndCoplanarPoint(t, e) {
                    return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                }
                setFromCoplanarPoints(t, e, n) {
                    const i = Hi.subVectors(n, e).cross(Gi.subVectors(t, e)).normalize();
                    return this.setFromNormalAndCoplanarPoint(i, t), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.normal.copy(t.normal), this.constant = t.constant, this
                }
                normalize() {
                    const t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), this.constant *= t, this
                }
                negate() {
                    return this.constant *= -1, this.normal.negate(), this
                }
                distanceToPoint(t) {
                    return this.normal.dot(t) + this.constant
                }
                distanceToSphere(t) {
                    return this.distanceToPoint(t.center) - t.radius
                }
                projectPoint(t, e) {
                    return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new Hn), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                }
                intersectLine(t, e) {
                    void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new Hn);
                    const n = t.delta(Hi),
                        i = this.normal.dot(n);
                    if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
                    const r = -(t.start.dot(this.normal) + this.constant) / i;
                    return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start)
                }
                intersectsLine(t) {
                    const e = this.distanceToPoint(t.start),
                        n = this.distanceToPoint(t.end);
                    return e < 0 && n > 0 || n < 0 && e > 0
                }
                intersectsBox(t) {
                    return t.intersectsPlane(this)
                }
                intersectsSphere(t) {
                    return t.intersectsPlane(this)
                }
                coplanarPoint(t) {
                    return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new Hn), t.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(t, e) {
                    const n = e || Vi.getNormalMatrix(t),
                        i = this.coplanarPoint(Hi).applyMatrix4(t),
                        r = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -i.dot(r), this
                }
                translate(t) {
                    return this.constant -= t.dot(this.normal), this
                }
                equals(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant
                }
            }
            const Wi = new Hn,
                qi = new Hn,
                Xi = new Hn,
                Yi = new Hn,
                Ji = new Hn,
                Zi = new Hn,
                Ki = new Hn,
                $i = new Hn,
                Qi = new Hn,
                tr = new Hn;
            class er {
                constructor(t, e, n) {
                    this.a = void 0 !== t ? t : new Hn, this.b = void 0 !== e ? e : new Hn, this.c = void 0 !== n ? n : new Hn
                }
                static getNormal(t, e, n, i) {
                    void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new Hn), i.subVectors(n, e), Wi.subVectors(t, e), i.cross(Wi);
                    const r = i.lengthSq();
                    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
                }
                static getBarycoord(t, e, n, i, r) {
                    Wi.subVectors(i, e), qi.subVectors(n, e), Xi.subVectors(t, e);
                    const s = Wi.dot(Wi),
                        o = Wi.dot(qi),
                        a = Wi.dot(Xi),
                        l = qi.dot(qi),
                        c = qi.dot(Xi),
                        h = s * l - o * o;
                    if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new Hn), 0 === h) return r.set(-2, -1, -1);
                    const u = 1 / h,
                        d = (l * a - o * c) * u,
                        p = (s * c - o * a) * u;
                    return r.set(1 - d - p, p, d)
                }
                static containsPoint(t, e, n, i) {
                    return this.getBarycoord(t, e, n, i, Yi), Yi.x >= 0 && Yi.y >= 0 && Yi.x + Yi.y <= 1
                }
                static getUV(t, e, n, i, r, s, o, a) {
                    return this.getBarycoord(t, e, n, i, Yi), a.set(0, 0), a.addScaledVector(r, Yi.x), a.addScaledVector(s, Yi.y), a.addScaledVector(o, Yi.z), a
                }
                static isFrontFacing(t, e, n, i) {
                    return Wi.subVectors(n, e), qi.subVectors(t, e), Wi.cross(qi).dot(i) < 0
                }
                set(t, e, n) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                }
                setFromPointsAndIndices(t, e, n, i) {
                    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                }
                getArea() {
                    return Wi.subVectors(this.c, this.b), qi.subVectors(this.a, this.b), .5 * Wi.cross(qi).length()
                }
                getMidpoint(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new Hn), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(t) {
                    return er.getNormal(this.a, this.b, this.c, t)
                }
                getPlane(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new ji), t.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(t, e) {
                    return er.getBarycoord(t, this.a, this.b, this.c, e)
                }
                getUV(t, e, n, i, r) {
                    return er.getUV(t, this.a, this.b, this.c, e, n, i, r)
                }
                containsPoint(t) {
                    return er.containsPoint(t, this.a, this.b, this.c)
                }
                isFrontFacing(t) {
                    return er.isFrontFacing(this.a, this.b, this.c, t)
                }
                intersectsBox(t) {
                    return t.intersectsTriangle(this)
                }
                closestPointToPoint(t, e) {
                    void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new Hn);
                    const n = this.a,
                        i = this.b,
                        r = this.c;
                    let s, o;
                    Ji.subVectors(i, n), Zi.subVectors(r, n), $i.subVectors(t, n);
                    const a = Ji.dot($i),
                        l = Zi.dot($i);
                    if (a <= 0 && l <= 0) return e.copy(n);
                    Qi.subVectors(t, i);
                    const c = Ji.dot(Qi),
                        h = Zi.dot(Qi);
                    if (c >= 0 && h <= c) return e.copy(i);
                    const u = a * h - c * l;
                    if (u <= 0 && a >= 0 && c <= 0) return s = a / (a - c), e.copy(n).addScaledVector(Ji, s);
                    tr.subVectors(t, r);
                    const d = Ji.dot(tr),
                        p = Zi.dot(tr);
                    if (p >= 0 && d <= p) return e.copy(r);
                    const m = d * l - a * p;
                    if (m <= 0 && l >= 0 && p <= 0) return o = l / (l - p), e.copy(n).addScaledVector(Zi, o);
                    const f = c * p - d * h;
                    if (f <= 0 && h - c >= 0 && d - p >= 0) return Ki.subVectors(r, i), o = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(Ki, o);
                    const g = 1 / (f + m + u);
                    return s = m * g, o = u * g, e.copy(n).addScaledVector(Ji, s).addScaledVector(Zi, o)
                }
                equals(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            }
            const nr = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                ir = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                rr = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function sr(t, e, n) {
                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
            }

            function or(t) {
                return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
            }

            function ar(t) {
                return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
            }
            class lr {
                constructor(t, e, n) {
                    return Object.defineProperty(this, "isColor", {
                        value: !0
                    }), void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
                }
                set(t) {
                    return t && t.isColor ? this.copy(t) : "number" === typeof t ? this.setHex(t) : "string" === typeof t && this.setStyle(t), this
                }
                setScalar(t) {
                    return this.r = t, this.g = t, this.b = t, this
                }
                setHex(t) {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                }
                setRGB(t, e, n) {
                    return this.r = t, this.g = e, this.b = n, this
                }
                setHSL(t, e, n) {
                    if (t = Pn.euclideanModulo(t, 1), e = Pn.clamp(e, 0, 1), n = Pn.clamp(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                    else {
                        const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                            r = 2 * n - i;
                        this.r = sr(r, i, t + 1 / 3), this.g = sr(r, i, t), this.b = sr(r, i, t - 1 / 3)
                    }
                    return this
                }
                setStyle(t) {
                    function e(e) {
                        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                    }
                    let n;
                    if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                        let t;
                        const i = n[1],
                            r = n[2];
                        switch (i) {
                            case "rgb":
                            case "rgba":
                                if (t = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[5]), this;
                                if (t = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (t = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) {
                                    const n = parseFloat(t[1]) / 360,
                                        i = parseInt(t[2], 10) / 100,
                                        r = parseInt(t[3], 10) / 100;
                                    return e(t[5]), this.setHSL(n, i, r)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                        const t = n[1],
                            e = t.length;
                        if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                        if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                    }
                    return t && t.length > 0 ? this.setColorName(t) : this
                }
                setColorName(t) {
                    const e = nr[t];
                    return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                }
                copyGammaToLinear(t, e) {
                    return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
                }
                copyLinearToGamma(t, e) {
                    void 0 === e && (e = 2);
                    const n = e > 0 ? 1 / e : 1;
                    return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
                }
                convertGammaToLinear(t) {
                    return this.copyGammaToLinear(this, t), this
                }
                convertLinearToGamma(t) {
                    return this.copyLinearToGamma(this, t), this
                }
                copySRGBToLinear(t) {
                    return this.r = or(t.r), this.g = or(t.g), this.b = or(t.b), this
                }
                copyLinearToSRGB(t) {
                    return this.r = ar(t.r), this.g = ar(t.g), this.b = ar(t.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                }
                getHexString() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                }
                getHSL(t) {
                    void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    const e = this.r,
                        n = this.g,
                        i = this.b,
                        r = Math.max(e, n, i),
                        s = Math.min(e, n, i);
                    let o, a;
                    const l = (s + r) / 2;
                    if (s === r) o = 0, a = 0;
                    else {
                        const t = r - s;
                        switch (a = l <= .5 ? t / (r + s) : t / (2 - r - s), r) {
                            case e:
                                o = (n - i) / t + (n < i ? 6 : 0);
                                break;
                            case n:
                                o = (i - e) / t + 2;
                                break;
                            case i:
                                o = (e - n) / t + 4
                        }
                        o /= 6
                    }
                    return t.h = o, t.s = a, t.l = l, t
                }
                getStyle() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                }
                offsetHSL(t, e, n) {
                    return this.getHSL(ir), ir.h += t, ir.s += e, ir.l += n, this.setHSL(ir.h, ir.s, ir.l), this
                }
                add(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                }
                addColors(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                }
                addScalar(t) {
                    return this.r += t, this.g += t, this.b += t, this
                }
                sub(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                }
                multiply(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                }
                multiplyScalar(t) {
                    return this.r *= t, this.g *= t, this.b *= t, this
                }
                lerp(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                }
                lerpHSL(t, e) {
                    this.getHSL(ir), t.getHSL(rr);
                    const n = Pn.lerp(ir.h, rr.h, e),
                        i = Pn.lerp(ir.s, rr.s, e),
                        r = Pn.lerp(ir.l, rr.l, e);
                    return this.setHSL(n, i, r), this
                }
                equals(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                }
                fromArray(t, e) {
                    return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                }
                toArray(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                }
                fromBufferAttribute(t, e) {
                    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                }
                toJSON() {
                    return this.getHex()
                }
            }
            lr.NAMES = nr, lr.prototype.r = 1, lr.prototype.g = 1, lr.prototype.b = 1;
            class cr {
                constructor(t, e, n, i, r, s) {
                    this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new Hn, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new lr, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== s ? s : 0
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                    for (let e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                    for (let e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                    return this
                }
            }
            let hr = 0;

            function ur() {
                Object.defineProperty(this, "id", {
                    value: hr++
                }), this.uuid = Pn.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = V, this.side = k, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = it, this.blendDst = rt, this.blendEquation = Y, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = pt, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Sn, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Mn, this.stencilZFail = Mn, this.stencilZPass = Mn, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
            }

            function dr(t) {
                ur.call(this), this.type = "MeshBasicMaterial", this.color = new lr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = yt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t)
            }
            ur.prototype = Object.assign(Object.create(An.prototype), {
                constructor: ur,
                isMaterial: !0,
                onBeforeCompile: function() {},
                customProgramCacheKey: function() {
                    return this.onBeforeCompile.toString()
                },
                setValues: function(t) {
                    if (void 0 !== t)
                        for (const e in t) {
                            const n = t[e];
                            if (void 0 === n) {
                                console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                                continue
                            }
                            if ("shading" === e) {
                                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                                continue
                            }
                            const i = this[e];
                            void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                        }
                },
                toJSON: function(t) {
                    const e = void 0 === t || "string" === typeof t;
                    e && (t = {
                        textures: {},
                        images: {}
                    });
                    const n = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function i(t) {
                        const e = [];
                        for (const n in t) {
                            const i = t[n];
                            delete i.metadata, e.push(i)
                        }
                        return e
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== V && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== k && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                        const e = i(t.textures),
                            r = i(t.images);
                        e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                    }
                    return n
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                    const e = t.clippingPlanes;
                    let n = null;
                    if (null !== e) {
                        const t = e.length;
                        n = new Array(t);
                        for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
                    }
                    return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(ur.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), dr.prototype = Object.create(ur.prototype), dr.prototype.constructor = dr, dr.prototype.isMeshBasicMaterial = !0, dr.prototype.copy = function(t) {
                return ur.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
            };
            const pr = new Hn,
                mr = new Cn;

            function fr(t, e, n) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = Tn, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function gr(t, e, n) {
                fr.call(this, new Int8Array(t), e, n)
            }

            function vr(t, e, n) {
                fr.call(this, new Uint8Array(t), e, n)
            }

            function yr(t, e, n) {
                fr.call(this, new Uint8ClampedArray(t), e, n)
            }

            function xr(t, e, n) {
                fr.call(this, new Int16Array(t), e, n)
            }

            function br(t, e, n) {
                fr.call(this, new Uint16Array(t), e, n)
            }

            function _r(t, e, n) {
                fr.call(this, new Int32Array(t), e, n)
            }

            function wr(t, e, n) {
                fr.call(this, new Uint32Array(t), e, n)
            }

            function Mr(t, e, n) {
                fr.call(this, new Float32Array(t), e, n)
            }

            function Sr(t, e, n) {
                fr.call(this, new Float64Array(t), e, n)
            }
            Object.defineProperty(fr.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(fr.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function() {},
                setUsage: function(t) {
                    return this.usage = t, this
                },
                copy: function(t) {
                    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
                },
                copyAt: function(t, e, n) {
                    t *= this.itemSize, n *= e.itemSize;
                    for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                    return this
                },
                copyArray: function(t) {
                    return this.array.set(t), this
                },
                copyColorsArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new lr), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
                    }
                    return this
                },
                copyVector2sArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new Cn), e[n++] = r.x, e[n++] = r.y
                    }
                    return this
                },
                copyVector3sArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new Hn), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
                    }
                    return this
                },
                copyVector4sArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new Un), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
                    }
                    return this
                },
                applyMatrix3: function(t) {
                    if (2 === this.itemSize)
                        for (let e = 0, n = this.count; e < n; e++) mr.fromBufferAttribute(this, e), mr.applyMatrix3(t), this.setXY(e, mr.x, mr.y);
                    else if (3 === this.itemSize)
                        for (let e = 0, n = this.count; e < n; e++) pr.fromBufferAttribute(this, e), pr.applyMatrix3(t), this.setXYZ(e, pr.x, pr.y, pr.z);
                    return this
                },
                applyMatrix4: function(t) {
                    for (let e = 0, n = this.count; e < n; e++) pr.x = this.getX(e), pr.y = this.getY(e), pr.z = this.getZ(e), pr.applyMatrix4(t), this.setXYZ(e, pr.x, pr.y, pr.z);
                    return this
                },
                applyNormalMatrix: function(t) {
                    for (let e = 0, n = this.count; e < n; e++) pr.x = this.getX(e), pr.y = this.getY(e), pr.z = this.getZ(e), pr.applyNormalMatrix(t), this.setXYZ(e, pr.x, pr.y, pr.z);
                    return this
                },
                transformDirection: function(t) {
                    for (let e = 0, n = this.count; e < n; e++) pr.x = this.getX(e), pr.y = this.getY(e), pr.z = this.getZ(e), pr.transformDirection(t), this.setXYZ(e, pr.x, pr.y, pr.z);
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                getX: function(t) {
                    return this.array[t * this.itemSize]
                },
                setX: function(t, e) {
                    return this.array[t * this.itemSize] = e, this
                },
                getY: function(t) {
                    return this.array[t * this.itemSize + 1]
                },
                setY: function(t, e) {
                    return this.array[t * this.itemSize + 1] = e, this
                },
                getZ: function(t) {
                    return this.array[t * this.itemSize + 2]
                },
                setZ: function(t, e) {
                    return this.array[t * this.itemSize + 2] = e, this
                },
                getW: function(t) {
                    return this.array[t * this.itemSize + 3]
                },
                setW: function(t, e) {
                    return this.array[t * this.itemSize + 3] = e, this
                },
                setXY: function(t, e, n) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, i) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
                },
                setXYZW: function(t, e, n, i, r) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                },
                toJSON: function() {
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    }
                }
            }), gr.prototype = Object.create(fr.prototype), gr.prototype.constructor = gr, vr.prototype = Object.create(fr.prototype), vr.prototype.constructor = vr, yr.prototype = Object.create(fr.prototype), yr.prototype.constructor = yr, xr.prototype = Object.create(fr.prototype), xr.prototype.constructor = xr, br.prototype = Object.create(fr.prototype), br.prototype.constructor = br, _r.prototype = Object.create(fr.prototype), _r.prototype.constructor = _r, wr.prototype = Object.create(fr.prototype), wr.prototype.constructor = wr, Mr.prototype = Object.create(fr.prototype), Mr.prototype.constructor = Mr, Sr.prototype = Object.create(fr.prototype), Sr.prototype.constructor = Sr;
            class Tr {
                constructor() {
                    this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
                }
                computeGroups(t) {
                    const e = [];
                    let n, i, r = void 0;
                    const s = t.faces;
                    for (i = 0; i < s.length; i++) {
                        const t = s[i];
                        t.materialIndex !== r && (r = t.materialIndex, void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), n = {
                            start: 3 * i,
                            materialIndex: r
                        })
                    }
                    void 0 !== n && (n.count = 3 * i - n.start, e.push(n)), this.groups = e
                }
                fromGeometry(t) {
                    const e = t.faces,
                        n = t.vertices,
                        i = t.faceVertexUvs,
                        r = i[0] && i[0].length > 0,
                        s = i[1] && i[1].length > 0,
                        o = t.morphTargets,
                        a = o.length;
                    let l;
                    if (a > 0) {
                        l = [];
                        for (let t = 0; t < a; t++) l[t] = {
                            name: o[t].name,
                            data: []
                        };
                        this.morphTargets.position = l
                    }
                    const c = t.morphNormals,
                        h = c.length;
                    let u;
                    if (h > 0) {
                        u = [];
                        for (let t = 0; t < h; t++) u[t] = {
                            name: c[t].name,
                            data: []
                        };
                        this.morphTargets.normal = u
                    }
                    const d = t.skinIndices,
                        p = t.skinWeights,
                        m = d.length === n.length,
                        f = p.length === n.length;
                    n.length > 0 && 0 === e.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                    for (let g = 0; g < e.length; g++) {
                        const t = e[g];
                        this.vertices.push(n[t.a], n[t.b], n[t.c]);
                        const v = t.vertexNormals;
                        if (3 === v.length) this.normals.push(v[0], v[1], v[2]);
                        else {
                            const e = t.normal;
                            this.normals.push(e, e, e)
                        }
                        const y = t.vertexColors;
                        if (3 === y.length) this.colors.push(y[0], y[1], y[2]);
                        else {
                            const e = t.color;
                            this.colors.push(e, e, e)
                        }
                        if (!0 === r) {
                            const t = i[0][g];
                            void 0 !== t ? this.uvs.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", g), this.uvs.push(new Cn, new Cn, new Cn))
                        }
                        if (!0 === s) {
                            const t = i[1][g];
                            void 0 !== t ? this.uvs2.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", g), this.uvs2.push(new Cn, new Cn, new Cn))
                        }
                        for (let e = 0; e < a; e++) {
                            const n = o[e].vertices;
                            l[e].data.push(n[t.a], n[t.b], n[t.c])
                        }
                        for (let e = 0; e < h; e++) {
                            const t = c[e].vertexNormals[g];
                            u[e].data.push(t.a, t.b, t.c)
                        }
                        m && this.skinIndices.push(d[t.a], d[t.b], d[t.c]), f && this.skinWeights.push(p[t.a], p[t.b], p[t.c])
                    }
                    return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                }
            }

            function Er(t) {
                if (0 === t.length) return -1 / 0;
                let e = t[0];
                for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
                return e
            }
            let Ar = 1;
            const Lr = new fi,
                Rr = new Bi,
                Pr = new Hn,
                Cr = new jn,
                Or = new jn,
                Ir = new Hn;

            function Nr() {
                Object.defineProperty(this, "id", {
                    value: Ar += 2
                }), this.uuid = Pn.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            Nr.prototype = Object.assign(Object.create(An.prototype), {
                constructor: Nr,
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(t) {
                    return Array.isArray(t) ? this.index = new(Er(t) > 65535 ? wr : br)(t, 1) : this.index = t, this
                },
                getAttribute: function(t) {
                    return this.attributes[t]
                },
                setAttribute: function(t, e) {
                    return this.attributes[t] = e, this
                },
                deleteAttribute: function(t) {
                    return delete this.attributes[t], this
                },
                addGroup: function(t, e, n) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: void 0 !== n ? n : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                },
                applyMatrix4: function(t) {
                    const e = this.attributes.position;
                    void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                    const n = this.attributes.normal;
                    if (void 0 !== n) {
                        const e = (new On).getNormalMatrix(t);
                        n.applyNormalMatrix(e), n.needsUpdate = !0
                    }
                    const i = this.attributes.tangent;
                    return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function(t) {
                    return Lr.makeRotationX(t), this.applyMatrix4(Lr), this
                },
                rotateY: function(t) {
                    return Lr.makeRotationY(t), this.applyMatrix4(Lr), this
                },
                rotateZ: function(t) {
                    return Lr.makeRotationZ(t), this.applyMatrix4(Lr), this
                },
                translate: function(t, e, n) {
                    return Lr.makeTranslation(t, e, n), this.applyMatrix4(Lr), this
                },
                scale: function(t, e, n) {
                    return Lr.makeScale(t, e, n), this.applyMatrix4(Lr), this
                },
                lookAt: function(t) {
                    return Rr.lookAt(t), Rr.updateMatrix(), this.applyMatrix4(Rr.matrix), this
                },
                center: function() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(Pr).negate(), this.translate(Pr.x, Pr.y, Pr.z), this
                },
                setFromObject: function(t) {
                    const e = t.geometry;
                    if (t.isPoints || t.isLine) {
                        const t = new Mr(3 * e.vertices.length, 3),
                            n = new Mr(3 * e.colors.length, 3);
                        if (this.setAttribute("position", t.copyVector3sArray(e.vertices)), this.setAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                            const t = new Mr(e.lineDistances.length, 1);
                            this.setAttribute("lineDistance", t.copyArray(e.lineDistances))
                        }
                        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                    } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                    return this
                },
                setFromPoints: function(t) {
                    const e = [];
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n];
                        e.push(i.x, i.y, i.z || 0)
                    }
                    return this.setAttribute("position", new Mr(e, 3)), this
                },
                updateFromObject: function(t) {
                    let e = t.geometry;
                    if (t.isMesh) {
                        let t = e.__directGeometry;
                        if (!0 === e.elementsNeedUpdate && (t = void 0, e.elementsNeedUpdate = !1), void 0 === t) return this.fromGeometry(e);
                        t.verticesNeedUpdate = e.verticesNeedUpdate, t.normalsNeedUpdate = e.normalsNeedUpdate, t.colorsNeedUpdate = e.colorsNeedUpdate, t.uvsNeedUpdate = e.uvsNeedUpdate, t.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = t
                    }
                    if (!0 === e.verticesNeedUpdate) {
                        const t = this.attributes.position;
                        void 0 !== t && (t.copyVector3sArray(e.vertices), t.needsUpdate = !0), e.verticesNeedUpdate = !1
                    }
                    if (!0 === e.normalsNeedUpdate) {
                        const t = this.attributes.normal;
                        void 0 !== t && (t.copyVector3sArray(e.normals), t.needsUpdate = !0), e.normalsNeedUpdate = !1
                    }
                    if (!0 === e.colorsNeedUpdate) {
                        const t = this.attributes.color;
                        void 0 !== t && (t.copyColorsArray(e.colors), t.needsUpdate = !0), e.colorsNeedUpdate = !1
                    }
                    if (e.uvsNeedUpdate) {
                        const t = this.attributes.uv;
                        void 0 !== t && (t.copyVector2sArray(e.uvs), t.needsUpdate = !0), e.uvsNeedUpdate = !1
                    }
                    if (e.lineDistancesNeedUpdate) {
                        const t = this.attributes.lineDistance;
                        void 0 !== t && (t.copyArray(e.lineDistances), t.needsUpdate = !0), e.lineDistancesNeedUpdate = !1
                    }
                    return e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(t) {
                    return t.__directGeometry = (new Tr).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
                },
                fromDirectGeometry: function(t) {
                    const e = new Float32Array(3 * t.vertices.length);
                    if (this.setAttribute("position", new fr(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                        const e = new Float32Array(3 * t.normals.length);
                        this.setAttribute("normal", new fr(e, 3).copyVector3sArray(t.normals))
                    }
                    if (t.colors.length > 0) {
                        const e = new Float32Array(3 * t.colors.length);
                        this.setAttribute("color", new fr(e, 3).copyColorsArray(t.colors))
                    }
                    if (t.uvs.length > 0) {
                        const e = new Float32Array(2 * t.uvs.length);
                        this.setAttribute("uv", new fr(e, 2).copyVector2sArray(t.uvs))
                    }
                    if (t.uvs2.length > 0) {
                        const e = new Float32Array(2 * t.uvs2.length);
                        this.setAttribute("uv2", new fr(e, 2).copyVector2sArray(t.uvs2))
                    }
                    this.groups = t.groups;
                    for (const n in t.morphTargets) {
                        const e = [],
                            i = t.morphTargets[n];
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = i[t],
                                r = new Mr(3 * n.data.length, 3);
                            r.name = n.name, e.push(r.copyVector3sArray(n.data))
                        }
                        this.morphAttributes[n] = e
                    }
                    if (t.skinIndices.length > 0) {
                        const e = new Mr(4 * t.skinIndices.length, 4);
                        this.setAttribute("skinIndex", e.copyVector4sArray(t.skinIndices))
                    }
                    if (t.skinWeights.length > 0) {
                        const e = new Mr(4 * t.skinWeights.length, 4);
                        this.setAttribute("skinWeight", e.copyVector4sArray(t.skinWeights))
                    }
                    return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new jn);
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Hn(-1 / 0, -1 / 0, -1 / 0), new Hn(1 / 0, 1 / 0, 1 / 0));
                    if (void 0 !== t) {
                        if (this.boundingBox.setFromBufferAttribute(t), e)
                            for (let n = 0, i = e.length; n < i; n++) {
                                const t = e[n];
                                Cr.setFromBufferAttribute(t), this.morphTargetsRelative ? (Ir.addVectors(this.boundingBox.min, Cr.min), this.boundingBox.expandByPoint(Ir), Ir.addVectors(this.boundingBox.max, Cr.max), this.boundingBox.expandByPoint(Ir)) : (this.boundingBox.expandByPoint(Cr.min), this.boundingBox.expandByPoint(Cr.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new oi);
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Hn, 1 / 0);
                    if (t) {
                        const n = this.boundingSphere.center;
                        if (Cr.setFromBufferAttribute(t), e)
                            for (let t = 0, r = e.length; t < r; t++) {
                                const n = e[t];
                                Or.setFromBufferAttribute(n), this.morphTargetsRelative ? (Ir.addVectors(Cr.min, Or.min), Cr.expandByPoint(Ir), Ir.addVectors(Cr.max, Or.max), Cr.expandByPoint(Ir)) : (Cr.expandByPoint(Or.min), Cr.expandByPoint(Or.max))
                            }
                        Cr.getCenter(n);
                        let i = 0;
                        for (let e = 0, r = t.count; e < r; e++) Ir.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(Ir));
                        if (e)
                            for (let r = 0, s = e.length; r < s; r++) {
                                const s = e[r],
                                    o = this.morphTargetsRelative;
                                for (let e = 0, r = s.count; e < r; e++) Ir.fromBufferAttribute(s, e), o && (Pr.fromBufferAttribute(t, e), Ir.add(Pr)), i = Math.max(i, n.distanceToSquared(Ir))
                            }
                        this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                },
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    const t = this.index,
                        e = this.getAttribute("position");
                    if (void 0 !== e) {
                        let n = this.getAttribute("normal");
                        if (void 0 === n) n = new fr(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                        else
                            for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                        const i = new Hn,
                            r = new Hn,
                            s = new Hn,
                            o = new Hn,
                            a = new Hn,
                            l = new Hn,
                            c = new Hn,
                            h = new Hn;
                        if (t)
                            for (let u = 0, d = t.count; u < d; u += 3) {
                                const d = t.getX(u + 0),
                                    p = t.getX(u + 1),
                                    m = t.getX(u + 2);
                                i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, m), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), o.fromBufferAttribute(n, d), a.fromBufferAttribute(n, p), l.fromBufferAttribute(n, m), o.add(c), a.add(c), l.add(c), n.setXYZ(d, o.x, o.y, o.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(m, l.x, l.y, l.z)
                            } else
                                for (let t = 0, u = e.count; t < u; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z);
                        this.normalizeNormals(), n.needsUpdate = !0
                    }
                },
                merge: function(t, e) {
                    if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                    void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    const n = this.attributes;
                    for (const i in n) {
                        if (void 0 === t.attributes[i]) continue;
                        const r = n[i].array,
                            s = t.attributes[i],
                            o = s.array,
                            a = s.itemSize * e,
                            l = Math.min(o.length, r.length - a);
                        for (let t = 0, e = a; t < l; t++, e++) r[e] = o[t]
                    }
                    return this
                },
                normalizeNormals: function() {
                    const t = this.attributes.normal;
                    for (let e = 0, n = t.count; e < n; e++) Ir.fromBufferAttribute(t, e), Ir.normalize(), t.setXYZ(e, Ir.x, Ir.y, Ir.z)
                },
                toNonIndexed: function() {
                    function t(t, e) {
                        const n = t.array,
                            i = t.itemSize,
                            r = t.normalized,
                            s = new n.constructor(e.length * i);
                        let o = 0,
                            a = 0;
                        for (let l = 0, c = e.length; l < c; l++) {
                            o = e[l] * i;
                            for (let t = 0; t < i; t++) s[a++] = n[o++]
                        }
                        return new fr(s, i, r)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    const e = new Nr,
                        n = this.index.array,
                        i = this.attributes;
                    for (const o in i) {
                        const r = t(i[o], n);
                        e.setAttribute(o, r)
                    }
                    const r = this.morphAttributes;
                    for (const o in r) {
                        const i = [],
                            s = r[o];
                        for (let e = 0, r = s.length; e < r; e++) {
                            const r = t(s[e], n);
                            i.push(r)
                        }
                        e.morphAttributes[o] = i
                    }
                    e.morphTargetsRelative = this.morphTargetsRelative;
                    const s = this.groups;
                    for (let o = 0, a = s.length; o < a; o++) {
                        const t = s[o];
                        e.addGroup(t.start, t.count, t.materialIndex)
                    }
                    return e
                },
                toJSON: function() {
                    const t = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                        const e = this.parameters;
                        for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    const e = this.index;
                    null !== e && (t.data.index = {
                        type: e.array.constructor.name,
                        array: Array.prototype.slice.call(e.array)
                    });
                    const n = this.attributes;
                    for (const a in n) {
                        const e = n[a],
                            i = e.toJSON(t.data);
                        "" !== e.name && (i.name = e.name), t.data.attributes[a] = i
                    }
                    const i = {};
                    let r = !1;
                    for (const a in this.morphAttributes) {
                        const e = this.morphAttributes[a],
                            n = [];
                        for (let i = 0, r = e.length; i < r; i++) {
                            const r = e[i],
                                s = r.toJSON(t.data);
                            "" !== r.name && (s.name = r.name), n.push(s)
                        }
                        n.length > 0 && (i[a] = n, r = !0)
                    }
                    r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
                    const s = this.groups;
                    s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                    const o = this.boundingSphere;
                    return null !== o && (t.data.boundingSphere = {
                        center: o.center.toArray(),
                        radius: o.radius
                    }), t
                },
                clone: function() {
                    return (new Nr).copy(this)
                },
                copy: function(t) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    const e = {};
                    this.name = t.name;
                    const n = t.index;
                    null !== n && this.setIndex(n.clone(e));
                    const i = t.attributes;
                    for (const l in i) {
                        const t = i[l];
                        this.setAttribute(l, t.clone(e))
                    }
                    const r = t.morphAttributes;
                    for (const l in r) {
                        const t = [],
                            n = r[l];
                        for (let i = 0, r = n.length; i < r; i++) t.push(n[i].clone(e));
                        this.morphAttributes[l] = t
                    }
                    this.morphTargetsRelative = t.morphTargetsRelative;
                    const s = t.groups;
                    for (let l = 0, c = s.length; l < c; l++) {
                        const t = s[l];
                        this.addGroup(t.start, t.count, t.materialIndex)
                    }
                    const o = t.boundingBox;
                    null !== o && (this.boundingBox = o.clone());
                    const a = t.boundingSphere;
                    return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            const Dr = new fi,
                Fr = new mi,
                Ur = new oi,
                zr = new Hn,
                kr = new Hn,
                Br = new Hn,
                Hr = new Hn,
                Gr = new Hn,
                Vr = new Hn,
                jr = new Hn,
                Wr = new Hn,
                qr = new Hn,
                Xr = new Cn,
                Yr = new Cn,
                Jr = new Cn,
                Zr = new Hn,
                Kr = new Hn;

            function $r(t, e) {
                Bi.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Nr, this.material = void 0 !== e ? e : new dr, this.updateMorphTargets()
            }

            function Qr(t, e, n, i, r, s, o, a) {
                let l;
                if (l = e.side === B ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, e.side !== H, a), null === l) return null;
                Kr.copy(a), Kr.applyMatrix4(t.matrixWorld);
                const c = n.ray.origin.distanceTo(Kr);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: Kr.clone(),
                    object: t
                }
            }

            function ts(t, e, n, i, r, s, o, a, l, c, h, u) {
                zr.fromBufferAttribute(r, c), kr.fromBufferAttribute(r, h), Br.fromBufferAttribute(r, u);
                const d = t.morphTargetInfluences;
                if (e.morphTargets && s && d) {
                    jr.set(0, 0, 0), Wr.set(0, 0, 0), qr.set(0, 0, 0);
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = d[t],
                            n = s[t];
                        0 !== e && (Hr.fromBufferAttribute(n, c), Gr.fromBufferAttribute(n, h), Vr.fromBufferAttribute(n, u), o ? (jr.addScaledVector(Hr, e), Wr.addScaledVector(Gr, e), qr.addScaledVector(Vr, e)) : (jr.addScaledVector(Hr.sub(zr), e), Wr.addScaledVector(Gr.sub(kr), e), qr.addScaledVector(Vr.sub(Br), e)))
                    }
                    zr.add(jr), kr.add(Wr), Br.add(qr)
                }
                t.isSkinnedMesh && (t.boneTransform(c, zr), t.boneTransform(h, kr), t.boneTransform(u, Br));
                const p = Qr(t, e, n, i, zr, kr, Br, Zr);
                if (p) {
                    a && (Xr.fromBufferAttribute(a, c), Yr.fromBufferAttribute(a, h), Jr.fromBufferAttribute(a, u), p.uv = er.getUV(Zr, zr, kr, Br, Xr, Yr, Jr, new Cn)), l && (Xr.fromBufferAttribute(l, c), Yr.fromBufferAttribute(l, h), Jr.fromBufferAttribute(l, u), p.uv2 = er.getUV(Zr, zr, kr, Br, Xr, Yr, Jr, new Cn));
                    const t = new cr(c, h, u);
                    er.getNormal(zr, kr, Br, t.normal), p.face = t
                }
                return p
            }
            $r.prototype = Object.assign(Object.create(Bi.prototype), {
                constructor: $r,
                isMesh: !0,
                copy: function(t) {
                    return Bi.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
                },
                updateMorphTargets: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            n = Object.keys(e);
                        if (n.length > 0) {
                            const t = e[n[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                },
                raycast: function(t, e) {
                    const n = this.geometry,
                        i = this.material,
                        r = this.matrixWorld;
                    if (void 0 === i) return;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), Ur.copy(n.boundingSphere), Ur.applyMatrix4(r), !1 === t.ray.intersectsSphere(Ur)) return;
                    if (Dr.getInverse(r), Fr.copy(t.ray).applyMatrix4(Dr), null !== n.boundingBox && !1 === Fr.intersectsBox(n.boundingBox)) return;
                    let s;
                    if (n.isBufferGeometry) {
                        const r = n.index,
                            o = n.attributes.position,
                            a = n.morphAttributes.position,
                            l = n.morphTargetsRelative,
                            c = n.attributes.uv,
                            h = n.attributes.uv2,
                            u = n.groups,
                            d = n.drawRange;
                        if (null !== r)
                            if (Array.isArray(i))
                                for (let n = 0, p = u.length; n < p; n++) {
                                    const p = u[n],
                                        m = i[p.materialIndex];
                                    for (let n = Math.max(p.start, d.start), i = Math.min(p.start + p.count, d.start + d.count); n < i; n += 3) {
                                        const i = r.getX(n),
                                            u = r.getX(n + 1),
                                            d = r.getX(n + 2);
                                        s = ts(this, m, t, Fr, o, a, l, c, h, i, u, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s))
                                    }
                                } else {
                                    for (let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); n < u; n += 3) {
                                        const u = r.getX(n),
                                            d = r.getX(n + 1),
                                            p = r.getX(n + 2);
                                        s = ts(this, i, t, Fr, o, a, l, c, h, u, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                                    }
                                } else if (void 0 !== o)
                                    if (Array.isArray(i))
                                        for (let n = 0, p = u.length; n < p; n++) {
                                            const r = u[n],
                                                p = i[r.materialIndex];
                                            for (let n = Math.max(r.start, d.start), i = Math.min(r.start + r.count, d.start + d.count); n < i; n += 3) {
                                                s = ts(this, p, t, Fr, o, a, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
                                            }
                                        } else {
                                            for (let n = Math.max(0, d.start), r = Math.min(o.count, d.start + d.count); n < r; n += 3) {
                                                s = ts(this, i, t, Fr, o, a, l, c, h, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                                            }
                                        }
                    } else if (n.isGeometry) {
                        const r = Array.isArray(i),
                            o = n.vertices,
                            a = n.faces;
                        let l;
                        const c = n.faceVertexUvs[0];
                        c.length > 0 && (l = c);
                        for (let n = 0, h = a.length; n < h; n++) {
                            const c = a[n],
                                h = r ? i[c.materialIndex] : i;
                            if (void 0 === h) continue;
                            const u = o[c.a],
                                d = o[c.b],
                                p = o[c.c];
                            if (s = Qr(this, h, t, Fr, u, d, p, Zr), s) {
                                if (l && l[n]) {
                                    const t = l[n];
                                    Xr.copy(t[0]), Yr.copy(t[1]), Jr.copy(t[2]), s.uv = er.getUV(Zr, u, d, p, Xr, Yr, Jr, new Cn)
                                }
                                s.face = c, s.faceIndex = n, e.push(s)
                            }
                        }
                    }
                }
            });
            class es extends Nr {
                constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
                    super(), this.type = "BoxBufferGeometry", this.parameters = {
                        width: t,
                        height: e,
                        depth: n,
                        widthSegments: i,
                        heightSegments: r,
                        depthSegments: s
                    };
                    const o = this;
                    i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
                    const a = [],
                        l = [],
                        c = [],
                        h = [];
                    let u = 0,
                        d = 0;

                    function p(t, e, n, i, r, s, p, m, f, g, v) {
                        const y = s / f,
                            x = p / g,
                            b = s / 2,
                            _ = p / 2,
                            w = m / 2,
                            M = f + 1,
                            S = g + 1;
                        let T = 0,
                            E = 0;
                        const A = new Hn;
                        for (let o = 0; o < S; o++) {
                            const s = o * x - _;
                            for (let a = 0; a < M; a++) {
                                const u = a * y - b;
                                A[t] = u * i, A[e] = s * r, A[n] = w, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = m > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(a / f), h.push(1 - o / g), T += 1
                            }
                        }
                        for (let o = 0; o < g; o++)
                            for (let t = 0; t < f; t++) {
                                const e = u + t + M * o,
                                    n = u + t + M * (o + 1),
                                    i = u + (t + 1) + M * (o + 1),
                                    r = u + (t + 1) + M * o;
                                a.push(e, n, r), a.push(n, i, r), E += 6
                            }
                        o.addGroup(d, E, v), d += E, u += T
                    }
                    p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new Mr(l, 3)), this.setAttribute("normal", new Mr(c, 3)), this.setAttribute("uv", new Mr(h, 2))
                }
            }

            function ns(t) {
                const e = {};
                for (const n in t) {
                    e[n] = {};
                    for (const i in t[n]) {
                        const r = t[n][i];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                    }
                }
                return e
            }

            function is(t) {
                const e = {};
                for (let n = 0; n < t.length; n++) {
                    const i = ns(t[n]);
                    for (const t in i) e[t] = i[t]
                }
                return e
            }
            const rs = {
                clone: ns,
                merge: is
            };
            var ss = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                os = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

            function as(t) {
                ur.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = ss, this.fragmentShader = os, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
            }

            function ls() {
                Bi.call(this), this.type = "Camera", this.matrixWorldInverse = new fi, this.projectionMatrix = new fi, this.projectionMatrixInverse = new fi
            }

            function cs(t, e, n, i) {
                ls.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            as.prototype = Object.create(ur.prototype), as.prototype.constructor = as, as.prototype.isShaderMaterial = !0, as.prototype.copy = function(t) {
                return ur.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = ns(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
            }, as.prototype.toJSON = function(t) {
                const e = ur.prototype.toJSON.call(this, t);
                e.glslVersion = this.glslVersion, e.uniforms = {};
                for (const i in this.uniforms) {
                    const n = this.uniforms[i].value;
                    n && n.isTexture ? e.uniforms[i] = {
                        type: "t",
                        value: n.toJSON(t).uuid
                    } : n && n.isColor ? e.uniforms[i] = {
                        type: "c",
                        value: n.getHex()
                    } : n && n.isVector2 ? e.uniforms[i] = {
                        type: "v2",
                        value: n.toArray()
                    } : n && n.isVector3 ? e.uniforms[i] = {
                        type: "v3",
                        value: n.toArray()
                    } : n && n.isVector4 ? e.uniforms[i] = {
                        type: "v4",
                        value: n.toArray()
                    } : n && n.isMatrix3 ? e.uniforms[i] = {
                        type: "m3",
                        value: n.toArray()
                    } : n && n.isMatrix4 ? e.uniforms[i] = {
                        type: "m4",
                        value: n.toArray()
                    } : e.uniforms[i] = {
                        value: n
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                const n = {};
                for (const i in this.extensions) !0 === this.extensions[i] && (n[i] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n), e
            }, ls.prototype = Object.assign(Object.create(Bi.prototype), {
                constructor: ls,
                isCamera: !0,
                copy: function(t, e) {
                    return Bi.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new Hn), this.updateMatrixWorld(!0);
                    const e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize()
                },
                updateMatrixWorld: function(t) {
                    Bi.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                updateWorldMatrix: function(t, e) {
                    Bi.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), cs.prototype = Object.assign(Object.create(ls.prototype), {
                constructor: cs,
                isPerspectiveCamera: !0,
                copy: function(t, e) {
                    return ls.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                },
                setFocalLength: function(t) {
                    const e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * Pn.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    const t = Math.tan(.5 * Pn.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / t
                },
                getEffectiveFOV: function() {
                    return 2 * Pn.RAD2DEG * Math.atan(Math.tan(.5 * Pn.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(t, e, n, i, r, s) {
                    this.aspect = t / e, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    const t = this.near;
                    let e = t * Math.tan(.5 * Pn.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * e,
                        i = this.aspect * n,
                        r = -.5 * i;
                    const s = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const t = s.fullWidth,
                            o = s.fullHeight;
                        r += s.offsetX * i / t, e -= s.offsetY * n / o, i *= s.width / t, n *= s.height / o
                    }
                    const o = this.filmOffset;
                    0 !== o && (r += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    const e = Bi.prototype.toJSON.call(this, t);
                    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                }
            });
            const hs = 90,
                us = 1;

            function ds(t, e, n) {
                if (Bi.call(this), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                this.renderTarget = n;
                const i = new cs(hs, us, t, e);
                i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Hn(1, 0, 0)), this.add(i);
                const r = new cs(hs, us, t, e);
                r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Hn(-1, 0, 0)), this.add(r);
                const s = new cs(hs, us, t, e);
                s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new Hn(0, 1, 0)), this.add(s);
                const o = new cs(hs, us, t, e);
                o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new Hn(0, -1, 0)), this.add(o);
                const a = new cs(hs, us, t, e);
                a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new Hn(0, 0, 1)), this.add(a);
                const l = new cs(hs, us, t, e);
                l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Hn(0, 0, -1)), this.add(l), this.update = function(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    const c = t.xr.enabled,
                        h = t.getRenderTarget();
                    t.xr.enabled = !1;
                    const u = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(h), t.xr.enabled = c
                }, this.clear = function(t, e, i, r) {
                    const s = t.getRenderTarget();
                    for (let o = 0; o < 6; o++) t.setRenderTarget(n, o), t.clear(e, i, r);
                    t.setRenderTarget(s)
                }
            }

            function ps(t, e, n, i, r, s, o, a, l, c) {
                t = void 0 !== t ? t : [], e = void 0 !== e ? e : At, o = void 0 !== o ? o : ee, Fn.call(this, t, e, n, i, r, s, o, a, l, c), this.flipY = !1, this._needsFlipEnvMap = !0
            }

            function ms(t, e, n) {
                Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), zn.call(this, t, t, e), e = e || {}, this.texture = new ps(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture._needsFlipEnvMap = !1
            }

            function fs(t, e, n, i, r, s, o, a, l, c, h, u) {
                Fn.call(this, null, s, o, a, l, c, i, r, h, u), this.image = {
                    data: t || null,
                    width: e || 1,
                    height: n || 1
                }, this.magFilter = void 0 !== l ? l : Ft, this.minFilter = void 0 !== c ? c : Ft, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
            }
            ds.prototype = Object.create(Bi.prototype), ds.prototype.constructor = ds, ps.prototype = Object.create(Fn.prototype), ps.prototype.constructor = ps, ps.prototype.isCubeTexture = !0, Object.defineProperty(ps.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(t) {
                    this.image = t
                }
            }), ms.prototype = Object.create(zn.prototype), ms.prototype.constructor = ms, ms.prototype.isWebGLCubeRenderTarget = !0, ms.prototype.fromEquirectangularTexture = function(t, e) {
                this.texture.type = e.type, this.texture.format = ne, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                const n = {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: "\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",
                        fragmentShader: "\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t"
                    },
                    i = new es(5, 5, 5),
                    r = new as({
                        name: "CubemapFromEquirect",
                        uniforms: ns(n.uniforms),
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader,
                        side: B,
                        blending: G
                    });
                r.uniforms.tEquirect.value = e;
                const s = new $r(i, r),
                    o = e.minFilter;
                return e.minFilter === Ht && (e.minFilter = kt), new ds(1, 10, this).update(t, s), e.minFilter = o, s.geometry.dispose(), s.material.dispose(), this
            }, fs.prototype = Object.create(Fn.prototype), fs.prototype.constructor = fs, fs.prototype.isDataTexture = !0;
            const gs = new oi,
                vs = new Hn;
            class ys {
                constructor(t, e, n, i, r, s) {
                    this.planes = [void 0 !== t ? t : new ji, void 0 !== e ? e : new ji, void 0 !== n ? n : new ji, void 0 !== i ? i : new ji, void 0 !== r ? r : new ji, void 0 !== s ? s : new ji]
                }
                set(t, e, n, i, r, s) {
                    const o = this.planes;
                    return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(s), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                    return this
                }
                setFromProjectionMatrix(t) {
                    const e = this.planes,
                        n = t.elements,
                        i = n[0],
                        r = n[1],
                        s = n[2],
                        o = n[3],
                        a = n[4],
                        l = n[5],
                        c = n[6],
                        h = n[7],
                        u = n[8],
                        d = n[9],
                        p = n[10],
                        m = n[11],
                        f = n[12],
                        g = n[13],
                        v = n[14],
                        y = n[15];
                    return e[0].setComponents(o - i, h - a, m - u, y - f).normalize(), e[1].setComponents(o + i, h + a, m + u, y + f).normalize(), e[2].setComponents(o + r, h + l, m + d, y + g).normalize(), e[3].setComponents(o - r, h - l, m - d, y - g).normalize(), e[4].setComponents(o - s, h - c, m - p, y - v).normalize(), e[5].setComponents(o + s, h + c, m + p, y + v).normalize(), this
                }
                intersectsObject(t) {
                    const e = t.geometry;
                    return null === e.boundingSphere && e.computeBoundingSphere(), gs.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(gs)
                }
                intersectsSprite(t) {
                    return gs.center.set(0, 0, 0), gs.radius = .7071067811865476, gs.applyMatrix4(t.matrixWorld), this.intersectsSphere(gs)
                }
                intersectsSphere(t) {
                    const e = this.planes,
                        n = t.center,
                        i = -t.radius;
                    for (let r = 0; r < 6; r++) {
                        if (e[r].distanceToPoint(n) < i) return !1
                    }
                    return !0
                }
                intersectsBox(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++) {
                        const i = e[n];
                        if (vs.x = i.normal.x > 0 ? t.max.x : t.min.x, vs.y = i.normal.y > 0 ? t.max.y : t.min.y, vs.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(vs) < 0) return !1
                    }
                    return !0
                }
                containsPoint(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++)
                        if (e[n].distanceToPoint(t) < 0) return !1;
                    return !0
                }
            }

            function xs() {
                let t = null,
                    e = !1,
                    n = null,
                    i = null;

                function r(e, s) {
                    n(e, s), i = t.requestAnimationFrame(r)
                }
                return {
                    start: function() {
                        !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0)
                    },
                    stop: function() {
                        t.cancelAnimationFrame(i), e = !1
                    },
                    setAnimationLoop: function(t) {
                        n = t
                    },
                    setContext: function(e) {
                        t = e
                    }
                }
            }

            function bs(t, e) {
                const n = e.isWebGL2,
                    i = new WeakMap;
                return {
                    get: function(t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
                    },
                    remove: function(e) {
                        e.isInterleavedBufferAttribute && (e = e.data);
                        const n = i.get(e);
                        n && (t.deleteBuffer(n.buffer), i.delete(e))
                    },
                    update: function(e, r) {
                        if (e.isGLBufferAttribute) {
                            var s = i.get(e);
                            return void((!s || s.version < e.version) && i.set(e, {
                                buffer: e.buffer,
                                type: e.type,
                                bytesPerElement: e.elementSize,
                                version: e.version
                            }))
                        }
                        e.isInterleavedBufferAttribute && (e = e.data);
                        const o = i.get(e);
                        void 0 === o ? i.set(e, function(e, n) {
                            const i = e.array,
                                r = e.usage,
                                s = t.createBuffer();
                            t.bindBuffer(n, s), t.bufferData(n, i, r), e.onUploadCallback();
                            let o = 5126;
                            return i instanceof Float32Array ? o = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? o = 5123 : i instanceof Int16Array ? o = 5122 : i instanceof Uint32Array ? o = 5125 : i instanceof Int32Array ? o = 5124 : i instanceof Int8Array ? o = 5120 : i instanceof Uint8Array && (o = 5121), {
                                buffer: s,
                                type: o,
                                bytesPerElement: i.BYTES_PER_ELEMENT,
                                version: e.version
                            }
                        }(e, r)) : o.version < e.version && (! function(e, i, r) {
                            const s = i.array,
                                o = i.updateRange;
                            t.bindBuffer(r, e), -1 === o.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1)
                        }(o.buffer, e, r), o.version = e.version)
                    }
                }
            }
            class _s extends Nr {
                constructor(t, e, n, i) {
                    super(), this.type = "PlaneBufferGeometry", this.parameters = {
                        width: t,
                        height: e,
                        widthSegments: n,
                        heightSegments: i
                    };
                    const r = (t = t || 1) / 2,
                        s = (e = e || 1) / 2,
                        o = Math.floor(n) || 1,
                        a = Math.floor(i) || 1,
                        l = o + 1,
                        c = a + 1,
                        h = t / o,
                        u = e / a,
                        d = [],
                        p = [],
                        m = [],
                        f = [];
                    for (let g = 0; g < c; g++) {
                        const t = g * u - s;
                        for (let e = 0; e < l; e++) {
                            const n = e * h - r;
                            p.push(n, -t, 0), m.push(0, 0, 1), f.push(e / o), f.push(1 - g / a)
                        }
                    }
                    for (let g = 0; g < a; g++)
                        for (let t = 0; t < o; t++) {
                            const e = t + l * g,
                                n = t + l * (g + 1),
                                i = t + 1 + l * (g + 1),
                                r = t + 1 + l * g;
                            d.push(e, n, r), d.push(n, i, r)
                        }
                    this.setIndex(d), this.setAttribute("position", new Mr(p, 3)), this.setAttribute("normal", new Mr(m, 3)), this.setAttribute("uv", new Mr(f, 2))
                }
            }
            const ws = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                    normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
                    transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
                },
                Ms = {
                    common: {
                        diffuse: {
                            value: new lr(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new On
                        },
                        uv2Transform: {
                            value: new On
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new Cn(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new lr(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new lr(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new On
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new lr(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new Cn(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new On
                        }
                    }
                },
                Ss = {
                    basic: {
                        uniforms: is([Ms.common, Ms.specularmap, Ms.envmap, Ms.aomap, Ms.lightmap, Ms.fog]),
                        vertexShader: ws.meshbasic_vert,
                        fragmentShader: ws.meshbasic_frag
                    },
                    lambert: {
                        uniforms: is([Ms.common, Ms.specularmap, Ms.envmap, Ms.aomap, Ms.lightmap, Ms.emissivemap, Ms.fog, Ms.lights, {
                            emissive: {
                                value: new lr(0)
                            }
                        }]),
                        vertexShader: ws.meshlambert_vert,
                        fragmentShader: ws.meshlambert_frag
                    },
                    phong: {
                        uniforms: is([Ms.common, Ms.specularmap, Ms.envmap, Ms.aomap, Ms.lightmap, Ms.emissivemap, Ms.bumpmap, Ms.normalmap, Ms.displacementmap, Ms.fog, Ms.lights, {
                            emissive: {
                                value: new lr(0)
                            },
                            specular: {
                                value: new lr(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: ws.meshphong_vert,
                        fragmentShader: ws.meshphong_frag
                    },
                    standard: {
                        uniforms: is([Ms.common, Ms.envmap, Ms.aomap, Ms.lightmap, Ms.emissivemap, Ms.bumpmap, Ms.normalmap, Ms.displacementmap, Ms.roughnessmap, Ms.metalnessmap, Ms.fog, Ms.lights, {
                            emissive: {
                                value: new lr(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ws.meshphysical_vert,
                        fragmentShader: ws.meshphysical_frag
                    },
                    toon: {
                        uniforms: is([Ms.common, Ms.aomap, Ms.lightmap, Ms.emissivemap, Ms.bumpmap, Ms.normalmap, Ms.displacementmap, Ms.gradientmap, Ms.fog, Ms.lights, {
                            emissive: {
                                value: new lr(0)
                            }
                        }]),
                        vertexShader: ws.meshtoon_vert,
                        fragmentShader: ws.meshtoon_frag
                    },
                    matcap: {
                        uniforms: is([Ms.common, Ms.bumpmap, Ms.normalmap, Ms.displacementmap, Ms.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: ws.meshmatcap_vert,
                        fragmentShader: ws.meshmatcap_frag
                    },
                    points: {
                        uniforms: is([Ms.points, Ms.fog]),
                        vertexShader: ws.points_vert,
                        fragmentShader: ws.points_frag
                    },
                    dashed: {
                        uniforms: is([Ms.common, Ms.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: ws.linedashed_vert,
                        fragmentShader: ws.linedashed_frag
                    },
                    depth: {
                        uniforms: is([Ms.common, Ms.displacementmap]),
                        vertexShader: ws.depth_vert,
                        fragmentShader: ws.depth_frag
                    },
                    normal: {
                        uniforms: is([Ms.common, Ms.bumpmap, Ms.normalmap, Ms.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ws.normal_vert,
                        fragmentShader: ws.normal_frag
                    },
                    sprite: {
                        uniforms: is([Ms.sprite, Ms.fog]),
                        vertexShader: ws.sprite_vert,
                        fragmentShader: ws.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new On
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: ws.background_vert,
                        fragmentShader: ws.background_frag
                    },
                    cube: {
                        uniforms: is([Ms.envmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ws.cube_vert,
                        fragmentShader: ws.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: ws.equirect_vert,
                        fragmentShader: ws.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: is([Ms.common, Ms.displacementmap, {
                            referencePosition: {
                                value: new Hn
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: ws.distanceRGBA_vert,
                        fragmentShader: ws.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: is([Ms.lights, Ms.fog, {
                            color: {
                                value: new lr(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ws.shadow_vert,
                        fragmentShader: ws.shadow_frag
                    }
                };

            function Ts(t, e, n, i, r) {
                const s = new lr(0);
                let o, a, l = 0,
                    c = null,
                    h = 0,
                    u = null;

                function d(t, e) {
                    n.buffers.color.setClear(t.r, t.g, t.b, e, r)
                }
                return {
                    getClearColor: function() {
                        return s
                    },
                    setClearColor: function(t, e) {
                        s.set(t), l = void 0 !== e ? e : 1, d(s, l)
                    },
                    getClearAlpha: function() {
                        return l
                    },
                    setClearAlpha: function(t) {
                        l = t, d(s, l)
                    },
                    render: function(n, r, p, m) {
                        let f = !0 === r.isScene ? r.background : null;
                        f && f.isTexture && (f = e.get(f));
                        const g = t.xr,
                            v = g.getSession && g.getSession();
                        v && "additive" === v.environmentBlendMode && (f = null), null === f ? d(s, l) : f && f.isColor && (d(f, 1), m = !0), (t.autoClear || m) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), f && (f.isCubeTexture || f.isWebGLCubeRenderTarget || f.mapping === Ct) ? (void 0 === a && (a = new $r(new es(1, 1, 1), new as({
                            name: "BackgroundCubeMaterial",
                            uniforms: ns(Ss.cube.uniforms),
                            vertexShader: Ss.cube.vertexShader,
                            fragmentShader: Ss.cube.fragmentShader,
                            side: B,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function(t, e, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, Object.defineProperty(a.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), i.update(a)), f.isWebGLCubeRenderTarget && (f = f.texture), a.material.uniforms.envMap.value = f, a.material.uniforms.flipEnvMap.value = f.isCubeTexture && f._needsFlipEnvMap ? -1 : 1, c === f && h === f.version && u === t.toneMapping || (a.material.needsUpdate = !0, c = f, h = f.version, u = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) : f && f.isTexture && (void 0 === o && (o = new $r(new _s(2, 2), new as({
                            name: "BackgroundMaterial",
                            uniforms: ns(Ss.background.uniforms),
                            vertexShader: Ss.background.vertexShader,
                            fragmentShader: Ss.background.fragmentShader,
                            side: k,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), i.update(o)), o.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), o.material.uniforms.uvTransform.value.copy(f.matrix), c === f && h === f.version && u === t.toneMapping || (o.material.needsUpdate = !0, c = f, h = f.version, u = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
                    }
                }
            }

            function Es(t, e, n, i) {
                const r = t.getParameter(34921),
                    s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                    o = i.isWebGL2 || null !== s,
                    a = {},
                    l = d(null);
                let c = l;

                function h(e) {
                    return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
                }

                function u(e) {
                    return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
                }

                function d(t) {
                    const e = [],
                        n = [],
                        i = [];
                    for (let s = 0; s < r; s++) e[s] = 0, n[s] = 0, i[s] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: e,
                        enabledAttributes: n,
                        attributeDivisors: i,
                        object: t,
                        attributes: {},
                        index: null
                    }
                }

                function p() {
                    const t = c.newAttributes;
                    for (let e = 0, n = t.length; e < n; e++) t[e] = 0
                }

                function m(t) {
                    f(t, 0)
                }

                function f(n, r) {
                    const s = c.newAttributes,
                        o = c.enabledAttributes,
                        a = c.attributeDivisors;
                    if (s[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), a[n] !== r) {
                        (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r
                    }
                }

                function g() {
                    const e = c.newAttributes,
                        n = c.enabledAttributes;
                    for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
                }

                function v(e, n, r, s, o, a) {
                    !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, s, o, a) : t.vertexAttribIPointer(e, n, r, o, a)
                }

                function y() {
                    x(), c !== l && (c = l, h(c.object))
                }

                function x() {
                    l.geometry = null, l.program = null, l.wireframe = !1
                }
                return {
                    setup: function(r, l, u, y, x) {
                        let b = !1;
                        if (o) {
                            const e = function(e, n, r) {
                                const o = !0 === r.wireframe;
                                let l = a[e.id];
                                void 0 === l && (l = {}, a[e.id] = l);
                                let c = l[n.id];
                                void 0 === c && (c = {}, l[n.id] = c);
                                let h = c[o];
                                void 0 === h && (h = d(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), c[o] = h);
                                return h
                            }(y, u, l);
                            c !== e && (c = e, h(c.object)), b = function(t, e) {
                                const n = c.attributes,
                                    i = t.attributes;
                                if (Object.keys(n).length !== Object.keys(i).length) return !0;
                                for (const r in i) {
                                    const t = n[r],
                                        e = i[r];
                                    if (void 0 === t) return !0;
                                    if (t.attribute !== e) return !0;
                                    if (t.data !== e.data) return !0
                                }
                                return c.index !== e
                            }(y, x), b && function(t, e) {
                                const n = {},
                                    i = t.attributes;
                                for (const r in i) {
                                    const t = i[r],
                                        e = {};
                                    e.attribute = t, t.data && (e.data = t.data), n[r] = e
                                }
                                c.attributes = n, c.index = e
                            }(y, x)
                        } else {
                            const t = !0 === l.wireframe;
                            c.geometry === y.id && c.program === u.id && c.wireframe === t || (c.geometry = y.id, c.program = u.id, c.wireframe = t, b = !0)
                        }!0 === r.isInstancedMesh && (b = !0), null !== x && n.update(x, 34963), b && (! function(r, s, o, a) {
                            if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                            p();
                            const l = a.attributes,
                                c = o.getAttributes(),
                                h = s.defaultAttributeValues;
                            for (const e in c) {
                                const i = c[e];
                                if (i >= 0) {
                                    const s = l[e];
                                    if (void 0 !== s) {
                                        const e = s.normalized,
                                            r = s.itemSize,
                                            o = n.get(s);
                                        if (void 0 === o) continue;
                                        const l = o.buffer,
                                            c = o.type,
                                            h = o.bytesPerElement;
                                        if (s.isInterleavedBufferAttribute) {
                                            const n = s.data,
                                                o = n.stride,
                                                u = s.offset;
                                            n && n.isInstancedInterleavedBuffer ? (f(i, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : m(i), t.bindBuffer(34962, l), v(i, r, c, e, o * h, u * h)
                                        } else s.isInstancedBufferAttribute ? (f(i, s.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count)) : m(i), t.bindBuffer(34962, l), v(i, r, c, e, 0, 0)
                                    } else if ("instanceMatrix" === e) {
                                        const e = n.get(r.instanceMatrix);
                                        if (void 0 === e) continue;
                                        const s = e.buffer,
                                            o = e.type;
                                        f(i + 0, 1), f(i + 1, 1), f(i + 2, 1), f(i + 3, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(i + 0, 4, o, !1, 64, 0), t.vertexAttribPointer(i + 1, 4, o, !1, 64, 16), t.vertexAttribPointer(i + 2, 4, o, !1, 64, 32), t.vertexAttribPointer(i + 3, 4, o, !1, 64, 48)
                                    } else if ("instanceColor" === e) {
                                        const e = n.get(r.instanceColor);
                                        if (void 0 === e) continue;
                                        const s = e.buffer,
                                            o = e.type;
                                        f(i, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(i, 3, o, !1, 12, 0)
                                    } else if (void 0 !== h) {
                                        const n = h[e];
                                        if (void 0 !== n) switch (n.length) {
                                            case 2:
                                                t.vertexAttrib2fv(i, n);
                                                break;
                                            case 3:
                                                t.vertexAttrib3fv(i, n);
                                                break;
                                            case 4:
                                                t.vertexAttrib4fv(i, n);
                                                break;
                                            default:
                                                t.vertexAttrib1fv(i, n)
                                        }
                                    }
                                }
                            }
                            g()
                        }(r, l, u, y), null !== x && t.bindBuffer(34963, n.get(x).buffer))
                    },
                    reset: y,
                    resetDefaultState: x,
                    dispose: function() {
                        y();
                        for (const t in a) {
                            const e = a[t];
                            for (const t in e) {
                                const n = e[t];
                                for (const t in n) u(n[t].object), delete n[t];
                                delete e[t]
                            }
                            delete a[t]
                        }
                    },
                    releaseStatesOfGeometry: function(t) {
                        if (void 0 === a[t.id]) return;
                        const e = a[t.id];
                        for (const n in e) {
                            const t = e[n];
                            for (const e in t) u(t[e].object), delete t[e];
                            delete e[n]
                        }
                        delete a[t.id]
                    },
                    releaseStatesOfProgram: function(t) {
                        for (const e in a) {
                            const n = a[e];
                            if (void 0 === n[t.id]) continue;
                            const i = n[t.id];
                            for (const t in i) u(i[t].object), delete i[t];
                            delete n[t.id]
                        }
                    },
                    initAttributes: p,
                    enableAttribute: m,
                    disableUnusedAttributes: g
                }
            }

            function As(t, e, n, i) {
                const r = i.isWebGL2;
                let s;
                this.setMode = function(t) {
                    s = t
                }, this.render = function(e, i) {
                    t.drawArrays(s, e, i), n.update(i, s, 1)
                }, this.renderInstances = function(i, o, a) {
                    if (0 === a) return;
                    let l, c;
                    if (r) l = t, c = "drawArraysInstanced";
                    else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    l[c](s, i, o, a), n.update(o, s, a)
                }
            }

            function Ls(t, e, n) {
                let i;

                function r(e) {
                    if ("highp" === e) {
                        if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        e = "mediump"
                    }
                    return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                const s = "undefined" !== typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" !== typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
                let o = void 0 !== n.precision ? n.precision : "highp";
                const a = r(o);
                a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
                const l = !0 === n.logarithmicDepthBuffer,
                    c = t.getParameter(34930),
                    h = t.getParameter(35660),
                    u = t.getParameter(3379),
                    d = t.getParameter(34076),
                    p = t.getParameter(34921),
                    m = t.getParameter(36347),
                    f = t.getParameter(36348),
                    g = t.getParameter(36349),
                    v = h > 0,
                    y = s || !!e.get("OES_texture_float");
                return {
                    isWebGL2: s,
                    getMaxAnisotropy: function() {
                        if (void 0 !== i) return i;
                        const n = e.get("EXT_texture_filter_anisotropic");
                        return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, i
                    },
                    getMaxPrecision: r,
                    precision: o,
                    logarithmicDepthBuffer: l,
                    maxTextures: c,
                    maxVertexTextures: h,
                    maxTextureSize: u,
                    maxCubemapSize: d,
                    maxAttributes: p,
                    maxVertexUniforms: m,
                    maxVaryings: f,
                    maxFragmentUniforms: g,
                    vertexTextures: v,
                    floatFragmentTextures: y,
                    floatVertexTextures: v && y,
                    maxSamples: s ? t.getParameter(36183) : 0
                }
            }

            function Rs(t) {
                const e = this;
                let n = null,
                    i = 0,
                    r = !1,
                    s = !1;
                const o = new ji,
                    a = new On,
                    l = {
                        value: null,
                        needsUpdate: !1
                    };

                function c() {
                    l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
                }

                function h(t, n, i, r) {
                    const s = null !== t ? t.length : 0;
                    let c = null;
                    if (0 !== s) {
                        if (c = l.value, !0 !== r || null === c) {
                            const e = i + 4 * s,
                                r = n.matrixWorldInverse;
                            a.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
                            for (let n = 0, l = i; n !== s; ++n, l += 4) o.copy(t[n]).applyMatrix4(r, a), o.normal.toArray(c, l), c[l + 3] = o.constant
                        }
                        l.value = c, l.needsUpdate = !0
                    }
                    return e.numPlanes = s, e.numIntersection = 0, c
                }
                this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, s) {
                    const o = 0 !== t.length || e || 0 !== i || r;
                    return r = e, n = h(t, s, 0), i = t.length, o
                }, this.beginShadows = function() {
                    s = !0, h(null)
                }, this.endShadows = function() {
                    s = !1, c()
                }, this.setState = function(e, o, a) {
                    const u = e.clippingPlanes,
                        d = e.clipIntersection,
                        p = e.clipShadows,
                        m = t.get(e);
                    if (!r || null === u || 0 === u.length || s && !p) s ? h(null) : c();
                    else {
                        const t = s ? 0 : i,
                            e = 4 * t;
                        let r = m.clippingState || null;
                        l.value = r, r = h(u, o, e, a);
                        for (let i = 0; i !== e; ++i) r[i] = n[i];
                        m.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                    }
                }
            }

            function Ps(t) {
                let e = new WeakMap;

                function n(t, e) {
                    return e === Rt ? t.mapping = At : e === Pt && (t.mapping = Lt), t
                }
                return {
                    get: function(i) {
                        if (i && i.isTexture) {
                            const r = i.mapping;
                            if (r === Rt || r === Pt) {
                                if (e.has(i)) {
                                    return n(e.get(i).texture, i.mapping)
                                } {
                                    const r = i.image;
                                    if (r && r.height > 0) {
                                        const s = t.getRenderList(),
                                            o = t.getRenderTarget(),
                                            a = t.getRenderState(),
                                            l = new ms(r.height / 2);
                                        return l.fromEquirectangularTexture(t, i), e.set(i, l), t.setRenderTarget(o), t.setRenderList(s), t.setRenderState(a), n(l.texture, i.mapping)
                                    }
                                    return null
                                }
                            }
                        }
                        return i
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function Cs(t) {
                const e = {};
                return {
                    has: function(n) {
                        if (void 0 !== e[n]) return null !== e[n];
                        let i;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                i = t.getExtension(n)
                        }
                        return e[n] = i, null !== i
                    },
                    get: function(t) {
                        return this.has(t) || console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e[t]
                    }
                }
            }

            function Os(t, e, n, i) {
                const r = new WeakMap,
                    s = new WeakMap;

                function o(t) {
                    const a = t.target,
                        l = r.get(a);
                    null !== l.index && e.remove(l.index);
                    for (const n in l.attributes) e.remove(l.attributes[n]);
                    a.removeEventListener("dispose", o), r.delete(a);
                    const c = s.get(l);
                    c && (e.remove(c), s.delete(l)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
                }

                function a(t) {
                    const n = [],
                        i = t.index,
                        r = t.attributes.position;
                    let o = 0;
                    if (null !== i) {
                        const t = i.array;
                        o = i.version;
                        for (let e = 0, i = t.length; e < i; e += 3) {
                            const i = t[e + 0],
                                r = t[e + 1],
                                s = t[e + 2];
                            n.push(i, r, r, s, s, i)
                        }
                    } else {
                        const t = r.array;
                        o = r.version;
                        for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                            const t = e + 0,
                                i = e + 1,
                                r = e + 2;
                            n.push(t, i, i, r, r, t)
                        }
                    }
                    const a = new(Er(n) > 65535 ? wr : br)(n, 1);
                    a.version = o;
                    const l = s.get(t);
                    l && e.remove(l), s.set(t, a)
                }
                return {
                    get: function(t, e) {
                        let i = r.get(e);
                        return i || (e.addEventListener("dispose", o), e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Nr).setFromObject(t)), i = e._bufferGeometry), r.set(e, i), n.memory.geometries++, i)
                    },
                    update: function(t) {
                        const n = t.attributes;
                        for (const r in n) e.update(n[r], 34962);
                        const i = t.morphAttributes;
                        for (const r in i) {
                            const t = i[r];
                            for (let n = 0, i = t.length; n < i; n++) e.update(t[n], 34962)
                        }
                    },
                    getWireframeAttribute: function(t) {
                        const e = s.get(t);
                        if (e) {
                            const n = t.index;
                            null !== n && e.version < n.version && a(t)
                        } else a(t);
                        return s.get(t)
                    }
                }
            }

            function Is(t, e, n, i) {
                const r = i.isWebGL2;
                let s, o, a;
                this.setMode = function(t) {
                    s = t
                }, this.setIndex = function(t) {
                    o = t.type, a = t.bytesPerElement
                }, this.render = function(e, i) {
                    t.drawElements(s, i, o, e * a), n.update(i, s, 1)
                }, this.renderInstances = function(i, l, c) {
                    if (0 === c) return;
                    let h, u;
                    if (r) h = t, u = "drawElementsInstanced";
                    else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    h[u](s, l, o, i * a, c), n.update(l, s, c)
                }
            }

            function Ns(t) {
                const e = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: e,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                    },
                    update: function(t, n, i) {
                        switch (e.calls++, n) {
                            case 4:
                                e.triangles += i * (t / 3);
                                break;
                            case 1:
                                e.lines += i * (t / 2);
                                break;
                            case 3:
                                e.lines += i * (t - 1);
                                break;
                            case 2:
                                e.lines += i * t;
                                break;
                            case 0:
                                e.points += i * t;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                        }
                    }
                }
            }

            function Ds(t, e) {
                return t[0] - e[0]
            }

            function Fs(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1])
            }

            function Us(t) {
                const e = {},
                    n = new Float32Array(8),
                    i = [];
                for (let r = 0; r < 8; r++) i[r] = [r, 0];
                return {
                    update: function(r, s, o, a) {
                        const l = r.morphTargetInfluences,
                            c = void 0 === l ? 0 : l.length;
                        let h = e[s.id];
                        if (void 0 === h) {
                            h = [];
                            for (let t = 0; t < c; t++) h[t] = [t, 0];
                            e[s.id] = h
                        }
                        for (let t = 0; t < c; t++) {
                            const e = h[t];
                            e[0] = t, e[1] = l[t]
                        }
                        h.sort(Fs);
                        for (let t = 0; t < 8; t++) t < c && h[t][1] ? (i[t][0] = h[t][0], i[t][1] = h[t][1]) : (i[t][0] = Number.MAX_SAFE_INTEGER, i[t][1] = 0);
                        i.sort(Ds);
                        const u = o.morphTargets && s.morphAttributes.position,
                            d = o.morphNormals && s.morphAttributes.normal;
                        let p = 0;
                        for (let t = 0; t < 8; t++) {
                            const e = i[t],
                                r = e[0],
                                o = e[1];
                            r !== Number.MAX_SAFE_INTEGER && o ? (u && s.getAttribute("morphTarget" + t) !== u[r] && s.setAttribute("morphTarget" + t, u[r]), d && s.getAttribute("morphNormal" + t) !== d[r] && s.setAttribute("morphNormal" + t, d[r]), n[t] = o, p += o) : (u && void 0 !== s.getAttribute("morphTarget" + t) && s.deleteAttribute("morphTarget" + t), d && void 0 !== s.getAttribute("morphNormal" + t) && s.deleteAttribute("morphNormal" + t), n[t] = 0)
                        }
                        const m = s.morphTargetsRelative ? 1 : 1 - p;
                        a.getUniforms().setValue(t, "morphTargetBaseInfluence", m), a.getUniforms().setValue(t, "morphTargetInfluences", n)
                    }
                }
            }

            function zs(t, e, n, i) {
                let r = new WeakMap;
                return {
                    update: function(t) {
                        const s = i.render.frame,
                            o = t.geometry,
                            a = e.get(t, o);
                        return r.get(a) !== s && (o.isGeometry && a.updateFromObject(t), e.update(a), r.set(a, s)), t.isInstancedMesh && (n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), a
                    },
                    dispose: function() {
                        r = new WeakMap
                    }
                }
            }

            function ks(t, e, n, i) {
                Fn.call(this, null), this.image = {
                    data: t || null,
                    width: e || 1,
                    height: n || 1,
                    depth: i || 1
                }, this.magFilter = Ft, this.minFilter = Ft, this.wrapR = Nt, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
            }

            function Bs(t, e, n, i) {
                Fn.call(this, null), this.image = {
                    data: t || null,
                    width: e || 1,
                    height: n || 1,
                    depth: i || 1
                }, this.magFilter = Ft, this.minFilter = Ft, this.wrapR = Nt, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
            }
            Ss.physical = {
                uniforms: is([Ss.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatNormalScale: {
                        value: new Cn(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    sheen: {
                        value: new lr(0)
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    }
                }]),
                vertexShader: ws.meshphysical_vert,
                fragmentShader: ws.meshphysical_frag
            }, ks.prototype = Object.create(Fn.prototype), ks.prototype.constructor = ks, ks.prototype.isDataTexture2DArray = !0, Bs.prototype = Object.create(Fn.prototype), Bs.prototype.constructor = Bs, Bs.prototype.isDataTexture3D = !0;
            const Hs = new Fn,
                Gs = new ks,
                Vs = new Bs,
                js = new ps,
                Ws = [],
                qs = [],
                Xs = new Float32Array(16),
                Ys = new Float32Array(9),
                Js = new Float32Array(4);

            function Zs(t, e, n) {
                const i = t[0];
                if (i <= 0 || i > 0) return t;
                const r = e * n;
                let s = Ws[r];
                if (void 0 === s && (s = new Float32Array(r), Ws[r] = s), 0 !== e) {
                    i.toArray(s, 0);
                    for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(s, r)
                }
                return s
            }

            function Ks(t, e) {
                if (t.length !== e.length) return !1;
                for (let n = 0, i = t.length; n < i; n++)
                    if (t[n] !== e[n]) return !1;
                return !0
            }

            function $s(t, e) {
                for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
            }

            function Qs(t, e) {
                let n = qs[e];
                void 0 === n && (n = new Int32Array(e), qs[e] = n);
                for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
                return n
            }

            function to(t, e) {
                const n = this.cache;
                n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
            }

            function eo(t, e) {
                const n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                else {
                    if (Ks(n, e)) return;
                    t.uniform2fv(this.addr, e), $s(n, e)
                }
            }

            function no(t, e) {
                const n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                else {
                    if (Ks(n, e)) return;
                    t.uniform3fv(this.addr, e), $s(n, e)
                }
            }

            function io(t, e) {
                const n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                else {
                    if (Ks(n, e)) return;
                    t.uniform4fv(this.addr, e), $s(n, e)
                }
            }

            function ro(t, e) {
                const n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (Ks(n, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), $s(n, e)
                } else {
                    if (Ks(n, i)) return;
                    Js.set(i), t.uniformMatrix2fv(this.addr, !1, Js), $s(n, i)
                }
            }

            function so(t, e) {
                const n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (Ks(n, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), $s(n, e)
                } else {
                    if (Ks(n, i)) return;
                    Ys.set(i), t.uniformMatrix3fv(this.addr, !1, Ys), $s(n, i)
                }
            }

            function oo(t, e) {
                const n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (Ks(n, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), $s(n, e)
                } else {
                    if (Ks(n, i)) return;
                    Xs.set(i), t.uniformMatrix4fv(this.addr, !1, Xs), $s(n, i)
                }
            }

            function ao(t, e, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || Hs, r)
            }

            function lo(t, e, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || Gs, r)
            }

            function co(t, e, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Vs, r)
            }

            function ho(t, e, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || js, r)
            }

            function uo(t, e) {
                const n = this.cache;
                n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
            }

            function po(t, e) {
                const n = this.cache;
                Ks(n, e) || (t.uniform2iv(this.addr, e), $s(n, e))
            }

            function mo(t, e) {
                const n = this.cache;
                Ks(n, e) || (t.uniform3iv(this.addr, e), $s(n, e))
            }

            function fo(t, e) {
                const n = this.cache;
                Ks(n, e) || (t.uniform4iv(this.addr, e), $s(n, e))
            }

            function go(t, e) {
                const n = this.cache;
                n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
            }

            function vo(t, e) {
                t.uniform1fv(this.addr, e)
            }

            function yo(t, e) {
                t.uniform1iv(this.addr, e)
            }

            function xo(t, e) {
                t.uniform2iv(this.addr, e)
            }

            function bo(t, e) {
                t.uniform3iv(this.addr, e)
            }

            function _o(t, e) {
                t.uniform4iv(this.addr, e)
            }

            function wo(t, e) {
                const n = Zs(e, this.size, 2);
                t.uniform2fv(this.addr, n)
            }

            function Mo(t, e) {
                const n = Zs(e, this.size, 3);
                t.uniform3fv(this.addr, n)
            }

            function So(t, e) {
                const n = Zs(e, this.size, 4);
                t.uniform4fv(this.addr, n)
            }

            function To(t, e) {
                const n = Zs(e, this.size, 4);
                t.uniformMatrix2fv(this.addr, !1, n)
            }

            function Eo(t, e) {
                const n = Zs(e, this.size, 9);
                t.uniformMatrix3fv(this.addr, !1, n)
            }

            function Ao(t, e) {
                const n = Zs(e, this.size, 16);
                t.uniformMatrix4fv(this.addr, !1, n)
            }

            function Lo(t, e, n) {
                const i = e.length,
                    r = Qs(n, i);
                t.uniform1iv(this.addr, r);
                for (let s = 0; s !== i; ++s) n.safeSetTexture2D(e[s] || Hs, r[s])
            }

            function Ro(t, e, n) {
                const i = e.length,
                    r = Qs(n, i);
                t.uniform1iv(this.addr, r);
                for (let s = 0; s !== i; ++s) n.safeSetTextureCube(e[s] || js, r[s])
            }

            function Po(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return to;
                        case 35664:
                            return eo;
                        case 35665:
                            return no;
                        case 35666:
                            return io;
                        case 35674:
                            return ro;
                        case 35675:
                            return so;
                        case 35676:
                            return oo;
                        case 5124:
                        case 35670:
                            return uo;
                        case 35667:
                        case 35671:
                            return po;
                        case 35668:
                        case 35672:
                            return mo;
                        case 35669:
                        case 35673:
                            return fo;
                        case 5125:
                            return go;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return ao;
                        case 35679:
                        case 36299:
                        case 36307:
                            return co;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return ho;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return lo
                    }
                }(e.type)
            }

            function Co(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return vo;
                        case 35664:
                            return wo;
                        case 35665:
                            return Mo;
                        case 35666:
                            return So;
                        case 35674:
                            return To;
                        case 35675:
                            return Eo;
                        case 35676:
                            return Ao;
                        case 5124:
                        case 35670:
                            return yo;
                        case 35667:
                        case 35671:
                            return xo;
                        case 35668:
                        case 35672:
                            return bo;
                        case 35669:
                        case 35673:
                            return _o;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Lo;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Ro
                    }
                }(e.type)
            }

            function Oo(t) {
                this.id = t, this.seq = [], this.map = {}
            }
            Co.prototype.updateCache = function(t) {
                const e = this.cache;
                t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), $s(e, t)
            }, Oo.prototype.setValue = function(t, e, n) {
                const i = this.seq;
                for (let r = 0, s = i.length; r !== s; ++r) {
                    const s = i[r];
                    s.setValue(t, e[s.id], n)
                }
            };
            const Io = /([\w\d_]+)(\])?(\[|\.)?/g;

            function No(t, e) {
                t.seq.push(e), t.map[e.id] = e
            }

            function Do(t, e, n) {
                const i = t.name,
                    r = i.length;
                for (Io.lastIndex = 0;;) {
                    const s = Io.exec(i),
                        o = Io.lastIndex;
                    let a = s[1];
                    const l = "]" === s[2],
                        c = s[3];
                    if (l && (a |= 0), void 0 === c || "[" === c && o + 2 === r) {
                        No(n, void 0 === c ? new Po(a, t, e) : new Co(a, t, e));
                        break
                    } {
                        let t = n.map[a];
                        void 0 === t && (t = new Oo(a), No(n, t)), n = t
                    }
                }
            }

            function Fo(t, e) {
                this.seq = [], this.map = {};
                const n = t.getProgramParameter(e, 35718);
                for (let i = 0; i < n; ++i) {
                    const n = t.getActiveUniform(e, i);
                    Do(n, t.getUniformLocation(e, n.name), this)
                }
            }

            function Uo(t, e, n) {
                const i = t.createShader(e);
                return t.shaderSource(i, n), t.compileShader(i), i
            }
            Fo.prototype.setValue = function(t, e, n, i) {
                const r = this.map[e];
                void 0 !== r && r.setValue(t, n, i)
            }, Fo.prototype.setOptional = function(t, e, n) {
                const i = e[n];
                void 0 !== i && this.setValue(t, n, i)
            }, Fo.upload = function(t, e, n, i) {
                for (let r = 0, s = e.length; r !== s; ++r) {
                    const s = e[r],
                        o = n[s.id];
                    !1 !== o.needsUpdate && s.setValue(t, o.value, i)
                }
            }, Fo.seqWithValue = function(t, e) {
                const n = [];
                for (let i = 0, r = t.length; i !== r; ++i) {
                    const r = t[i];
                    r.id in e && n.push(r)
                }
                return n
            };
            let zo = 0;

            function ko(t) {
                switch (t) {
                    case un:
                        return ["Linear", "( value )"];
                    case dn:
                        return ["sRGB", "( value )"];
                    case mn:
                        return ["RGBE", "( value )"];
                    case gn:
                        return ["RGBM", "( value, 7.0 )"];
                    case vn:
                        return ["RGBM", "( value, 16.0 )"];
                    case yn:
                        return ["RGBD", "( value, 256.0 )"];
                    case pn:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    case fn:
                        return ["LogLuv", "( value )"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                }
            }

            function Bo(t, e, n) {
                const i = t.getShaderParameter(e, 35713),
                    r = t.getShaderInfoLog(e).trim();
                return i && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function(t) {
                    const e = t.split("\n");
                    for (let n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
                    return e.join("\n")
                }(t.getShaderSource(e))
            }

            function Ho(t, e) {
                const n = ko(e);
                return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }

            function Go(t, e) {
                const n = ko(e);
                return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
            }

            function Vo(t, e) {
                let n;
                switch (e) {
                    case wt:
                        n = "Linear";
                        break;
                    case Mt:
                        n = "Reinhard";
                        break;
                    case St:
                        n = "OptimizedCineon";
                        break;
                    case Tt:
                        n = "ACESFilmic";
                        break;
                    case Et:
                        n = "Custom";
                        break;
                    default:
                        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
                }
                return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }

            function jo(t) {
                return "" !== t
            }

            function Wo(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
            }

            function qo(t, e) {
                return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
            }
            const Xo = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function Yo(t) {
                return t.replace(Xo, Jo)
            }

            function Jo(t, e) {
                const n = ws[e];
                if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
                return Yo(n)
            }
            const Zo = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                Ko = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function $o(t) {
                return t.replace(Ko, ta).replace(Zo, Qo)
            }

            function Qo(t, e, n, i) {
                return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), ta(t, e, n, i)
            }

            function ta(t, e, n, i) {
                let r = "";
                for (let s = parseInt(e); s < parseInt(n); s++) r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
                return r
            }

            function ea(t) {
                let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
                return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
            }

            function na(t, e, n, i) {
                const r = t.getContext(),
                    s = n.defines;
                let o = n.vertexShader,
                    a = n.fragmentShader;
                const l = function(t) {
                        let e = "SHADOWMAP_TYPE_BASIC";
                        return t.shadowMapType === F ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === U ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === z && (e = "SHADOWMAP_TYPE_VSM"), e
                    }(n),
                    c = function(t) {
                        let e = "ENVMAP_TYPE_CUBE";
                        if (t.envMap) switch (t.envMapMode) {
                            case At:
                            case Lt:
                                e = "ENVMAP_TYPE_CUBE";
                                break;
                            case Ct:
                            case Ot:
                                e = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return e
                    }(n),
                    h = function(t) {
                        let e = "ENVMAP_MODE_REFLECTION";
                        if (t.envMap) switch (t.envMapMode) {
                            case Lt:
                            case Ot:
                                e = "ENVMAP_MODE_REFRACTION"
                        }
                        return e
                    }(n),
                    u = function(t) {
                        let e = "ENVMAP_BLENDING_NONE";
                        if (t.envMap) switch (t.combine) {
                            case yt:
                                e = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case xt:
                                e = "ENVMAP_BLENDING_MIX";
                                break;
                            case bt:
                                e = "ENVMAP_BLENDING_ADD"
                        }
                        return e
                    }(n),
                    d = t.gammaFactor > 0 ? t.gammaFactor : 1,
                    p = n.isWebGL2 ? "" : function(t) {
                        return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(jo).join("\n")
                    }(n),
                    m = function(t) {
                        const e = [];
                        for (const n in t) {
                            const i = t[n];
                            !1 !== i && e.push("#define " + n + " " + i)
                        }
                        return e.join("\n")
                    }(s),
                    f = r.createProgram();
                let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                n.isRawShaderMaterial ? (g = [m].filter(jo).join("\n"), g.length > 0 && (g += "\n"), v = [p, m].filter(jo).join("\n"), v.length > 0 && (v += "\n")) : (g = [ea(n), "#define SHADER_NAME " + n.shaderName, m, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(jo).join("\n"), v = [p, ea(n), "#define SHADER_NAME " + n.shaderName, m, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== _t ? "#define TONE_MAPPING" : "", n.toneMapping !== _t ? ws.tonemapping_pars_fragment : "", n.toneMapping !== _t ? Vo("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", ws.encodings_pars_fragment, n.map ? Ho("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Ho("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Ho("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Ho("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? Ho("lightMapTexelToLinear", n.lightMapEncoding) : "", Go("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(jo).join("\n")), o = Yo(o), o = Wo(o, n), o = qo(o, n), a = Yo(a), a = Wo(a, n), a = qo(a, n), o = $o(o), a = $o(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", n.glslVersion === En ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === En ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
                const x = y + v + a,
                    b = Uo(r, 35633, y + g + o),
                    _ = Uo(r, 35632, x);
                if (r.attachShader(f, b), r.attachShader(f, _), void 0 !== n.index0AttributeName ? r.bindAttribLocation(f, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(f, 0, "position"), r.linkProgram(f), t.debug.checkShaderErrors) {
                    const t = r.getProgramInfoLog(f).trim(),
                        e = r.getShaderInfoLog(b).trim(),
                        n = r.getShaderInfoLog(_).trim();
                    let i = !0,
                        s = !0;
                    if (!1 === r.getProgramParameter(f, 35714)) {
                        i = !1;
                        const e = Bo(r, b, "vertex"),
                            n = Bo(r, _, "fragment");
                        console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(f, 35715), "gl.getProgramInfoLog", t, e, n)
                    } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (s = !1);
                    s && (this.diagnostics = {
                        runnable: i,
                        programLog: t,
                        vertexShader: {
                            log: e,
                            prefix: g
                        },
                        fragmentShader: {
                            log: n,
                            prefix: v
                        }
                    })
                }
                let w, M;
                return r.deleteShader(b), r.deleteShader(_), this.getUniforms = function() {
                    return void 0 === w && (w = new Fo(r, f)), w
                }, this.getAttributes = function() {
                    return void 0 === M && (M = function(t, e) {
                        const n = {},
                            i = t.getProgramParameter(e, 35721);
                        for (let r = 0; r < i; r++) {
                            const i = t.getActiveAttrib(e, r).name;
                            n[i] = t.getAttribLocation(e, i)
                        }
                        return n
                    }(r, f)), M
                }, this.destroy = function() {
                    i.releaseStatesOfProgram(this), r.deleteProgram(f), this.program = void 0
                }, this.name = n.shaderName, this.id = zo++, this.cacheKey = e, this.usedTimes = 1, this.program = f, this.vertexShader = b, this.fragmentShader = _, this
            }

            function ia(t, e, n, i, r, s) {
                const o = [],
                    a = i.isWebGL2,
                    l = i.logarithmicDepthBuffer,
                    c = i.floatVertexTextures,
                    h = i.maxVertexUniforms,
                    u = i.vertexTextures;
                let d = i.precision;
                const p = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    m = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];

                function f(t) {
                    let e;
                    return t ? t.isTexture ? e = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = un, e
                }
                return {
                    getParameters: function(r, o, m, g, v) {
                        const y = g.fog,
                            x = r.isMeshStandardMaterial ? g.environment : null,
                            b = e.get(r.envMap || x),
                            _ = p[r.type],
                            w = v.isSkinnedMesh ? function(t) {
                                const e = t.skeleton.bones;
                                if (c) return 1024; {
                                    const t = h,
                                        n = Math.floor((t - 20) / 4),
                                        i = Math.min(n, e.length);
                                    return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i
                                }
                            }(v) : 0;
                        let M, S;
                        if (null !== r.precision && (d = i.getMaxPrecision(r.precision), d !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", d, "instead.")), _) {
                            const t = Ss[_];
                            M = t.vertexShader, S = t.fragmentShader
                        } else M = r.vertexShader, S = r.fragmentShader;
                        const T = t.getRenderTarget();
                        return {
                            isWebGL2: a,
                            shaderID: _,
                            shaderName: r.type,
                            vertexShader: M,
                            fragmentShader: S,
                            defines: r.defines,
                            isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                            glslVersion: r.glslVersion,
                            precision: d,
                            instancing: !0 === v.isInstancedMesh,
                            instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
                            supportsVertexTextures: u,
                            outputEncoding: null !== T ? f(T.texture) : t.outputEncoding,
                            map: !!r.map,
                            mapEncoding: f(r.map),
                            matcap: !!r.matcap,
                            matcapEncoding: f(r.matcap),
                            envMap: !!b,
                            envMapMode: b && b.mapping,
                            envMapEncoding: f(b),
                            envMapCubeUV: !!b && (b.mapping === Ct || b.mapping === Ot),
                            lightMap: !!r.lightMap,
                            lightMapEncoding: f(r.lightMap),
                            aoMap: !!r.aoMap,
                            emissiveMap: !!r.emissiveMap,
                            emissiveMapEncoding: f(r.emissiveMap),
                            bumpMap: !!r.bumpMap,
                            normalMap: !!r.normalMap,
                            objectSpaceNormalMap: r.normalMapType === wn,
                            tangentSpaceNormalMap: r.normalMapType === _n,
                            clearcoatMap: !!r.clearcoatMap,
                            clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
                            clearcoatNormalMap: !!r.clearcoatNormalMap,
                            displacementMap: !!r.displacementMap,
                            roughnessMap: !!r.roughnessMap,
                            metalnessMap: !!r.metalnessMap,
                            specularMap: !!r.specularMap,
                            alphaMap: !!r.alphaMap,
                            gradientMap: !!r.gradientMap,
                            sheen: !!r.sheen,
                            transmissionMap: !!r.transmissionMap,
                            combine: r.combine,
                            vertexTangents: r.normalMap && r.vertexTangents,
                            vertexColors: r.vertexColors,
                            vertexUvs: !!r.map || !!r.bumpMap || !!r.normalMap || !!r.specularMap || !!r.alphaMap || !!r.emissiveMap || !!r.roughnessMap || !!r.metalnessMap || !!r.clearcoatMap || !!r.clearcoatRoughnessMap || !!r.clearcoatNormalMap || !!r.displacementMap || !!r.transmissionMap,
                            uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmissionMap) && !!r.displacementMap,
                            fog: !!y,
                            useFog: r.fog,
                            fogExp2: y && y.isFogExp2,
                            flatShading: r.flatShading,
                            sizeAttenuation: r.sizeAttenuation,
                            logarithmicDepthBuffer: l,
                            skinning: r.skinning && w > 0,
                            maxBones: w,
                            useVertexTexture: c,
                            morphTargets: r.morphTargets,
                            morphNormals: r.morphNormals,
                            maxMorphTargets: t.maxMorphTargets,
                            maxMorphNormals: t.maxMorphNormals,
                            numDirLights: o.directional.length,
                            numPointLights: o.point.length,
                            numSpotLights: o.spot.length,
                            numRectAreaLights: o.rectArea.length,
                            numHemiLights: o.hemi.length,
                            numDirLightShadows: o.directionalShadowMap.length,
                            numPointLightShadows: o.pointShadowMap.length,
                            numSpotLightShadows: o.spotShadowMap.length,
                            numClippingPlanes: s.numPlanes,
                            numClipIntersection: s.numIntersection,
                            dithering: r.dithering,
                            shadowMapEnabled: t.shadowMap.enabled && m.length > 0,
                            shadowMapType: t.shadowMap.type,
                            toneMapping: r.toneMapped ? t.toneMapping : _t,
                            physicallyCorrectLights: t.physicallyCorrectLights,
                            premultipliedAlpha: r.premultipliedAlpha,
                            alphaTest: r.alphaTest,
                            doubleSided: r.side === H,
                            flipSided: r.side === B,
                            depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                            index0AttributeName: r.index0AttributeName,
                            extensionDerivatives: r.extensions && r.extensions.derivatives,
                            extensionFragDepth: r.extensions && r.extensions.fragDepth,
                            extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                            extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: a || n.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: a || n.has("EXT_shader_texture_lod"),
                            customProgramCacheKey: r.customProgramCacheKey()
                        }
                    },
                    getProgramCacheKey: function(e) {
                        const n = [];
                        if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                            for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                        if (!1 === e.isRawShaderMaterial) {
                            for (let t = 0; t < m.length; t++) n.push(e[m[t]]);
                            n.push(t.outputEncoding), n.push(t.gammaFactor)
                        }
                        return n.push(e.customProgramCacheKey), n.join()
                    },
                    getUniforms: function(t) {
                        const e = p[t.type];
                        let n;
                        if (e) {
                            const t = Ss[e];
                            n = rs.clone(t.uniforms)
                        } else n = t.uniforms;
                        return n
                    },
                    acquireProgram: function(e, n) {
                        let i;
                        for (let t = 0, r = o.length; t < r; t++) {
                            const e = o[t];
                            if (e.cacheKey === n) {
                                i = e, ++i.usedTimes;
                                break
                            }
                        }
                        return void 0 === i && (i = new na(t, n, e, r), o.push(i)), i
                    },
                    releaseProgram: function(t) {
                        if (0 === --t.usedTimes) {
                            const e = o.indexOf(t);
                            o[e] = o[o.length - 1], o.pop(), t.destroy()
                        }
                    },
                    programs: o
                }
            }

            function ra() {
                let t = new WeakMap;
                return {
                    get: function(e) {
                        let n = t.get(e);
                        return void 0 === n && (n = {}, t.set(e, n)), n
                    },
                    remove: function(e) {
                        t.delete(e)
                    },
                    update: function(e, n, i) {
                        t.get(e)[n] = i
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }

            function sa(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
            }

            function oa(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
            }

            function aa(t) {
                const e = [];
                let n = 0;
                const i = [],
                    r = [],
                    s = {
                        id: -1
                    };

                function o(i, r, o, a, l, c) {
                    let h = e[n];
                    const u = t.get(o);
                    return void 0 === h ? (h = {
                        id: i.id,
                        object: i,
                        geometry: r,
                        material: o,
                        program: u.program || s,
                        groupOrder: a,
                        renderOrder: i.renderOrder,
                        z: l,
                        group: c
                    }, e[n] = h) : (h.id = i.id, h.object = i, h.geometry = r, h.material = o, h.program = u.program || s, h.groupOrder = a, h.renderOrder = i.renderOrder, h.z = l, h.group = c), n++, h
                }
                return {
                    opaque: i,
                    transparent: r,
                    init: function() {
                        n = 0, i.length = 0, r.length = 0
                    },
                    push: function(t, e, n, s, a, l) {
                        const c = o(t, e, n, s, a, l);
                        (!0 === n.transparent ? r : i).push(c)
                    },
                    unshift: function(t, e, n, s, a, l) {
                        const c = o(t, e, n, s, a, l);
                        (!0 === n.transparent ? r : i).unshift(c)
                    },
                    finish: function() {
                        for (let t = n, i = e.length; t < i; t++) {
                            const n = e[t];
                            if (null === n.id) break;
                            n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                        }
                    },
                    sort: function(t, e) {
                        i.length > 1 && i.sort(t || sa), r.length > 1 && r.sort(e || oa)
                    }
                }
            }

            function la(t) {
                let e = new WeakMap;
                return {
                    get: function(n, i) {
                        const r = e.get(n);
                        let s;
                        return void 0 === r ? (s = new aa(t), e.set(n, new WeakMap), e.get(n).set(i, s)) : (s = r.get(i), void 0 === s && (s = new aa(t), r.set(i, s))), s
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function ca() {
                const t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        let n;
                        switch (e.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new Hn,
                                    color: new lr
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new Hn,
                                    direction: new Hn,
                                    color: new lr,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new Hn,
                                    color: new lr,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new Hn,
                                    skyColor: new lr,
                                    groundColor: new lr
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new lr,
                                    position: new Hn,
                                    halfWidth: new Hn,
                                    halfHeight: new Hn
                                }
                        }
                        return t[e.id] = n, n
                    }
                }
            }
            let ha = 0;

            function ua(t, e) {
                return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
            }

            function da() {
                const t = new ca,
                    e = function() {
                        const t = {};
                        return {
                            get: function(e) {
                                if (void 0 !== t[e.id]) return t[e.id];
                                let n;
                                switch (e.type) {
                                    case "DirectionalLight":
                                    case "SpotLight":
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Cn
                                        };
                                        break;
                                    case "PointLight":
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Cn,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        }
                                }
                                return t[e.id] = n, n
                            }
                        }
                    }(),
                    n = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    };
                for (let o = 0; o < 9; o++) n.probe.push(new Hn);
                const i = new Hn,
                    r = new fi,
                    s = new fi;
                return {
                    setup: function(o, a, l) {
                        let c = 0,
                            h = 0,
                            u = 0;
                        for (let t = 0; t < 9; t++) n.probe[t].set(0, 0, 0);
                        let d = 0,
                            p = 0,
                            m = 0,
                            f = 0,
                            g = 0,
                            v = 0,
                            y = 0,
                            x = 0;
                        const b = l.matrixWorldInverse;
                        o.sort(ua);
                        for (let w = 0, M = o.length; w < M; w++) {
                            const a = o[w],
                                l = a.color,
                                _ = a.intensity,
                                M = a.distance,
                                S = a.shadow && a.shadow.map ? a.shadow.map.texture : null;
                            if (a.isAmbientLight) c += l.r * _, h += l.g * _, u += l.b * _;
                            else if (a.isLightProbe)
                                for (let t = 0; t < 9; t++) n.probe[t].addScaledVector(a.sh.coefficients[t], _);
                            else if (a.isDirectionalLight) {
                                const r = t.get(a);
                                if (r.color.copy(a.color).multiplyScalar(a.intensity), r.direction.setFromMatrixPosition(a.matrixWorld), i.setFromMatrixPosition(a.target.matrixWorld), r.direction.sub(i), r.direction.transformDirection(b), a.castShadow) {
                                    const t = a.shadow,
                                        i = e.get(a);
                                    i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, n.directionalShadow[d] = i, n.directionalShadowMap[d] = S, n.directionalShadowMatrix[d] = a.shadow.matrix, v++
                                }
                                n.directional[d] = r, d++
                            } else if (a.isSpotLight) {
                                const r = t.get(a);
                                if (r.position.setFromMatrixPosition(a.matrixWorld), r.position.applyMatrix4(b), r.color.copy(l).multiplyScalar(_), r.distance = M, r.direction.setFromMatrixPosition(a.matrixWorld), i.setFromMatrixPosition(a.target.matrixWorld), r.direction.sub(i), r.direction.transformDirection(b), r.coneCos = Math.cos(a.angle), r.penumbraCos = Math.cos(a.angle * (1 - a.penumbra)), r.decay = a.decay, a.castShadow) {
                                    const t = a.shadow,
                                        i = e.get(a);
                                    i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, n.spotShadow[m] = i, n.spotShadowMap[m] = S, n.spotShadowMatrix[m] = a.shadow.matrix, x++
                                }
                                n.spot[m] = r, m++
                            } else if (a.isRectAreaLight) {
                                const e = t.get(a);
                                e.color.copy(l).multiplyScalar(_), e.position.setFromMatrixPosition(a.matrixWorld), e.position.applyMatrix4(b), s.identity(), r.copy(a.matrixWorld), r.premultiply(b), s.extractRotation(r), e.halfWidth.set(.5 * a.width, 0, 0), e.halfHeight.set(0, .5 * a.height, 0), e.halfWidth.applyMatrix4(s), e.halfHeight.applyMatrix4(s), n.rectArea[f] = e, f++
                            } else if (a.isPointLight) {
                                const i = t.get(a);
                                if (i.position.setFromMatrixPosition(a.matrixWorld), i.position.applyMatrix4(b), i.color.copy(a.color).multiplyScalar(a.intensity), i.distance = a.distance, i.decay = a.decay, a.castShadow) {
                                    const t = a.shadow,
                                        i = e.get(a);
                                    i.shadowBias = t.bias, i.shadowNormalBias = t.normalBias, i.shadowRadius = t.radius, i.shadowMapSize = t.mapSize, i.shadowCameraNear = t.camera.near, i.shadowCameraFar = t.camera.far, n.pointShadow[p] = i, n.pointShadowMap[p] = S, n.pointShadowMatrix[p] = a.shadow.matrix, y++
                                }
                                n.point[p] = i, p++
                            } else if (a.isHemisphereLight) {
                                const e = t.get(a);
                                e.direction.setFromMatrixPosition(a.matrixWorld), e.direction.transformDirection(b), e.direction.normalize(), e.skyColor.copy(a.color).multiplyScalar(_), e.groundColor.copy(a.groundColor).multiplyScalar(_), n.hemi[g] = e, g++
                            }
                        }
                        f > 0 && (n.rectAreaLTC1 = Ms.LTC_1, n.rectAreaLTC2 = Ms.LTC_2), n.ambient[0] = c, n.ambient[1] = h, n.ambient[2] = u;
                        const _ = n.hash;
                        _.directionalLength === d && _.pointLength === p && _.spotLength === m && _.rectAreaLength === f && _.hemiLength === g && _.numDirectionalShadows === v && _.numPointShadows === y && _.numSpotShadows === x || (n.directional.length = d, n.spot.length = m, n.rectArea.length = f, n.point.length = p, n.hemi.length = g, n.directionalShadow.length = v, n.directionalShadowMap.length = v, n.pointShadow.length = y, n.pointShadowMap.length = y, n.spotShadow.length = x, n.spotShadowMap.length = x, n.directionalShadowMatrix.length = v, n.pointShadowMatrix.length = y, n.spotShadowMatrix.length = x, _.directionalLength = d, _.pointLength = p, _.spotLength = m, _.rectAreaLength = f, _.hemiLength = g, _.numDirectionalShadows = v, _.numPointShadows = y, _.numSpotShadows = x, n.version = ha++)
                    },
                    state: n
                }
            }

            function pa() {
                const t = new da,
                    e = [],
                    n = [];
                return {
                    init: function() {
                        e.length = 0, n.length = 0
                    },
                    state: {
                        lightsArray: e,
                        shadowsArray: n,
                        lights: t
                    },
                    setupLights: function(i) {
                        t.setup(e, n, i)
                    },
                    pushLight: function(t) {
                        e.push(t)
                    },
                    pushShadow: function(t) {
                        n.push(t)
                    }
                }
            }

            function ma() {
                let t = new WeakMap;
                return {
                    get: function(e, n) {
                        let i;
                        return !1 === t.has(e) ? (i = new pa, t.set(e, new WeakMap), t.get(e).set(n, i)) : !1 === t.get(e).has(n) ? (i = new pa, t.get(e).set(n, i)) : i = t.get(e).get(n), i
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }

            function fa(t) {
                ur.call(this), this.type = "MeshDepthMaterial", this.depthPacking = xn, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
            }

            function ga(t) {
                ur.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Hn, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
            }
            fa.prototype = Object.create(ur.prototype), fa.prototype.constructor = fa, fa.prototype.isMeshDepthMaterial = !0, fa.prototype.copy = function(t) {
                return ur.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }, ga.prototype = Object.create(ur.prototype), ga.prototype.constructor = ga, ga.prototype.isMeshDistanceMaterial = !0, ga.prototype.copy = function(t) {
                return ur.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            };
            var va = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
                ya = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

            function xa(t, e, n) {
                let i = new ys;
                const r = new Cn,
                    s = new Cn,
                    o = new Un,
                    a = [],
                    l = [],
                    c = {},
                    h = {
                        0: B,
                        1: k,
                        2: H
                    },
                    u = new as({
                        defines: {
                            SAMPLE_RATE: .25,
                            HALF_SAMPLE_RATE: 1 / 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new Cn
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: ya,
                        fragmentShader: va
                    }),
                    d = u.clone();
                d.defines.HORIZONAL_PASS = 1;
                const p = new Nr;
                p.setAttribute("position", new fr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                const m = new $r(p, u),
                    f = this;

                function g(n, i) {
                    const r = e.update(m);
                    u.uniforms.shadow_pass.value = n.map.texture, u.uniforms.resolution.value = n.mapSize, u.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, u, m, null), d.uniforms.shadow_pass.value = n.mapPass.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, d, m, null)
                }

                function v(t, e, n) {
                    const i = t << 0 | e << 1 | n << 2;
                    let r = a[i];
                    return void 0 === r && (r = new fa({
                        depthPacking: bn,
                        morphTargets: t,
                        skinning: e
                    }), a[i] = r), r
                }

                function y(t, e, n) {
                    const i = t << 0 | e << 1 | n << 2;
                    let r = l[i];
                    return void 0 === r && (r = new ga({
                        morphTargets: t,
                        skinning: e
                    }), l[i] = r), r
                }

                function x(e, n, i, r, s, o, a) {
                    let l = null,
                        u = v,
                        d = e.customDepthMaterial;
                    if (!0 === r.isPointLight && (u = y, d = e.customDistanceMaterial), void 0 === d) {
                        let t = !1;
                        !0 === i.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                        let r = !1;
                        !0 === e.isSkinnedMesh && (!0 === i.skinning ? r = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e)), l = u(t, r, !0 === e.isInstancedMesh)
                    } else l = d;
                    if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                        const t = l.uuid,
                            e = i.uuid;
                        let n = c[t];
                        void 0 === n && (n = {}, c[t] = n);
                        let r = n[e];
                        void 0 === r && (r = l.clone(), n[e] = r), l = r
                    }
                    return l.visible = i.visible, l.wireframe = i.wireframe, l.side = a === z ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : h[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld), l.nearDistance = s, l.farDistance = o), l
                }

                function b(n, r, s, o, a) {
                    if (!1 === n.visible) return;
                    if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === z) && (!n.frustumCulled || i.intersectsObject(n))) {
                        n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                        const i = e.update(n),
                            r = n.material;
                        if (Array.isArray(r)) {
                            const e = i.groups;
                            for (let l = 0, c = e.length; l < c; l++) {
                                const c = e[l],
                                    h = r[c.materialIndex];
                                if (h && h.visible) {
                                    const e = x(n, i, h, o, s.near, s.far, a);
                                    t.renderBufferDirect(s, null, i, e, n, c)
                                }
                            }
                        } else if (r.visible) {
                            const e = x(n, i, r, o, s.near, s.far, a);
                            t.renderBufferDirect(s, null, i, e, n, null)
                        }
                    }
                    const l = n.children;
                    for (let t = 0, e = l.length; t < e; t++) b(l[t], r, s, o, a)
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = F, this.render = function(e, a, l) {
                    if (!1 === f.enabled) return;
                    if (!1 === f.autoUpdate && !1 === f.needsUpdate) return;
                    if (0 === e.length) return;
                    const c = t.getRenderTarget(),
                        h = t.getActiveCubeFace(),
                        u = t.getActiveMipmapLevel(),
                        d = t.state;
                    d.setBlending(G), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                    for (let p = 0, m = e.length; p < m; p++) {
                        const c = e[p],
                            h = c.shadow;
                        if (void 0 === h) {
                            console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                            continue
                        }
                        if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
                        r.copy(h.mapSize);
                        const u = h.getFrameExtents();
                        if (r.multiply(u), s.copy(h.mapSize), (r.x > n || r.y > n) && (r.x > n && (s.x = Math.floor(n / u.x), r.x = s.x * u.x, h.mapSize.x = s.x), r.y > n && (s.y = Math.floor(n / u.y), r.y = s.y * u.y, h.mapSize.y = s.y)), null === h.map && !h.isPointLightShadow && this.type === z) {
                            const t = {
                                minFilter: kt,
                                magFilter: kt,
                                format: ne
                            };
                            h.map = new zn(r.x, r.y, t), h.map.texture.name = c.name + ".shadowMap", h.mapPass = new zn(r.x, r.y, t), h.camera.updateProjectionMatrix()
                        }
                        if (null === h.map) {
                            const t = {
                                minFilter: Ft,
                                magFilter: Ft,
                                format: ne
                            };
                            h.map = new zn(r.x, r.y, t), h.map.texture.name = c.name + ".shadowMap", h.camera.updateProjectionMatrix()
                        }
                        t.setRenderTarget(h.map), t.clear();
                        const m = h.getViewportCount();
                        for (let t = 0; t < m; t++) {
                            const e = h.getViewport(t);
                            o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(o), h.updateMatrices(c, t), i = h.getFrustum(), b(a, l, h.camera, c, this.type)
                        }
                        h.isPointLightShadow || this.type !== z || g(h, l), h.needsUpdate = !1
                    }
                    f.needsUpdate = !1, t.setRenderTarget(c, h, u)
                }
            }

            function ba(t, e, n) {
                const i = n.isWebGL2;
                const r = new function() {
                        let e = !1;
                        const n = new Un;
                        let i = null;
                        const r = new Un(0, 0, 0, 0);
                        return {
                            setMask: function(n) {
                                i === n || e || (t.colorMask(n, n, n, n), i = n)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e, i, s, o, a) {
                                !0 === a && (e *= o, i *= o, s *= o), n.set(e, i, s, o), !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n))
                            },
                            reset: function() {
                                e = !1, i = null, r.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    s = new function() {
                        let e = !1,
                            n = null,
                            i = null,
                            r = null;
                        return {
                            setTest: function(t) {
                                t ? F(2929) : U(2929)
                            },
                            setMask: function(i) {
                                n === i || e || (t.depthMask(i), n = i)
                            },
                            setFunc: function(e) {
                                if (i !== e) {
                                    if (e) switch (e) {
                                        case ht:
                                            t.depthFunc(512);
                                            break;
                                        case ut:
                                            t.depthFunc(519);
                                            break;
                                        case dt:
                                            t.depthFunc(513);
                                            break;
                                        case pt:
                                            t.depthFunc(515);
                                            break;
                                        case mt:
                                            t.depthFunc(514);
                                            break;
                                        case ft:
                                            t.depthFunc(518);
                                            break;
                                        case gt:
                                            t.depthFunc(516);
                                            break;
                                        case vt:
                                            t.depthFunc(517);
                                            break;
                                        default:
                                            t.depthFunc(515)
                                    } else t.depthFunc(515);
                                    i = e
                                }
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                r !== e && (t.clearDepth(e), r = e)
                            },
                            reset: function() {
                                e = !1, n = null, i = null, r = null
                            }
                        }
                    },
                    o = new function() {
                        let e = !1,
                            n = null,
                            i = null,
                            r = null,
                            s = null,
                            o = null,
                            a = null,
                            l = null,
                            c = null;
                        return {
                            setTest: function(t) {
                                e || (t ? F(2960) : U(2960))
                            },
                            setMask: function(i) {
                                n === i || e || (t.stencilMask(i), n = i)
                            },
                            setFunc: function(e, n, o) {
                                i === e && r === n && s === o || (t.stencilFunc(e, n, o), i = e, r = n, s = o)
                            },
                            setOp: function(e, n, i) {
                                o === e && a === n && l === i || (t.stencilOp(e, n, i), o = e, a = n, l = i)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                c !== e && (t.clearStencil(e), c = e)
                            },
                            reset: function() {
                                e = !1, n = null, i = null, r = null, s = null, o = null, a = null, l = null, c = null
                            }
                        }
                    };
                let a = {},
                    l = null,
                    c = null,
                    h = null,
                    u = null,
                    d = null,
                    p = null,
                    m = null,
                    f = null,
                    g = null,
                    v = !1,
                    y = null,
                    x = null,
                    b = null,
                    _ = null,
                    w = null;
                const M = t.getParameter(35661);
                let S = !1,
                    T = 0;
                const E = t.getParameter(7938); - 1 !== E.indexOf("WebGL") ? (T = parseFloat(/^WebGL\ ([0-9])/.exec(E)[1]), S = T >= 1) : -1 !== E.indexOf("OpenGL ES") && (T = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(E)[1]), S = T >= 2);
                let A = null,
                    L = {};
                const R = new Un,
                    P = new Un;

                function C(e, n, i) {
                    const r = new Uint8Array(4),
                        s = t.createTexture();
                    t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                    for (let o = 0; o < i; o++) t.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, r);
                    return s
                }
                const O = {};

                function F(e) {
                    !0 !== a[e] && (t.enable(e), a[e] = !0)
                }

                function U(e) {
                    !1 !== a[e] && (t.disable(e), a[e] = !1)
                }
                O[3553] = C(3553, 3553, 1), O[34067] = C(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), F(2929), s.setFunc(pt), xt(!1), bt(N), F(2884), yt(G);
                const z = {
                    [Y]: 32774,
                    [J]: 32778,
                    [Z]: 32779
                };
                if (i) z[K] = 32775, z[$] = 32776;
                else {
                    const t = e.get("EXT_blend_minmax");
                    null !== t && (z[K] = t.MIN_EXT, z[$] = t.MAX_EXT)
                }
                const k = {
                    [Q]: 0,
                    [tt]: 1,
                    [et]: 768,
                    [it]: 770,
                    [ct]: 776,
                    [at]: 774,
                    [st]: 772,
                    [nt]: 769,
                    [rt]: 771,
                    [lt]: 775,
                    [ot]: 773
                };

                function yt(e, n, i, r, s, o, a, l) {
                    if (e !== G) {
                        if (c || (F(3042), c = !0), e === X) s = s || n, o = o || i, a = a || r, n === u && s === m || (t.blendEquationSeparate(z[n], z[s]), u = n, m = s), i === d && r === p && o === f && a === g || (t.blendFuncSeparate(k[i], k[r], k[o], k[a]), d = i, p = r, f = o, g = a), h = e, v = null;
                        else if (e !== h || l !== v) {
                            if (u === Y && m === Y || (t.blendEquation(32774), u = Y, m = Y), l) switch (e) {
                                case V:
                                    t.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case j:
                                    t.blendFunc(1, 1);
                                    break;
                                case W:
                                    t.blendFuncSeparate(0, 0, 769, 771);
                                    break;
                                case q:
                                    t.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            } else switch (e) {
                                case V:
                                    t.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case j:
                                    t.blendFunc(770, 1);
                                    break;
                                case W:
                                    t.blendFunc(0, 769);
                                    break;
                                case q:
                                    t.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                            d = null, p = null, f = null, g = null, h = e, v = l
                        }
                    } else c && (U(3042), c = !1)
                }

                function xt(e) {
                    y !== e && (e ? t.frontFace(2304) : t.frontFace(2305), y = e)
                }

                function bt(e) {
                    e !== I ? (F(2884), e !== x && (e === N ? t.cullFace(1029) : e === D ? t.cullFace(1028) : t.cullFace(1032))) : U(2884), x = e
                }

                function _t(e, n, i) {
                    e ? (F(32823), _ === n && w === i || (t.polygonOffset(n, i), _ = n, w = i)) : U(32823)
                }

                function wt(e) {
                    void 0 === e && (e = 33984 + M - 1), A !== e && (t.activeTexture(e), A = e)
                }
                return {
                    buffers: {
                        color: r,
                        depth: s,
                        stencil: o
                    },
                    enable: F,
                    disable: U,
                    useProgram: function(e) {
                        return l !== e && (t.useProgram(e), l = e, !0)
                    },
                    setBlending: yt,
                    setMaterial: function(t, e) {
                        t.side === H ? U(2884) : F(2884);
                        let n = t.side === B;
                        e && (n = !n), xt(n), t.blending === V && !1 === t.transparent ? yt(G) : yt(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), r.setMask(t.colorWrite);
                        const i = t.stencilWrite;
                        o.setTest(i), i && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), _t(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                    },
                    setFlipSided: xt,
                    setCullFace: bt,
                    setLineWidth: function(e) {
                        e !== b && (S && t.lineWidth(e), b = e)
                    },
                    setPolygonOffset: _t,
                    setScissorTest: function(t) {
                        t ? F(3089) : U(3089)
                    },
                    activeTexture: wt,
                    bindTexture: function(e, n) {
                        null === A && wt();
                        let i = L[A];
                        void 0 === i && (i = {
                            type: void 0,
                            texture: void 0
                        }, L[A] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || O[e]), i.type = e, i.texture = n)
                    },
                    unbindTexture: function() {
                        const e = L[A];
                        void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            t.compressedTexImage2D.apply(t, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage2D: function() {
                        try {
                            t.texImage2D.apply(t, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage3D: function() {
                        try {
                            t.texImage3D.apply(t, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    scissor: function(e) {
                        !1 === R.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), R.copy(e))
                    },
                    viewport: function(e) {
                        !1 === P.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), P.copy(e))
                    },
                    reset: function() {
                        a = {}, A = null, L = {}, l = null, h = null, y = null, x = null, r.reset(), s.reset(), o.reset()
                    }
                }
            }

            function _a(t, e, n, i, r, s, o) {
                const a = r.isWebGL2,
                    l = r.maxTextures,
                    c = r.maxCubemapSize,
                    h = r.maxTextureSize,
                    u = r.maxSamples,
                    d = new WeakMap;
                let p, m = !1;
                try {
                    m = "undefined" !== typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (z) {}

                function f(t, e) {
                    return m ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                }

                function g(t, e, n, i) {
                    let r = 1;
                    if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                        if ("undefined" !== typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && t instanceof ImageBitmap) {
                            const i = e ? Pn.floorPowerOfTwo : Math.floor,
                                s = i(r * t.width),
                                o = i(r * t.height);
                            void 0 === p && (p = f(s, o));
                            const a = n ? f(s, o) : p;
                            return a.width = s, a.height = o, a.getContext("2d").drawImage(t, 0, 0, s, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + o + ")."), a
                        }
                        return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                    }
                    return t
                }

                function v(t) {
                    return Pn.isPowerOfTwo(t.width) && Pn.isPowerOfTwo(t.height)
                }

                function y(t, e) {
                    return t.generateMipmaps && e && t.minFilter !== Ft && t.minFilter !== kt
                }

                function x(e, n, r, s) {
                    t.generateMipmap(e), i.get(n).__maxMipLevel = Math.log(Math.max(r, s)) * Math.LOG2E
                }

                function b(n, i, r) {
                    if (!1 === a) return i;
                    if (null !== n) {
                        if (void 0 !== t[n]) return t[n];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                    }
                    let s = i;
                    return 6403 === i && (5126 === r && (s = 33326), 5131 === r && (s = 33325), 5121 === r && (s = 33321)), 6407 === i && (5126 === r && (s = 34837), 5131 === r && (s = 34843), 5121 === r && (s = 32849)), 6408 === i && (5126 === r && (s = 34836), 5131 === r && (s = 34842), 5121 === r && (s = 32856)), 33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s || e.get("EXT_color_buffer_float"), s
                }

                function _(t) {
                    return t === Ft || t === Ut || t === zt ? 9728 : 9729
                }

                function w(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", w),
                        function(e) {
                            const n = i.get(e);
                            if (void 0 === n.__webglInit) return;
                            t.deleteTexture(n.__webglTexture), i.remove(e)
                        }(n), n.isVideoTexture && d.delete(n), o.memory.textures--
                }

                function M(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", M),
                        function(e) {
                            const n = i.get(e),
                                r = i.get(e.texture);
                            if (!e) return;
                            void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
                            e.depthTexture && e.depthTexture.dispose();
                            if (e.isWebGLCubeRenderTarget)
                                for (let i = 0; i < 6; i++) t.deleteFramebuffer(n.__webglFramebuffer[i]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[i]);
                            else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && t.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                            i.remove(e.texture), i.remove(e)
                        }(n), o.memory.textures--
                }
                let S = 0;

                function T(t, e) {
                    const r = i.get(t);
                    if (t.isVideoTexture && function(t) {
                            const e = o.render.frame;
                            d.get(t) !== e && (d.set(t, e), t.update())
                        }(t), t.version > 0 && r.__version !== t.version) {
                        const n = t.image;
                        if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== n.complete) return void C(r, t, e);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
                }

                function E(e, r) {
                    const o = i.get(e);
                    e.version > 0 && o.__version !== e.version ? function(e, i, r) {
                        if (6 !== i.image.length) return;
                        P(e, i), n.activeTexture(33984 + r), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY);
                        const o = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                            l = i.image[0] && i.image[0].isDataTexture,
                            h = [];
                        for (let t = 0; t < 6; t++) h[t] = o || l ? l ? i.image[t].image : i.image[t] : g(i.image[t], !1, !0, c);
                        const u = h[0],
                            d = v(u) || a,
                            p = s.convert(i.format),
                            m = s.convert(i.type),
                            f = b(i.internalFormat, p, m);
                        let _;
                        if (R(34067, i, d), o) {
                            for (let t = 0; t < 6; t++) {
                                _ = h[t].mipmaps;
                                for (let e = 0; e < _.length; e++) {
                                    const r = _[e];
                                    i.format !== ne && i.format !== ee ? null !== p ? n.compressedTexImage2D(34069 + t, e, f, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, f, r.width, r.height, 0, p, m, r.data)
                                }
                            }
                            e.__maxMipLevel = _.length - 1
                        } else {
                            _ = i.mipmaps;
                            for (let t = 0; t < 6; t++)
                                if (l) {
                                    n.texImage2D(34069 + t, 0, f, h[t].width, h[t].height, 0, p, m, h[t].data);
                                    for (let e = 0; e < _.length; e++) {
                                        const i = _[e].image[t].image;
                                        n.texImage2D(34069 + t, e + 1, f, i.width, i.height, 0, p, m, i.data)
                                    }
                                } else {
                                    n.texImage2D(34069 + t, 0, f, p, m, h[t]);
                                    for (let e = 0; e < _.length; e++) {
                                        const i = _[e];
                                        n.texImage2D(34069 + t, e + 1, f, p, m, i.image[t])
                                    }
                                }
                            e.__maxMipLevel = _.length
                        }
                        y(i, d) && x(34067, i, u.width, u.height);
                        e.__version = i.version, i.onUpdate && i.onUpdate(i)
                    }(o, e, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, o.__webglTexture))
                }
                const A = {
                        [It]: 10497,
                        [Nt]: 33071,
                        [Dt]: 33648
                    },
                    L = {
                        [Ft]: 9728,
                        [Ut]: 9984,
                        [zt]: 9986,
                        [kt]: 9729,
                        [Bt]: 9985,
                        [Ht]: 9987
                    };

                function R(n, s, o) {
                    o ? (t.texParameteri(n, 10242, A[s.wrapS]), t.texParameteri(n, 10243, A[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, A[s.wrapR]), t.texParameteri(n, 10240, L[s.magFilter]), t.texParameteri(n, 10241, L[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), s.wrapS === Nt && s.wrapT === Nt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, _(s.magFilter)), t.texParameteri(n, 10241, _(s.minFilter)), s.minFilter !== Ft && s.minFilter !== kt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
                    const l = e.get("EXT_texture_filter_anisotropic");
                    if (l) {
                        if (s.type === Yt && null === e.get("OES_texture_float_linear")) return;
                        if (s.type === Jt && null === (a || e.get("OES_texture_half_float_linear"))) return;
                        (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, l.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
                    }
                }

                function P(e, n) {
                    void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", w), e.__webglTexture = t.createTexture(), o.memory.textures++)
                }

                function C(e, i, r) {
                    let o = 3553;
                    i.isDataTexture2DArray && (o = 35866), i.isDataTexture3D && (o = 32879), P(e, i), n.activeTexture(33984 + r), n.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment);
                    const l = function(t) {
                            return !a && (t.wrapS !== Nt || t.wrapT !== Nt || t.minFilter !== Ft && t.minFilter !== kt)
                        }(i) && !1 === v(i.image),
                        c = g(i.image, l, !1, h),
                        u = v(c) || a,
                        d = s.convert(i.format);
                    let p, m = s.convert(i.type),
                        f = b(i.internalFormat, d, m);
                    R(o, i, u);
                    const _ = i.mipmaps;
                    if (i.isDepthTexture) f = 6402, a ? f = i.type === Yt ? 36012 : i.type === Xt ? 33190 : i.type === Qt ? 35056 : 33189 : i.type === Yt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === oe && 6402 === f && i.type !== Wt && i.type !== Xt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = Wt, m = s.convert(i.type)), i.format === ae && 6402 === f && (f = 34041, i.type !== Qt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Qt, m = s.convert(i.type))), n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, null);
                    else if (i.isDataTexture)
                        if (_.length > 0 && u) {
                            for (let t = 0, e = _.length; t < e; t++) p = _[t], n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data);
                            i.generateMipmaps = !1, e.__maxMipLevel = _.length - 1
                        } else n.texImage2D(3553, 0, f, c.width, c.height, 0, d, m, c.data), e.__maxMipLevel = 0;
                    else if (i.isCompressedTexture) {
                        for (let t = 0, e = _.length; t < e; t++) p = _[t], i.format !== ne && i.format !== ee ? null !== d ? n.compressedTexImage2D(3553, t, f, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, f, p.width, p.height, 0, d, m, p.data);
                        e.__maxMipLevel = _.length - 1
                    } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, f, c.width, c.height, c.depth, 0, d, m, c.data), e.__maxMipLevel = 0;
                    else if (i.isDataTexture3D) n.texImage3D(32879, 0, f, c.width, c.height, c.depth, 0, d, m, c.data), e.__maxMipLevel = 0;
                    else if (_.length > 0 && u) {
                        for (let t = 0, e = _.length; t < e; t++) p = _[t], n.texImage2D(3553, t, f, d, m, p);
                        i.generateMipmaps = !1, e.__maxMipLevel = _.length - 1
                    } else n.texImage2D(3553, 0, f, d, m, c), e.__maxMipLevel = 0;
                    y(i, u) && x(o, i, c.width, c.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                }

                function O(e, r, o, a) {
                    const l = s.convert(r.texture.format),
                        c = s.convert(r.texture.type),
                        h = b(r.texture.internalFormat, l, c);
                    n.texImage2D(a, 0, h, r.width, r.height, 0, l, c, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, o, a, i.get(r.texture).__webglTexture, 0), t.bindFramebuffer(36160, null)
                }

                function I(e, n, i) {
                    if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                        let r = 33189;
                        if (i) {
                            const e = n.depthTexture;
                            e && e.isDepthTexture && (e.type === Yt ? r = 36012 : e.type === Xt && (r = 33190));
                            const i = D(n);
                            t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                        } else t.renderbufferStorage(36161, r, n.width, n.height);
                        t.framebufferRenderbuffer(36160, 36096, 36161, e)
                    } else if (n.depthBuffer && n.stencilBuffer) {
                        if (i) {
                            const e = D(n);
                            t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                        } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                        t.framebufferRenderbuffer(36160, 33306, 36161, e)
                    } else {
                        const e = s.convert(n.texture.format),
                            r = s.convert(n.texture.type),
                            o = b(n.texture.internalFormat, e, r);
                        if (i) {
                            const e = D(n);
                            t.renderbufferStorageMultisample(36161, e, o, n.width, n.height)
                        } else t.renderbufferStorage(36161, o, n.width, n.height)
                    }
                    t.bindRenderbuffer(36161, null)
                }

                function N(e) {
                    const n = i.get(e),
                        r = !0 === e.isWebGLCubeRenderTarget;
                    if (e.depthTexture) {
                        if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(e, n) {
                            if (n && n.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                            if (t.bindFramebuffer(36160, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), T(n.depthTexture, 0);
                            const r = i.get(n.depthTexture).__webglTexture;
                            if (n.depthTexture.format === oe) t.framebufferTexture2D(36160, 36096, 3553, r, 0);
                            else {
                                if (n.depthTexture.format !== ae) throw new Error("Unknown depthTexture format");
                                t.framebufferTexture2D(36160, 33306, 3553, r, 0)
                            }
                        }(n.__webglFramebuffer, e)
                    } else if (r) {
                        n.__webglDepthbuffer = [];
                        for (let i = 0; i < 6; i++) t.bindFramebuffer(36160, n.__webglFramebuffer[i]), n.__webglDepthbuffer[i] = t.createRenderbuffer(), I(n.__webglDepthbuffer[i], e, !1)
                    } else t.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), I(n.__webglDepthbuffer, e, !1);
                    t.bindFramebuffer(36160, null)
                }

                function D(t) {
                    return a && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0
                }
                let F = !1,
                    U = !1;
                this.allocateTextureUnit = function() {
                    const t = S;
                    return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), S += 1, t
                }, this.resetTextureUnits = function() {
                    S = 0
                }, this.setTexture2D = T, this.setTexture2DArray = function(t, e) {
                    const r = i.get(t);
                    t.version > 0 && r.__version !== t.version ? C(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
                }, this.setTexture3D = function(t, e) {
                    const r = i.get(t);
                    t.version > 0 && r.__version !== t.version ? C(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
                }, this.setTextureCube = E, this.setupRenderTarget = function(e) {
                    const r = i.get(e),
                        l = i.get(e.texture);
                    e.addEventListener("dispose", M), l.__webglTexture = t.createTexture(), o.memory.textures++;
                    const c = !0 === e.isWebGLCubeRenderTarget,
                        h = !0 === e.isWebGLMultisampleRenderTarget,
                        u = v(e) || a;
                    if (!a || e.texture.format !== ee || e.texture.type !== Yt && e.texture.type !== Jt || (e.texture.format = ne, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), c) {
                        r.__webglFramebuffer = [];
                        for (let e = 0; e < 6; e++) r.__webglFramebuffer[e] = t.createFramebuffer()
                    } else if (r.__webglFramebuffer = t.createFramebuffer(), h)
                        if (a) {
                            r.__webglMultisampledFramebuffer = t.createFramebuffer(), r.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, r.__webglColorRenderbuffer);
                            const n = s.convert(e.texture.format),
                                i = s.convert(e.texture.type),
                                o = b(e.texture.internalFormat, n, i),
                                a = D(e);
                            t.renderbufferStorageMultisample(36161, a, o, e.width, e.height), t.bindFramebuffer(36160, r.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, r.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (r.__webglDepthRenderbuffer = t.createRenderbuffer(), I(r.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                    if (c) {
                        n.bindTexture(34067, l.__webglTexture), R(34067, e.texture, u);
                        for (let t = 0; t < 6; t++) O(r.__webglFramebuffer[t], e, 36064, 34069 + t);
                        y(e.texture, u) && x(34067, e.texture, e.width, e.height), n.bindTexture(34067, null)
                    } else n.bindTexture(3553, l.__webglTexture), R(3553, e.texture, u), O(r.__webglFramebuffer, e, 36064, 3553), y(e.texture, u) && x(3553, e.texture, e.width, e.height), n.bindTexture(3553, null);
                    e.depthBuffer && N(e)
                }, this.updateRenderTargetMipmap = function(t) {
                    const e = t.texture;
                    if (y(e, v(t) || a)) {
                        const r = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                            s = i.get(e).__webglTexture;
                        n.bindTexture(r, s), x(r, e, t.width, t.height), n.bindTexture(r, null)
                    }
                }, this.updateMultisampleRenderTarget = function(e) {
                    if (e.isWebGLMultisampleRenderTarget)
                        if (a) {
                            const n = i.get(e);
                            t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, n.__webglFramebuffer);
                            const r = e.width,
                                s = e.height;
                            let o = 16384;
                            e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024), t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, o, 9728), t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                }, this.safeSetTexture2D = function(t, e) {
                    t && t.isWebGLRenderTarget && (!1 === F && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), F = !0), t = t.texture), T(t, e)
                }, this.safeSetTextureCube = function(t, e) {
                    t && t.isWebGLCubeRenderTarget && (!1 === U && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), U = !0), t = t.texture), E(t, e)
                }
            }

            function wa(t, e, n) {
                const i = n.isWebGL2;
                return {
                    convert: function(t) {
                        let n;
                        if (t === Gt) return 5121;
                        if (t === Zt) return 32819;
                        if (t === Kt) return 32820;
                        if (t === $t) return 33635;
                        if (t === Vt) return 5120;
                        if (t === jt) return 5122;
                        if (t === Wt) return 5123;
                        if (t === qt) return 5124;
                        if (t === Xt) return 5125;
                        if (t === Yt) return 5126;
                        if (t === Jt) return i ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
                        if (t === te) return 6406;
                        if (t === ee) return 6407;
                        if (t === ne) return 6408;
                        if (t === ie) return 6409;
                        if (t === re) return 6410;
                        if (t === oe) return 6402;
                        if (t === ae) return 34041;
                        if (t === le) return 6403;
                        if (t === ce) return 36244;
                        if (t === he) return 33319;
                        if (t === ue) return 33320;
                        if (t === de) return 36248;
                        if (t === pe) return 36249;
                        if (t === me || t === fe || t === ge || t === ve) {
                            if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
                            if (t === me) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (t === fe) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (t === ge) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (t === ve) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if (t === ye || t === xe || t === be || t === _e) {
                            if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
                            if (t === ye) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (t === xe) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (t === be) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (t === _e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (t === we) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if ((t === Me || t === Se) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) {
                            if (t === Me) return n.COMPRESSED_RGB8_ETC2;
                            if (t === Se) return n.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        return t === Te || t === Ee || t === Ae || t === Le || t === Re || t === Pe || t === Ce || t === Oe || t === Ie || t === Ne || t === De || t === Fe || t === Ue || t === ze || t === Be || t === He || t === Ge || t === Ve || t === je || t === We || t === qe || t === Xe || t === Ye || t === Je || t === Ze || t === Ke || t === $e || t === Qe ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : t === ke ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : t === Qt ? i ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                    }
                }
            }

            function Ma(t) {
                cs.call(this), this.cameras = t || []
            }

            function Sa() {
                Bi.call(this), this.type = "Group"
            }

            function Ta() {
                this._targetRay = null, this._grip = null, this._hand = null
            }

            function Ea(t, e) {
                const n = this;
                let i = null,
                    r = 1,
                    s = null,
                    o = "local-floor",
                    a = null;
                const l = [],
                    c = new Map,
                    h = new cs;
                h.layers.enable(1), h.viewport = new Un;
                const u = new cs;
                u.layers.enable(2), u.viewport = new Un;
                const d = [h, u],
                    p = new Ma;
                p.layers.enable(1), p.layers.enable(2);
                let m = null,
                    f = null;

                function g(t) {
                    const e = c.get(t.inputSource);
                    e && e.dispatchEvent({
                        type: t.type,
                        data: t.inputSource
                    })
                }

                function v() {
                    c.forEach((function(t, e) {
                        t.disconnect(e)
                    })), c.clear(), t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), S.stop(), n.isPresenting = !1, n.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function y(t) {
                    s = t, S.setContext(i), S.start(), n.isPresenting = !0, n.dispatchEvent({
                        type: "sessionstart"
                    })
                }

                function x(t) {
                    const e = i.inputSources;
                    for (let n = 0; n < l.length; n++) c.set(e[n], l[n]);
                    for (let n = 0; n < t.removed.length; n++) {
                        const e = t.removed[n],
                            i = c.get(e);
                        i && (i.dispatchEvent({
                            type: "disconnected",
                            data: e
                        }), c.delete(e))
                    }
                    for (let n = 0; n < t.added.length; n++) {
                        const e = t.added[n],
                            i = c.get(e);
                        i && i.dispatchEvent({
                            type: "connected",
                            data: e
                        })
                    }
                }
                this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                    let e = l[t];
                    return void 0 === e && (e = new Ta, l[t] = e), e.getTargetRaySpace()
                }, this.getControllerGrip = function(t) {
                    let e = l[t];
                    return void 0 === e && (e = new Ta, l[t] = e), e.getGripSpace()
                }, this.getHand = function(t) {
                    let e = l[t];
                    return void 0 === e && (e = new Ta, l[t] = e), e.getHandSpace()
                }, this.setFramebufferScaleFactor = function(t) {
                    r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }, this.setReferenceSpaceType = function(t) {
                    o = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }, this.getReferenceSpace = function() {
                    return s
                }, this.getSession = function() {
                    return i
                }, this.setSession = function(t) {
                    if (i = t, null !== i) {
                        i.addEventListener("select", g), i.addEventListener("selectstart", g), i.addEventListener("selectend", g), i.addEventListener("squeeze", g), i.addEventListener("squeezestart", g), i.addEventListener("squeezeend", g), i.addEventListener("end", v);
                        const t = e.getContextAttributes();
                        !0 !== t.xrCompatible && e.makeXRCompatible();
                        const n = {
                                antialias: t.antialias,
                                alpha: t.alpha,
                                depth: t.depth,
                                stencil: t.stencil,
                                framebufferScaleFactor: r
                            },
                            s = new XRWebGLLayer(i, e, n);
                        i.updateRenderState({
                            baseLayer: s
                        }), i.requestReferenceSpace(o).then(y), i.addEventListener("inputsourceschange", x)
                    }
                };
                const b = new Hn,
                    _ = new Hn;

                function w(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
                }
                this.getCamera = function(t) {
                    p.near = u.near = h.near = t.near, p.far = u.far = h.far = t.far, m === p.near && f === p.far || (i.updateRenderState({
                        depthNear: p.near,
                        depthFar: p.far
                    }), m = p.near, f = p.far);
                    const e = t.parent,
                        n = p.cameras;
                    w(p, e);
                    for (let i = 0; i < n.length; i++) w(n[i], e);
                    t.matrixWorld.copy(p.matrixWorld);
                    const r = t.children;
                    for (let i = 0, s = r.length; i < s; i++) r[i].updateMatrixWorld(!0);
                    return 2 === n.length ? function(t, e, n) {
                        b.setFromMatrixPosition(e.matrixWorld), _.setFromMatrixPosition(n.matrixWorld);
                        const i = b.distanceTo(_),
                            r = e.projectionMatrix.elements,
                            s = n.projectionMatrix.elements,
                            o = r[14] / (r[10] - 1),
                            a = r[14] / (r[10] + 1),
                            l = (r[9] + 1) / r[5],
                            c = (r[9] - 1) / r[5],
                            h = (r[8] - 1) / r[0],
                            u = (s[8] + 1) / s[0],
                            d = o * h,
                            p = o * u,
                            m = i / (-h + u),
                            f = m * -h;
                        e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(f), t.translateZ(m), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
                        const g = o + m,
                            v = a + m,
                            y = d - f,
                            x = p + (i - f),
                            w = l * a / v * g,
                            M = c * a / v * g;
                        t.projectionMatrix.makePerspective(y, x, w, M, g, v)
                    }(p, h, u) : p.projectionMatrix.copy(h.projectionMatrix), p
                };
                let M = null;
                const S = new xs;
                S.setAnimationLoop((function(e, n) {
                    if (a = n.getViewerPose(s), null !== a) {
                        const e = a.views,
                            n = i.renderState.baseLayer;
                        t.setFramebuffer(n.framebuffer);
                        let r = !1;
                        e.length !== p.cameras.length && (p.cameras.length = 0, r = !0);
                        for (let t = 0; t < e.length; t++) {
                            const i = e[t],
                                s = n.getViewport(i),
                                o = d[t];
                            o.matrix.fromArray(i.transform.matrix), o.projectionMatrix.fromArray(i.projectionMatrix), o.viewport.set(s.x, s.y, s.width, s.height), 0 === t && p.matrix.copy(o.matrix), !0 === r && p.cameras.push(o)
                        }
                    }
                    const r = i.inputSources;
                    for (let t = 0; t < l.length; t++) {
                        const e = l[t],
                            i = r[t];
                        e.update(i, n, s)
                    }
                    M && M(e, n)
                })), this.setAnimationLoop = function(t) {
                    M = t
                }, this.dispose = function() {}
            }

            function Aa(t) {
                function e(e, n) {
                    e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap);
                    const i = t.get(n).envMap;
                    if (i) {
                        e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio;
                        const r = t.get(i).__maxMipLevel;
                        void 0 !== r && (e.maxMipLevel.value = r)
                    }
                    let r, s;
                    n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix))
                }

                function n(e, n) {
                    e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, n.side === B && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), n.side === B && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
                }
                return {
                    refreshFogUniforms: function(t, e) {
                        t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                    },
                    refreshMaterialUniforms: function(t, i, r, s) {
                        i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function(t, e) {
                            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                        }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function(t, e) {
                            e.gradientMap && (t.gradientMap.value = e.gradientMap);
                            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === B && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === B && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function(t, e) {
                            t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === B && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === B && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, i)) : i.isMeshStandardMaterial ? (e(t, i), i.isMeshPhysicalMaterial ? function(t, e) {
                            n(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
                            e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                            e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                            e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === B && t.clearcoatNormalScale.value.negate());
                            t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
                        }(t, i) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i), function(t, e) {
                            e.matcap && (t.matcap.value = e.matcap);
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === B && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === B && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function(t, e) {
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function(t, e) {
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                            t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                        }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function(t, e) {
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === B && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === B && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, i)) : i.isLineBasicMaterial ? (function(t, e) {
                            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                        }(t, i), i.isLineDashedMaterial && function(t, e) {
                            t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                        }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map);
                            e.alphaMap && (t.alphaMap.value = e.alphaMap);
                            let r;
                            e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
                            void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                        }(t, i, r, s) : i.isSpriteMaterial ? function(t, e) {
                            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                            e.alphaMap && (t.alphaMap.value = e.alphaMap);
                            let n;
                            e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                            void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                        }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                    }
                }
            }

            function La(t) {
                const e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    n = void 0 !== t.context ? t.context : null,
                    i = void 0 !== t.alpha && t.alpha,
                    r = void 0 === t.depth || t.depth,
                    s = void 0 === t.stencil || t.stencil,
                    o = void 0 !== t.antialias && t.antialias,
                    a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                    l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                    c = void 0 !== t.powerPreference ? t.powerPreference : "default",
                    h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
                let u = null,
                    d = null;
                this.domElement = e, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = un, this.physicallyCorrectLights = !1, this.toneMapping = _t, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                const p = this;
                let m = !1,
                    f = null,
                    g = 0,
                    v = 0,
                    y = null,
                    x = null,
                    b = -1,
                    _ = null,
                    w = null;
                const M = new Un,
                    S = new Un;
                let T = null,
                    E = e.width,
                    A = e.height,
                    L = 1,
                    R = null,
                    P = null;
                const C = new Un(0, 0, E, A),
                    O = new Un(0, 0, E, A);
                let I = !1;
                const N = new ys;
                let D = !1,
                    F = !1;
                const U = new fi,
                    z = new Hn,
                    k = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function B() {
                    return null === y ? L : 1
                }
                let H, G, V, j, W, q, X, Y, J, Z, K, $, Q, tt, et, nt, it, rt, st, ot, at, lt = n;

                function ct(t, n) {
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i],
                            s = e.getContext(r, n);
                        if (null !== s) return s
                    }
                    return null
                }
                try {
                    const t = {
                        alpha: i,
                        depth: r,
                        stencil: s,
                        antialias: o,
                        premultipliedAlpha: a,
                        preserveDrawingBuffer: l,
                        powerPreference: c,
                        failIfMajorPerformanceCaveat: h
                    };
                    if (e.addEventListener("webglcontextlost", pt, !1), e.addEventListener("webglcontextrestored", mt, !1), null === lt) {
                        const e = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === p.isWebGL1Renderer && e.shift(), lt = ct(e, t), null === lt) throw ct(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    void 0 === lt.getShaderPrecisionFormat && (lt.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (Tt) {
                    throw console.error("THREE.WebGLRenderer: " + Tt.message), Tt
                }

                function ht() {
                    H = new Cs(lt), G = new Ls(lt, H, t), !1 === G.isWebGL2 && (H.get("WEBGL_depth_texture"), H.get("OES_texture_float"), H.get("OES_texture_half_float"), H.get("OES_texture_half_float_linear"), H.get("OES_standard_derivatives"), H.get("OES_element_index_uint"), H.get("OES_vertex_array_object"), H.get("ANGLE_instanced_arrays")), H.get("OES_texture_float_linear"), ot = new wa(lt, H, G), V = new ba(lt, H, G), V.scissor(S.copy(O).multiplyScalar(L).floor()), V.viewport(M.copy(C).multiplyScalar(L).floor()), j = new Ns(lt), W = new ra, q = new _a(lt, H, V, W, G, ot, j), X = new Ps(p), Y = new bs(lt, G), at = new Es(lt, H, Y, G), J = new Os(lt, Y, j, at), Z = new zs(lt, J, Y, j), it = new Us(lt), et = new Rs(W), K = new ia(p, X, H, G, at, et), $ = new Aa(W), Q = new la(W), tt = new ma, nt = new Ts(p, X, V, Z, a), rt = new As(lt, H, j, G), st = new Is(lt, H, j, G), j.programs = K.programs, p.capabilities = G, p.extensions = H, p.properties = W, p.renderLists = Q, p.state = V, p.info = j
                }
                ht();
                const ut = new Ea(p, lt);
                this.xr = ut;
                const dt = new xa(p, Z, G.maxTextureSize);

                function pt(t) {
                    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), m = !0
                }

                function mt() {
                    console.log("THREE.WebGLRenderer: Context Restored."), m = !1, ht()
                }

                function ft(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", ft),
                        function(t) {
                            gt(t), W.remove(t)
                        }(e)
                }

                function gt(t) {
                    const e = W.get(t).program;
                    void 0 !== e && K.releaseProgram(e)
                }
                this.shadowMap = dt, this.getContext = function() {
                    return lt
                }, this.getContextAttributes = function() {
                    return lt.getContextAttributes()
                }, this.forceContextLoss = function() {
                    const t = H.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function() {
                    const t = H.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function() {
                    return L
                }, this.setPixelRatio = function(t) {
                    void 0 !== t && (L = t, this.setSize(E, A, !1))
                }, this.getSize = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new Cn), t.set(E, A)
                }, this.setSize = function(t, n, i) {
                    ut.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E = t, A = n, e.width = Math.floor(t * L), e.height = Math.floor(n * L), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                }, this.getDrawingBufferSize = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new Cn), t.set(E * L, A * L).floor()
                }, this.setDrawingBufferSize = function(t, n, i) {
                    E = t, A = n, L = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
                }, this.getCurrentViewport = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new Un), t.copy(M)
                }, this.getViewport = function(t) {
                    return t.copy(C)
                }, this.setViewport = function(t, e, n, i) {
                    t.isVector4 ? C.set(t.x, t.y, t.z, t.w) : C.set(t, e, n, i), V.viewport(M.copy(C).multiplyScalar(L).floor())
                }, this.getScissor = function(t) {
                    return t.copy(O)
                }, this.setScissor = function(t, e, n, i) {
                    t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, i), V.scissor(S.copy(O).multiplyScalar(L).floor())
                }, this.getScissorTest = function() {
                    return I
                }, this.setScissorTest = function(t) {
                    V.setScissorTest(I = t)
                }, this.setOpaqueSort = function(t) {
                    R = t
                }, this.setTransparentSort = function(t) {
                    P = t
                }, this.getClearColor = function() {
                    return nt.getClearColor()
                }, this.setClearColor = function() {
                    nt.setClearColor.apply(nt, arguments)
                }, this.getClearAlpha = function() {
                    return nt.getClearAlpha()
                }, this.setClearAlpha = function() {
                    nt.setClearAlpha.apply(nt, arguments)
                }, this.clear = function(t, e, n) {
                    let i = 0;
                    (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), lt.clear(i)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    e.removeEventListener("webglcontextlost", pt, !1), e.removeEventListener("webglcontextrestored", mt, !1), Q.dispose(), tt.dispose(), W.dispose(), X.dispose(), Z.dispose(), at.dispose(), ut.dispose(), yt.stop()
                }, this.renderBufferImmediate = function(t, e) {
                    at.initAttributes();
                    const n = W.get(t);
                    t.hasPositions && !n.position && (n.position = lt.createBuffer()), t.hasNormals && !n.normal && (n.normal = lt.createBuffer()), t.hasUvs && !n.uv && (n.uv = lt.createBuffer()), t.hasColors && !n.color && (n.color = lt.createBuffer());
                    const i = e.getAttributes();
                    t.hasPositions && (lt.bindBuffer(34962, n.position), lt.bufferData(34962, t.positionArray, 35048), at.enableAttribute(i.position), lt.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (lt.bindBuffer(34962, n.normal), lt.bufferData(34962, t.normalArray, 35048), at.enableAttribute(i.normal), lt.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (lt.bindBuffer(34962, n.uv), lt.bufferData(34962, t.uvArray, 35048), at.enableAttribute(i.uv), lt.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (lt.bindBuffer(34962, n.color), lt.bufferData(34962, t.colorArray, 35048), at.enableAttribute(i.color), lt.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), at.disableUnusedAttributes(), lt.drawArrays(4, 0, t.count), t.count = 0
                }, this.renderBufferDirect = function(t, e, n, i, r, s) {
                    null === e && (e = k);
                    const o = r.isMesh && r.matrixWorld.determinant() < 0,
                        a = St(t, e, i, r);
                    V.setMaterial(i, o);
                    let l = n.index;
                    const c = n.attributes.position;
                    if (null === l) {
                        if (void 0 === c || 0 === c.count) return
                    } else if (0 === l.count) return;
                    let h, u = 1;
                    !0 === i.wireframe && (l = J.getWireframeAttribute(n), u = 2), (i.morphTargets || i.morphNormals) && it.update(r, n, i, a), at.setup(r, i, a, n, l);
                    let d = rt;
                    null !== l && (h = Y.get(l), d = st, d.setIndex(h));
                    const p = null !== l ? l.count : c.count,
                        m = n.drawRange.start * u,
                        f = n.drawRange.count * u,
                        g = null !== s ? s.start * u : 0,
                        v = null !== s ? s.count * u : 1 / 0,
                        y = Math.max(m, g),
                        x = Math.min(p, m + f, g + v) - 1,
                        b = Math.max(0, x - y + 1);
                    if (0 !== b) {
                        if (r.isMesh) !0 === i.wireframe ? (V.setLineWidth(i.wireframeLinewidth * B()), d.setMode(1)) : d.setMode(4);
                        else if (r.isLine) {
                            let t = i.linewidth;
                            void 0 === t && (t = 1), V.setLineWidth(t * B()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                        } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                        if (r.isInstancedMesh) d.renderInstances(y, b, r.count);
                        else if (n.isInstancedBufferGeometry) {
                            const t = Math.min(n.instanceCount, n._maxInstanceCount);
                            d.renderInstances(y, b, t)
                        } else d.render(y, b)
                    }
                }, this.compile = function(t, e) {
                    d = tt.get(t, e), d.init(), t.traverse((function(t) {
                        t.isLight && (d.pushLight(t), t.castShadow && d.pushShadow(t))
                    })), d.setupLights(e);
                    const n = new WeakMap;
                    t.traverse((function(e) {
                        const i = e.material;
                        if (i)
                            if (Array.isArray(i))
                                for (let r = 0; r < i.length; r++) {
                                    const s = i[r];
                                    !1 === n.has(s) && (Mt(s, t, e), n.set(s))
                                } else !1 === n.has(i) && (Mt(i, t, e), n.set(i))
                    }))
                };
                let vt = null;
                const yt = new xs;

                function xt(t, e, n, i) {
                    if (!1 === t.visible) return;
                    if (t.layers.test(e.layers))
                        if (t.isGroup) n = t.renderOrder;
                        else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || N.intersectsSprite(t)) {
                            i && z.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);
                            const e = Z.update(t),
                                r = t.material;
                            r.visible && u.push(t, e, r, n, z.z, null)
                        }
                    } else if (t.isImmediateRenderObject) i && z.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U), u.push(t, null, t.material, n, z.z, null);
                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== j.render.frame && (t.skeleton.update(), t.skeleton.frame = j.render.frame), !t.frustumCulled || N.intersectsObject(t))) {
                        i && z.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);
                        const e = Z.update(t),
                            r = t.material;
                        if (Array.isArray(r)) {
                            const i = e.groups;
                            for (let s = 0, o = i.length; s < o; s++) {
                                const o = i[s],
                                    a = r[o.materialIndex];
                                a && a.visible && u.push(t, e, a, n, z.z, o)
                            }
                        } else r.visible && u.push(t, e, r, n, z.z, null)
                    }
                    const r = t.children;
                    for (let s = 0, o = r.length; s < o; s++) xt(r[s], e, n, i)
                }

                function bt(t, e, n) {
                    const i = !0 === e.isScene ? e.overrideMaterial : null;
                    for (let r = 0, s = t.length; r < s; r++) {
                        const s = t[r],
                            o = s.object,
                            a = s.geometry,
                            l = null === i ? s.material : i,
                            c = s.group;
                        if (n.isArrayCamera) {
                            w = n;
                            const t = n.cameras;
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = t[n];
                                o.layers.test(i.layers) && (V.viewport(M.copy(i.viewport)), d.setupLights(i), wt(o, e, i, a, l, c))
                            }
                        } else w = null, wt(o, e, n, a, l, c)
                    }
                }

                function wt(t, e, n, i, r, s) {
                    if (t.onBeforeRender(p, e, n, i, r, s), d = tt.get(e, w || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                        const i = St(n, e, r, t);
                        V.setMaterial(r), at.reset(),
                            function(t, e) {
                                t.render((function(t) {
                                    p.renderBufferImmediate(t, e)
                                }))
                            }(t, i)
                    } else p.renderBufferDirect(n, e, i, r, t, s);
                    t.onAfterRender(p, e, n, i, r, s), d = tt.get(e, w || n)
                }

                function Mt(t, e, n) {
                    !0 !== e.isScene && (e = k);
                    const i = W.get(t),
                        r = d.state.lights,
                        s = d.state.shadowsArray,
                        o = r.state.version,
                        a = K.getParameters(t, r.state, s, e, n),
                        l = K.getProgramCacheKey(a);
                    let c = i.program,
                        h = !0;
                    if (void 0 === c) t.addEventListener("dispose", ft);
                    else if (c.cacheKey !== l) gt(t);
                    else if (i.lightsStateVersion !== o) h = !1;
                    else {
                        if (void 0 !== a.shaderID) {
                            const n = t.isMeshStandardMaterial ? e.environment : null;
                            return void(i.envMap = X.get(t.envMap || n))
                        }
                        h = !1
                    }
                    h && (a.uniforms = K.getUniforms(t), t.onBeforeCompile(a, p), c = K.acquireProgram(a, l), i.program = c, i.uniforms = a.uniforms, i.outputEncoding = a.outputEncoding);
                    const u = i.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = et.numPlanes, i.numIntersection = et.numIntersection, u.clippingPlanes = et.uniform), i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = X.get(t.envMap || i.environment), i.needsLights = function(t) {
                        return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                    }(t), i.lightsStateVersion = o, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    const m = i.program.getUniforms(),
                        f = Fo.seqWithValue(m.seq, u);
                    i.uniformsList = f
                }

                function St(t, e, n, i) {
                    !0 !== e.isScene && (e = k), q.resetTextureUnits();
                    const r = e.fog,
                        s = n.isMeshStandardMaterial ? e.environment : null,
                        o = null === y ? p.outputEncoding : y.texture.encoding,
                        a = X.get(n.envMap || s),
                        l = W.get(n),
                        c = d.state.lights;
                    if (!0 === D && (!0 === F || t !== _)) {
                        const e = t === _ && n.id === b;
                        et.setState(n, t, e)
                    }
                    n.version === l.__version ? n.fog && l.fog !== r ? Mt(n, e, i) : l.environment !== s ? Mt(n, e, i) : l.needsLights && l.lightsStateVersion !== c.state.version ? Mt(n, e, i) : void 0 === l.numClippingPlanes || l.numClippingPlanes === et.numPlanes && l.numIntersection === et.numIntersection ? l.outputEncoding !== o ? Mt(n, e, i) : l.envMap !== a && Mt(n, e, i) : Mt(n, e, i) : (Mt(n, e, i), l.__version = n.version);
                    let h = !1,
                        u = !1,
                        m = !1;
                    const f = l.program,
                        g = f.getUniforms(),
                        v = l.uniforms;
                    if (V.useProgram(f.program) && (h = !0, u = !0, m = !0), n.id !== b && (b = n.id, u = !0), h || _ !== t) {
                        if (g.setValue(lt, "projectionMatrix", t.projectionMatrix), G.logarithmicDepthBuffer && g.setValue(lt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), _ !== t && (_ = t, u = !0, m = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                            const e = g.map.cameraPosition;
                            void 0 !== e && e.setValue(lt, z.setFromMatrixPosition(t.matrixWorld))
                        }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && g.setValue(lt, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && g.setValue(lt, "viewMatrix", t.matrixWorldInverse)
                    }
                    if (n.skinning) {
                        g.setOptional(lt, i, "bindMatrix"), g.setOptional(lt, i, "bindMatrixInverse");
                        const t = i.skeleton;
                        if (t) {
                            const e = t.bones;
                            if (G.floatVertexTextures) {
                                if (void 0 === t.boneTexture) {
                                    let n = Math.sqrt(4 * e.length);
                                    n = Pn.ceilPowerOfTwo(n), n = Math.max(n, 4);
                                    const i = new Float32Array(n * n * 4);
                                    i.set(t.boneMatrices);
                                    const r = new fs(i, n, n, ne, Yt);
                                    t.boneMatrices = i, t.boneTexture = r, t.boneTextureSize = n
                                }
                                g.setValue(lt, "boneTexture", t.boneTexture, q), g.setValue(lt, "boneTextureSize", t.boneTextureSize)
                            } else g.setOptional(lt, t, "boneMatrices")
                        }
                    }
                    var x, w;
                    return (u || l.receiveShadow !== i.receiveShadow) && (l.receiveShadow = i.receiveShadow, g.setValue(lt, "receiveShadow", i.receiveShadow)), u && (g.setValue(lt, "toneMappingExposure", p.toneMappingExposure), l.needsLights && (w = m, (x = v).ambientLightColor.needsUpdate = w, x.lightProbe.needsUpdate = w, x.directionalLights.needsUpdate = w, x.directionalLightShadows.needsUpdate = w, x.pointLights.needsUpdate = w, x.pointLightShadows.needsUpdate = w, x.spotLights.needsUpdate = w, x.spotLightShadows.needsUpdate = w, x.rectAreaLights.needsUpdate = w, x.hemisphereLights.needsUpdate = w), r && n.fog && $.refreshFogUniforms(v, r), $.refreshMaterialUniforms(v, n, L, A), Fo.upload(lt, l.uniformsList, v, q)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (Fo.upload(lt, l.uniformsList, v, q), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && g.setValue(lt, "center", i.center), g.setValue(lt, "modelViewMatrix", i.modelViewMatrix), g.setValue(lt, "normalMatrix", i.normalMatrix), g.setValue(lt, "modelMatrix", i.matrixWorld), f
                }
                yt.setAnimationLoop((function(t) {
                    ut.isPresenting || vt && vt(t)
                })), "undefined" !== typeof window && yt.setContext(window), this.setAnimationLoop = function(t) {
                    vt = t, ut.setAnimationLoop(t), null === t ? yt.stop() : yt.start()
                }, this.render = function(t, e) {
                    let n, i;
                    if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === m) return;
                    at.resetDefaultState(), b = -1, _ = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === ut.enabled && !0 === ut.isPresenting && (e = ut.getCamera(e)), !0 === t.isScene && t.onBeforeRender(p, t, e, n || y), d = tt.get(t, e), d.init(), U.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), N.setFromProjectionMatrix(U), F = this.localClippingEnabled, D = et.init(this.clippingPlanes, F, e), u = Q.get(t, e), u.init(), xt(t, e, 0, p.sortObjects), u.finish(), !0 === p.sortObjects && u.sort(R, P), !0 === D && et.beginShadows();
                    const r = d.state.shadowsArray;
                    dt.render(r, t, e), d.setupLights(e), !0 === D && et.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), nt.render(u, t, e, i);
                    const s = u.opaque,
                        o = u.transparent;
                    s.length > 0 && bt(s, t, e), o.length > 0 && bt(o, t, e), !0 === t.isScene && t.onAfterRender(p, t, e), null !== y && (q.updateRenderTargetMipmap(y), q.updateMultisampleRenderTarget(y)), V.buffers.depth.setTest(!0), V.buffers.depth.setMask(!0), V.buffers.color.setMask(!0), V.setPolygonOffset(!1), u = null, d = null
                }, this.setFramebuffer = function(t) {
                    f !== t && null === y && lt.bindFramebuffer(36160, t), f = t
                }, this.getActiveCubeFace = function() {
                    return g
                }, this.getActiveMipmapLevel = function() {
                    return v
                }, this.getRenderList = function() {
                    return u
                }, this.setRenderList = function(t) {
                    u = t
                }, this.getRenderState = function() {
                    return d
                }, this.setRenderState = function(t) {
                    d = t
                }, this.getRenderTarget = function() {
                    return y
                }, this.setRenderTarget = function(t, e = 0, n = 0) {
                    y = t, g = e, v = n, t && void 0 === W.get(t).__webglFramebuffer && q.setupRenderTarget(t);
                    let i = f,
                        r = !1;
                    if (t) {
                        const n = W.get(t).__webglFramebuffer;
                        t.isWebGLCubeRenderTarget ? (i = n[e], r = !0) : i = t.isWebGLMultisampleRenderTarget ? W.get(t).__webglMultisampledFramebuffer : n, M.copy(t.viewport), S.copy(t.scissor), T = t.scissorTest
                    } else M.copy(C).multiplyScalar(L).floor(), S.copy(O).multiplyScalar(L).floor(), T = I;
                    if (x !== i && (lt.bindFramebuffer(36160, i), x = i), V.viewport(M), V.scissor(S), V.setScissorTest(T), r) {
                        const i = W.get(t.texture);
                        lt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
                    }
                }, this.readRenderTargetPixels = function(t, e, n, i, r, s, o) {
                    if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let a = W.get(t).__webglFramebuffer;
                    if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
                        let o = !1;
                        a !== x && (lt.bindFramebuffer(36160, a), o = !0);
                        try {
                            const a = t.texture,
                                l = a.format,
                                c = a.type;
                            if (l !== ne && ot.convert(l) !== lt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (c !== Gt && ot.convert(c) !== lt.getParameter(35738) && (c !== Yt || !(G.isWebGL2 || H.get("OES_texture_float") || H.get("WEBGL_color_buffer_float"))) && (c !== Jt || (G.isWebGL2 ? !H.get("EXT_color_buffer_float") : !H.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            36053 === lt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && lt.readPixels(e, n, i, r, ot.convert(l), ot.convert(c), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            o && lt.bindFramebuffer(36160, x)
                        }
                    }
                }, this.copyFramebufferToTexture = function(t, e, n) {
                    void 0 === n && (n = 0);
                    const i = Math.pow(2, -n),
                        r = Math.floor(e.image.width * i),
                        s = Math.floor(e.image.height * i),
                        o = ot.convert(e.format);
                    q.setTexture2D(e, 0), lt.copyTexImage2D(3553, n, o, t.x, t.y, r, s, 0), V.unbindTexture()
                }, this.copyTextureToTexture = function(t, e, n, i) {
                    void 0 === i && (i = 0);
                    const r = e.image.width,
                        s = e.image.height,
                        o = ot.convert(n.format),
                        a = ot.convert(n.type);
                    q.setTexture2D(n, 0), lt.pixelStorei(37440, n.flipY), lt.pixelStorei(37441, n.premultiplyAlpha), lt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? lt.texSubImage2D(3553, i, t.x, t.y, r, s, o, a, e.image.data) : e.isCompressedTexture ? lt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : lt.texSubImage2D(3553, i, t.x, t.y, o, a, e.image), 0 === i && n.generateMipmaps && lt.generateMipmap(3553), V.unbindTexture()
                }, this.initTexture = function(t) {
                    q.setTexture2D(t, 0), V.unbindTexture()
                }, "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }

            function Ra(t) {
                La.call(this, t)
            }
            Ma.prototype = Object.assign(Object.create(cs.prototype), {
                constructor: Ma,
                isArrayCamera: !0
            }), Sa.prototype = Object.assign(Object.create(Bi.prototype), {
                constructor: Sa,
                isGroup: !0
            }), Object.assign(Ta.prototype, {
                constructor: Ta,
                getHandSpace: function() {
                    if (null === this._hand && (this._hand = new Sa, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = [], this._hand.inputState = {
                            pinching: !1
                        }, window.XRHand))
                        for (let t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) {
                            const t = new Sa;
                            t.matrixAutoUpdate = !1, t.visible = !1, this._hand.joints.push(t), this._hand.add(t)
                        }
                    return this._hand
                },
                getTargetRaySpace: function() {
                    return null === this._targetRay && (this._targetRay = new Sa, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay
                },
                getGripSpace: function() {
                    return null === this._grip && (this._grip = new Sa, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip
                },
                dispatchEvent: function(t) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                },
                disconnect: function(t) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: t
                    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                },
                update: function(t, e, n) {
                    let i = null,
                        r = null,
                        s = null;
                    const o = this._targetRay,
                        a = this._grip,
                        l = this._hand;
                    if (t)
                        if (l && t.hand) {
                            s = !0;
                            for (let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++)
                                if (t.hand[i]) {
                                    const r = e.getJointPose(t.hand[i], n),
                                        s = l.joints[i];
                                    null !== r && (s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.jointRadius = r.radius), s.visible = null !== r;
                                    const o = l.joints[window.XRHand.INDEX_PHALANX_TIP],
                                        a = l.joints[window.XRHand.THUMB_PHALANX_TIP],
                                        c = o.position.distanceTo(a.position),
                                        h = .02,
                                        u = .005;
                                    l.inputState.pinching && c > h + u ? (l.inputState.pinching = !1, this.dispatchEvent({
                                        type: "pinchend",
                                        handedness: t.handedness,
                                        target: this
                                    })) : !l.inputState.pinching && c <= h - u && (l.inputState.pinching = !0, this.dispatchEvent({
                                        type: "pinchstart",
                                        handedness: t.handedness,
                                        target: this
                                    }))
                                }
                        } else null !== o && (i = e.getPose(t.targetRaySpace, n), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale))), null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale)));
                    return null !== o && (o.visible = null !== i), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== s), this
                }
            }), Object.assign(Ea.prototype, An.prototype), Ra.prototype = Object.assign(Object.create(La.prototype), {
                constructor: Ra,
                isWebGL1Renderer: !0
            });
            class Pa extends Bi {
                constructor() {
                    super(), Object.defineProperty(this, "isScene", {
                        value: !0
                    }), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                copy(t, e) {
                    return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                }
            }

            function Ca(t, e) {
                this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = Tn, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0, this.uuid = Pn.generateUUID()
            }
            Object.defineProperty(Ca.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(Ca.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function() {},
                setUsage: function(t) {
                    return this.usage = t, this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
                },
                copyAt: function(t, e, n) {
                    t *= this.stride, n *= e.stride;
                    for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                clone: function(t) {
                    void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Pn.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    const e = new Ca(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride);
                    return e.setUsage(this.usage), e
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                toJSON: function(t) {
                    return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Pn.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            });
            const Oa = new Hn;

            function Ia(t, e, n, i) {
                this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
            }

            function Na(t) {
                ur.call(this), this.type = "SpriteMaterial", this.color = new lr(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
            }
            let Da;
            Object.defineProperties(Ia.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                },
                needsUpdate: {
                    set: function(t) {
                        this.data.needsUpdate = t
                    }
                }
            }), Object.assign(Ia.prototype, {
                isInterleavedBufferAttribute: !0,
                applyMatrix4: function(t) {
                    for (let e = 0, n = this.data.count; e < n; e++) Oa.x = this.getX(e), Oa.y = this.getY(e), Oa.z = this.getZ(e), Oa.applyMatrix4(t), this.setXYZ(e, Oa.x, Oa.y, Oa.z);
                    return this
                },
                setX: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e, this
                },
                setY: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                },
                setZ: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                },
                setW: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                },
                getX: function(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                },
                getY: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                },
                getZ: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                },
                getW: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                },
                setXY: function(t, e, n) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, i) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
                },
                setXYZW: function(t, e, n, i, r) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
                },
                clone: function(t) {
                    if (void 0 === t) {
                        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                        const t = [];
                        for (let e = 0; e < this.count; e++) {
                            const n = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                        }
                        return new fr(new this.array.constructor(t), this.itemSize, this.normalized)
                    }
                    return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Ia(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                },
                toJSON: function(t) {
                    if (void 0 === t) {
                        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                        const t = [];
                        for (let e = 0; e < this.count; e++) {
                            const n = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: t,
                            normalized: this.normalized
                        }
                    }
                    return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }
                }
            }), Na.prototype = Object.create(ur.prototype), Na.prototype.constructor = Na, Na.prototype.isSpriteMaterial = !0, Na.prototype.copy = function(t) {
                return ur.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
            };
            const Fa = new Hn,
                Ua = new Hn,
                za = new Hn,
                ka = new Cn,
                Ba = new Cn,
                Ha = new fi,
                Ga = new Hn,
                Va = new Hn,
                ja = new Hn,
                Wa = new Cn,
                qa = new Cn,
                Xa = new Cn;

            function Ya(t) {
                if (Bi.call(this), this.type = "Sprite", void 0 === Da) {
                    Da = new Nr;
                    const t = new Ca(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                    Da.setIndex([0, 1, 2, 0, 2, 3]), Da.setAttribute("position", new Ia(t, 3, 0, !1)), Da.setAttribute("uv", new Ia(t, 2, 3, !1))
                }
                this.geometry = Da, this.material = void 0 !== t ? t : new Na, this.center = new Cn(.5, .5)
            }

            function Ja(t, e, n, i, r, s) {
                ka.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (Ba.x = s * ka.x - r * ka.y, Ba.y = r * ka.x + s * ka.y) : Ba.copy(ka), t.copy(e), t.x += Ba.x, t.y += Ba.y, t.applyMatrix4(Ha)
            }
            Ya.prototype = Object.assign(Object.create(Bi.prototype), {
                constructor: Ya,
                isSprite: !0,
                raycast: function(t, e) {
                    null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Ua.setFromMatrixScale(this.matrixWorld), Ha.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), za.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Ua.multiplyScalar(-za.z);
                    const n = this.material.rotation;
                    let i, r;
                    0 !== n && (r = Math.cos(n), i = Math.sin(n));
                    const s = this.center;
                    Ja(Ga.set(-.5, -.5, 0), za, s, Ua, i, r), Ja(Va.set(.5, -.5, 0), za, s, Ua, i, r), Ja(ja.set(.5, .5, 0), za, s, Ua, i, r), Wa.set(0, 0), qa.set(1, 0), Xa.set(1, 1);
                    let o = t.ray.intersectTriangle(Ga, Va, ja, !1, Fa);
                    if (null === o && (Ja(Va.set(-.5, .5, 0), za, s, Ua, i, r), qa.set(0, 1), o = t.ray.intersectTriangle(Ga, ja, Va, !1, Fa), null === o)) return;
                    const a = t.ray.origin.distanceTo(Fa);
                    a < t.near || a > t.far || e.push({
                        distance: a,
                        point: Fa.clone(),
                        uv: er.getUV(Fa, Ga, Va, ja, Wa, qa, Xa, new Cn),
                        face: null,
                        object: this
                    })
                },
                copy: function(t) {
                    return Bi.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
                }
            });
            const Za = new Hn,
                Ka = new Hn;

            function $a() {
                Bi.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                }), this.autoUpdate = !0
            }

            function Qa(t, e) {
                t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), $r.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new fi, this.bindMatrixInverse = new fi
            }
            $a.prototype = Object.assign(Object.create(Bi.prototype), {
                constructor: $a,
                isLOD: !0,
                copy: function(t) {
                    Bi.prototype.copy.call(this, t, !1);
                    const e = t.levels;
                    for (let n = 0, i = e.length; n < i; n++) {
                        const t = e[n];
                        this.addLevel(t.object.clone(), t.distance)
                    }
                    return this.autoUpdate = t.autoUpdate, this
                },
                addLevel: function(t, e) {
                    void 0 === e && (e = 0), e = Math.abs(e);
                    const n = this.levels;
                    let i;
                    for (i = 0; i < n.length && !(e < n[i].distance); i++);
                    return n.splice(i, 0, {
                        distance: e,
                        object: t
                    }), this.add(t), this
                },
                getCurrentLevel: function() {
                    return this._currentLevel
                },
                getObjectForDistance: function(t) {
                    const e = this.levels;
                    if (e.length > 0) {
                        let n, i;
                        for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
                        return e[n - 1].object
                    }
                    return null
                },
                raycast: function(t, e) {
                    if (this.levels.length > 0) {
                        Za.setFromMatrixPosition(this.matrixWorld);
                        const n = t.ray.origin.distanceTo(Za);
                        this.getObjectForDistance(n).raycast(t, e)
                    }
                },
                update: function(t) {
                    const e = this.levels;
                    if (e.length > 1) {
                        Za.setFromMatrixPosition(t.matrixWorld), Ka.setFromMatrixPosition(this.matrixWorld);
                        const n = Za.distanceTo(Ka) / t.zoom;
                        let i, r;
                        for (e[0].object.visible = !0, i = 1, r = e.length; i < r && n >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;
                        for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1
                    }
                },
                toJSON: function(t) {
                    const e = Bi.prototype.toJSON.call(this, t);
                    !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
                    const n = this.levels;
                    for (let i = 0, r = n.length; i < r; i++) {
                        const t = n[i];
                        e.object.levels.push({
                            object: t.object.uuid,
                            distance: t.distance
                        })
                    }
                    return e
                }
            }), Qa.prototype = Object.assign(Object.create($r.prototype), {
                constructor: Qa,
                isSkinnedMesh: !0,
                copy: function(t) {
                    return $r.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
                },
                bind: function(t, e) {
                    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    const t = new Un,
                        e = this.geometry.attributes.skinWeight;
                    for (let n = 0, i = e.count; n < i; n++) {
                        t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                        const i = 1 / t.manhattanLength();
                        i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                    }
                },
                updateMatrixWorld: function(t) {
                    $r.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                },
                boneTransform: function() {
                    const t = new Hn,
                        e = new Un,
                        n = new Un,
                        i = new Hn,
                        r = new fi;
                    return function(s, o) {
                        const a = this.skeleton,
                            l = this.geometry;
                        e.fromBufferAttribute(l.attributes.skinIndex, s), n.fromBufferAttribute(l.attributes.skinWeight, s), t.fromBufferAttribute(l.attributes.position, s).applyMatrix4(this.bindMatrix), o.set(0, 0, 0);
                        for (let c = 0; c < 4; c++) {
                            const s = n.getComponent(c);
                            if (0 !== s) {
                                const n = e.getComponent(c);
                                r.multiplyMatrices(a.bones[n].matrixWorld, a.boneInverses[n]), o.addScaledVector(i.copy(t).applyMatrix4(r), s)
                            }
                        }
                        return o.applyMatrix4(this.bindMatrixInverse)
                    }
                }()
            });
            const tl = new fi,
                el = new fi;

            function nl(t, e) {
                if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), this.frame = -1, void 0 === e) this.calculateInverses();
                else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
                else {
                    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                    for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new fi)
                }
            }

            function il() {
                Bi.call(this), this.type = "Bone"
            }
            Object.assign(nl.prototype, {
                calculateInverses: function() {
                    this.boneInverses = [];
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = new fi;
                        this.bones[t] && e.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(e)
                    }
                },
                pose: function() {
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = this.bones[t];
                        e && e.matrixWorld.getInverse(this.boneInverses[t])
                    }
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = this.bones[t];
                        e && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                    }
                },
                update: function() {
                    const t = this.bones,
                        e = this.boneInverses,
                        n = this.boneMatrices,
                        i = this.boneTexture;
                    for (let r = 0, s = t.length; r < s; r++) {
                        const i = t[r] ? t[r].matrixWorld : el;
                        tl.multiplyMatrices(i, e[r]), tl.toArray(n, 16 * r)
                    }
                    void 0 !== i && (i.needsUpdate = !0)
                },
                clone: function() {
                    return new nl(this.bones, this.boneInverses)
                },
                getBoneByName: function(t) {
                    for (let e = 0, n = this.bones.length; e < n; e++) {
                        const n = this.bones[e];
                        if (n.name === t) return n
                    }
                },
                dispose: function() {
                    this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = void 0)
                }
            }), il.prototype = Object.assign(Object.create(Bi.prototype), {
                constructor: il,
                isBone: !0
            });
            const rl = new fi,
                sl = new fi,
                ol = [],
                al = new $r;

            function ll(t, e, n) {
                $r.call(this, t, e), this.instanceMatrix = new fr(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
            }

            function cl(t) {
                ur.call(this), this.type = "LineBasicMaterial", this.color = new lr(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t)
            }
            ll.prototype = Object.assign(Object.create($r.prototype), {
                constructor: ll,
                isInstancedMesh: !0,
                copy: function(t) {
                    return $r.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), this.count = t.count, this
                },
                setColorAt: function(t, e) {
                    null === this.instanceColor && (this.instanceColor = new fr(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
                },
                getMatrixAt: function(t, e) {
                    e.fromArray(this.instanceMatrix.array, 16 * t)
                },
                raycast: function(t, e) {
                    const n = this.matrixWorld,
                        i = this.count;
                    if (al.geometry = this.geometry, al.material = this.material, void 0 !== al.material)
                        for (let r = 0; r < i; r++) {
                            this.getMatrixAt(r, rl), sl.multiplyMatrices(n, rl), al.matrixWorld = sl, al.raycast(t, ol);
                            for (let t = 0, n = ol.length; t < n; t++) {
                                const n = ol[t];
                                n.instanceId = r, n.object = this, e.push(n)
                            }
                            ol.length = 0
                        }
                },
                setMatrixAt: function(t, e) {
                    e.toArray(this.instanceMatrix.array, 16 * t)
                },
                updateMorphTargets: function() {}
            }), cl.prototype = Object.create(ur.prototype), cl.prototype.constructor = cl, cl.prototype.isLineBasicMaterial = !0, cl.prototype.copy = function(t) {
                return ur.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this
            };
            const hl = new Hn,
                ul = new Hn,
                dl = new fi,
                pl = new mi,
                ml = new oi;

            function fl(t, e, n) {
                1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), Bi.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Nr, this.material = void 0 !== e ? e : new cl, this.updateMorphTargets()
            }
            fl.prototype = Object.assign(Object.create(Bi.prototype), {
                constructor: fl,
                isLine: !0,
                copy: function(t) {
                    return Bi.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this
                },
                computeLineDistances: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            const e = t.attributes.position,
                                n = [0];
                            for (let t = 1, i = e.count; t < i; t++) hl.fromBufferAttribute(e, t - 1), ul.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += hl.distanceTo(ul);
                            t.setAttribute("lineDistance", new Mr(n, 1))
                        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (t.isGeometry) {
                        const e = t.vertices,
                            n = t.lineDistances;
                        n[0] = 0;
                        for (let t = 1, i = e.length; t < i; t++) n[t] = n[t - 1], n[t] += e[t - 1].distanceTo(e[t])
                    }
                    return this
                },
                raycast: function(t, e) {
                    const n = this.geometry,
                        i = this.matrixWorld,
                        r = t.params.Line.threshold;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), ml.copy(n.boundingSphere), ml.applyMatrix4(i), ml.radius += r, !1 === t.ray.intersectsSphere(ml)) return;
                    dl.getInverse(i), pl.copy(t.ray).applyMatrix4(dl);
                    const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = s * s,
                        a = new Hn,
                        l = new Hn,
                        c = new Hn,
                        h = new Hn,
                        u = this.isLineSegments ? 2 : 1;
                    if (n.isBufferGeometry) {
                        const i = n.index,
                            r = n.attributes.position;
                        if (null !== i) {
                            const n = i.array;
                            for (let i = 0, s = n.length - 1; i < s; i += u) {
                                const s = n[i],
                                    u = n[i + 1];
                                if (a.fromBufferAttribute(r, s), l.fromBufferAttribute(r, u), pl.distanceSqToSegment(a, l, h, c) > o) continue;
                                h.applyMatrix4(this.matrixWorld);
                                const d = t.ray.origin.distanceTo(h);
                                d < t.near || d > t.far || e.push({
                                    distance: d,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        } else
                            for (let n = 0, s = r.count - 1; n < s; n += u) {
                                if (a.fromBufferAttribute(r, n), l.fromBufferAttribute(r, n + 1), pl.distanceSqToSegment(a, l, h, c) > o) continue;
                                h.applyMatrix4(this.matrixWorld);
                                const i = t.ray.origin.distanceTo(h);
                                i < t.near || i > t.far || e.push({
                                    distance: i,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: n,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                    } else if (n.isGeometry) {
                        const i = n.vertices,
                            r = i.length;
                        for (let n = 0; n < r - 1; n += u) {
                            if (pl.distanceSqToSegment(i[n], i[n + 1], h, c) > o) continue;
                            h.applyMatrix4(this.matrixWorld);
                            const r = t.ray.origin.distanceTo(h);
                            r < t.near || r > t.far || e.push({
                                distance: r,
                                point: c.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                },
                updateMorphTargets: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            n = Object.keys(e);
                        if (n.length > 0) {
                            const t = e[n[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
            });
            const gl = new Hn,
                vl = new Hn;

            function yl(t, e) {
                fl.call(this, t, e), this.type = "LineSegments"
            }

            function xl(t, e) {
                fl.call(this, t, e), this.type = "LineLoop"
            }

            function bl(t) {
                ur.call(this), this.type = "PointsMaterial", this.color = new lr(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
            }
            yl.prototype = Object.assign(Object.create(fl.prototype), {
                constructor: yl,
                isLineSegments: !0,
                computeLineDistances: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            const e = t.attributes.position,
                                n = [];
                            for (let t = 0, i = e.count; t < i; t += 2) gl.fromBufferAttribute(e, t), vl.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + gl.distanceTo(vl);
                            t.setAttribute("lineDistance", new Mr(n, 1))
                        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (t.isGeometry) {
                        const e = t.vertices,
                            n = t.lineDistances;
                        for (let t = 0, i = e.length; t < i; t += 2) gl.copy(e[t]), vl.copy(e[t + 1]), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + gl.distanceTo(vl)
                    }
                    return this
                }
            }), xl.prototype = Object.assign(Object.create(fl.prototype), {
                constructor: xl,
                isLineLoop: !0
            }), bl.prototype = Object.create(ur.prototype), bl.prototype.constructor = bl, bl.prototype.isPointsMaterial = !0, bl.prototype.copy = function(t) {
                return ur.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
            };
            const _l = new fi,
                wl = new mi,
                Ml = new oi,
                Sl = new Hn;

            function Tl(t, e) {
                Bi.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Nr, this.material = void 0 !== e ? e : new bl, this.updateMorphTargets()
            }

            function El(t, e, n, i, r, s, o) {
                const a = wl.distanceSqToPoint(t);
                if (a < n) {
                    const n = new Hn;
                    wl.closestPointToPoint(t, n), n.applyMatrix4(i);
                    const l = r.ray.origin.distanceTo(n);
                    if (l < r.near || l > r.far) return;
                    s.push({
                        distance: l,
                        distanceToRay: Math.sqrt(a),
                        point: n,
                        index: e,
                        face: null,
                        object: o
                    })
                }
            }

            function Al(t, e, n, i, r, s, o, a, l) {
                Fn.call(this, t, e, n, i, r, s, o, a, l), this.format = void 0 !== o ? o : ee, this.minFilter = void 0 !== s ? s : kt, this.magFilter = void 0 !== r ? r : kt, this.generateMipmaps = !1;
                const c = this;
                "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                    c.needsUpdate = !0, t.requestVideoFrameCallback(e)
                }))
            }

            function Ll(t, e, n, i, r, s, o, a, l, c, h, u) {
                Fn.call(this, null, s, o, a, l, c, i, r, h, u), this.image = {
                    width: e,
                    height: n
                }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
            }

            function Rl(t, e, n, i, r, s, o, a, l) {
                Fn.call(this, t, e, n, i, r, s, o, a, l), this.needsUpdate = !0
            }

            function Pl(t, e, n, i, r, s, o, a, l, c) {
                if ((c = void 0 !== c ? c : oe) !== oe && c !== ae) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === oe && (n = Wt), void 0 === n && c === ae && (n = Qt), Fn.call(this, null, i, r, s, o, a, c, n, l), this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== o ? o : Ft, this.minFilter = void 0 !== a ? a : Ft, this.flipY = !1, this.generateMipmaps = !1
            }
            Tl.prototype = Object.assign(Object.create(Bi.prototype), {
                constructor: Tl,
                isPoints: !0,
                copy: function(t) {
                    return Bi.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this
                },
                raycast: function(t, e) {
                    const n = this.geometry,
                        i = this.matrixWorld,
                        r = t.params.Points.threshold;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), Ml.copy(n.boundingSphere), Ml.applyMatrix4(i), Ml.radius += r, !1 === t.ray.intersectsSphere(Ml)) return;
                    _l.getInverse(i), wl.copy(t.ray).applyMatrix4(_l);
                    const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = s * s;
                    if (n.isBufferGeometry) {
                        const r = n.index,
                            s = n.attributes.position;
                        if (null !== r) {
                            const n = r.array;
                            for (let r = 0, a = n.length; r < a; r++) {
                                const a = n[r];
                                Sl.fromBufferAttribute(s, a), El(Sl, a, o, i, t, e, this)
                            }
                        } else
                            for (let n = 0, a = s.count; n < a; n++) Sl.fromBufferAttribute(s, n), El(Sl, n, o, i, t, e, this)
                    } else {
                        const r = n.vertices;
                        for (let n = 0, s = r.length; n < s; n++) El(r[n], n, o, i, t, e, this)
                    }
                },
                updateMorphTargets: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            n = Object.keys(e);
                        if (n.length > 0) {
                            const t = e[n[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
            }), Al.prototype = Object.assign(Object.create(Fn.prototype), {
                constructor: Al,
                isVideoTexture: !0,
                update: function() {
                    const t = this.image;
                    !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), Ll.prototype = Object.create(Fn.prototype), Ll.prototype.constructor = Ll, Ll.prototype.isCompressedTexture = !0, Rl.prototype = Object.create(Fn.prototype), Rl.prototype.constructor = Rl, Rl.prototype.isCanvasTexture = !0, Pl.prototype = Object.create(Fn.prototype), Pl.prototype.constructor = Pl, Pl.prototype.isDepthTexture = !0;
            let Cl = 0;
            const Ol = new fi,
                Il = new Bi,
                Nl = new Hn;

            function Dl() {
                Object.defineProperty(this, "id", {
                    value: Cl += 2
                }), this.uuid = Pn.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }
            Dl.prototype = Object.assign(Object.create(An.prototype), {
                constructor: Dl,
                isGeometry: !0,
                applyMatrix4: function(t) {
                    const e = (new On).getNormalMatrix(t);
                    for (let n = 0, i = this.vertices.length; n < i; n++) {
                        this.vertices[n].applyMatrix4(t)
                    }
                    for (let n = 0, i = this.faces.length; n < i; n++) {
                        const t = this.faces[n];
                        t.normal.applyMatrix3(e).normalize();
                        for (let n = 0, i = t.vertexNormals.length; n < i; n++) t.vertexNormals[n].applyMatrix3(e).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function(t) {
                    return Ol.makeRotationX(t), this.applyMatrix4(Ol), this
                },
                rotateY: function(t) {
                    return Ol.makeRotationY(t), this.applyMatrix4(Ol), this
                },
                rotateZ: function(t) {
                    return Ol.makeRotationZ(t), this.applyMatrix4(Ol), this
                },
                translate: function(t, e, n) {
                    return Ol.makeTranslation(t, e, n), this.applyMatrix4(Ol), this
                },
                scale: function(t, e, n) {
                    return Ol.makeScale(t, e, n), this.applyMatrix4(Ol), this
                },
                lookAt: function(t) {
                    return Il.lookAt(t), Il.updateMatrix(), this.applyMatrix4(Il.matrix), this
                },
                fromBufferGeometry: function(t) {
                    const e = this,
                        n = null !== t.index ? t.index : void 0,
                        i = t.attributes;
                    if (void 0 === i.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
                    const r = i.position,
                        s = i.normal,
                        o = i.color,
                        a = i.uv,
                        l = i.uv2;
                    void 0 !== l && (this.faceVertexUvs[1] = []);
                    for (let u = 0; u < r.count; u++) e.vertices.push((new Hn).fromBufferAttribute(r, u)), void 0 !== o && e.colors.push((new lr).fromBufferAttribute(o, u));

                    function c(t, n, i, r) {
                        const c = void 0 === o ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()],
                            h = void 0 === s ? [] : [(new Hn).fromBufferAttribute(s, t), (new Hn).fromBufferAttribute(s, n), (new Hn).fromBufferAttribute(s, i)],
                            u = new cr(t, n, i, h, c, r);
                        e.faces.push(u), void 0 !== a && e.faceVertexUvs[0].push([(new Cn).fromBufferAttribute(a, t), (new Cn).fromBufferAttribute(a, n), (new Cn).fromBufferAttribute(a, i)]), void 0 !== l && e.faceVertexUvs[1].push([(new Cn).fromBufferAttribute(l, t), (new Cn).fromBufferAttribute(l, n), (new Cn).fromBufferAttribute(l, i)])
                    }
                    const h = t.groups;
                    if (h.length > 0)
                        for (let u = 0; u < h.length; u++) {
                            const t = h[u],
                                e = t.start;
                            for (let i = e, r = e + t.count; i < r; i += 3) void 0 !== n ? c(n.getX(i), n.getX(i + 1), n.getX(i + 2), t.materialIndex) : c(i, i + 1, i + 2, t.materialIndex)
                        } else if (void 0 !== n)
                            for (let u = 0; u < n.count; u += 3) c(n.getX(u), n.getX(u + 1), n.getX(u + 2));
                        else
                            for (let u = 0; u < r.count; u += 3) c(u, u + 1, u + 2);
                    return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                },
                center: function() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(Nl).negate(), this.translate(Nl.x, Nl.y, Nl.z), this
                },
                normalize: function() {
                    this.computeBoundingSphere();
                    const t = this.boundingSphere.center,
                        e = this.boundingSphere.radius,
                        n = 0 === e ? 1 : 1 / e,
                        i = new fi;
                    return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(i), this
                },
                computeFaceNormals: function() {
                    const t = new Hn,
                        e = new Hn;
                    for (let n = 0, i = this.faces.length; n < i; n++) {
                        const i = this.faces[n],
                            r = this.vertices[i.a],
                            s = this.vertices[i.b],
                            o = this.vertices[i.c];
                        t.subVectors(o, s), e.subVectors(r, s), t.cross(e), t.normalize(), i.normal.copy(t)
                    }
                },
                computeVertexNormals: function(t) {
                    void 0 === t && (t = !0);
                    const e = new Array(this.vertices.length);
                    for (let n = 0, i = this.vertices.length; n < i; n++) e[n] = new Hn;
                    if (t) {
                        const t = new Hn,
                            n = new Hn;
                        for (let i = 0, r = this.faces.length; i < r; i++) {
                            const r = this.faces[i],
                                s = this.vertices[r.a],
                                o = this.vertices[r.b],
                                a = this.vertices[r.c];
                            t.subVectors(a, o), n.subVectors(s, o), t.cross(n), e[r.a].add(t), e[r.b].add(t), e[r.c].add(t)
                        }
                    } else {
                        this.computeFaceNormals();
                        for (let t = 0, n = this.faces.length; t < n; t++) {
                            const n = this.faces[t];
                            e[n.a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal)
                        }
                    }
                    for (let n = 0, i = this.vertices.length; n < i; n++) e[n].normalize();
                    for (let n = 0, i = this.faces.length; n < i; n++) {
                        const t = this.faces[n],
                            i = t.vertexNormals;
                        3 === i.length ? (i[0].copy(e[t.a]), i[1].copy(e[t.b]), i[2].copy(e[t.c])) : (i[0] = e[t.a].clone(), i[1] = e[t.b].clone(), i[2] = e[t.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function() {
                    this.computeFaceNormals();
                    for (let t = 0, e = this.faces.length; t < e; t++) {
                        const e = this.faces[t],
                            n = e.vertexNormals;
                        3 === n.length ? (n[0].copy(e.normal), n[1].copy(e.normal), n[2].copy(e.normal)) : (n[0] = e.normal.clone(), n[1] = e.normal.clone(), n[2] = e.normal.clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    for (let e = 0, n = this.faces.length; e < n; e++) {
                        const t = this.faces[e];
                        t.__originalFaceNormal ? t.__originalFaceNormal.copy(t.normal) : t.__originalFaceNormal = t.normal.clone(), t.__originalVertexNormals || (t.__originalVertexNormals = []);
                        for (let e = 0, n = t.vertexNormals.length; e < n; e++) t.__originalVertexNormals[e] ? t.__originalVertexNormals[e].copy(t.vertexNormals[e]) : t.__originalVertexNormals[e] = t.vertexNormals[e].clone()
                    }
                    const t = new Dl;
                    t.faces = this.faces;
                    for (let e = 0, n = this.morphTargets.length; e < n; e++) {
                        if (!this.morphNormals[e]) {
                            this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                            const t = this.morphNormals[e].faceNormals,
                                n = this.morphNormals[e].vertexNormals;
                            for (let e = 0, i = this.faces.length; e < i; e++) {
                                const e = new Hn,
                                    i = {
                                        a: new Hn,
                                        b: new Hn,
                                        c: new Hn
                                    };
                                t.push(e), n.push(i)
                            }
                        }
                        const n = this.morphNormals[e];
                        t.vertices = this.morphTargets[e].vertices, t.computeFaceNormals(), t.computeVertexNormals();
                        for (let t = 0, e = this.faces.length; t < e; t++) {
                            const e = this.faces[t],
                                i = n.faceNormals[t],
                                r = n.vertexNormals[t];
                            i.copy(e.normal), r.a.copy(e.vertexNormals[0]), r.b.copy(e.vertexNormals[1]), r.c.copy(e.vertexNormals[2])
                        }
                    }
                    for (let e = 0, n = this.faces.length; e < n; e++) {
                        const t = this.faces[e];
                        t.normal = t.__originalFaceNormal, t.vertexNormals = t.__originalVertexNormals
                    }
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new jn), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new oi), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(t, e, n) {
                    if (!t || !t.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
                    let i;
                    const r = this.vertices.length,
                        s = this.vertices,
                        o = t.vertices,
                        a = this.faces,
                        l = t.faces,
                        c = this.colors,
                        h = t.colors;
                    void 0 === n && (n = 0), void 0 !== e && (i = (new On).getNormalMatrix(e));
                    for (let u = 0, d = o.length; u < d; u++) {
                        const t = o[u].clone();
                        void 0 !== e && t.applyMatrix4(e), s.push(t)
                    }
                    for (let u = 0, d = h.length; u < d; u++) c.push(h[u].clone());
                    for (let u = 0, d = l.length; u < d; u++) {
                        const t = l[u];
                        let e, s;
                        const o = t.vertexNormals,
                            c = t.vertexColors,
                            h = new cr(t.a + r, t.b + r, t.c + r);
                        h.normal.copy(t.normal), void 0 !== i && h.normal.applyMatrix3(i).normalize();
                        for (let n = 0, r = o.length; n < r; n++) e = o[n].clone(), void 0 !== i && e.applyMatrix3(i).normalize(), h.vertexNormals.push(e);
                        h.color.copy(t.color);
                        for (let n = 0, i = c.length; n < i; n++) s = c[n], h.vertexColors.push(s.clone());
                        h.materialIndex = t.materialIndex + n, a.push(h)
                    }
                    for (let u = 0, d = t.faceVertexUvs.length; u < d; u++) {
                        const e = t.faceVertexUvs[u];
                        void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []);
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t],
                                i = [];
                            for (let t = 0, e = n.length; t < e; t++) i.push(n[t].clone());
                            this.faceVertexUvs[u].push(i)
                        }
                    }
                },
                mergeMesh: function(t) {
                    t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
                },
                mergeVertices: function() {
                    const t = {},
                        e = [],
                        n = [],
                        i = Math.pow(10, 4);
                    for (let o = 0, a = this.vertices.length; o < a; o++) {
                        const r = this.vertices[o],
                            s = Math.round(r.x * i) + "_" + Math.round(r.y * i) + "_" + Math.round(r.z * i);
                        void 0 === t[s] ? (t[s] = o, e.push(this.vertices[o]), n[o] = e.length - 1) : n[o] = n[t[s]]
                    }
                    const r = [];
                    for (let o = 0, a = this.faces.length; o < a; o++) {
                        const t = this.faces[o];
                        t.a = n[t.a], t.b = n[t.b], t.c = n[t.c];
                        const e = [t.a, t.b, t.c];
                        for (let n = 0; n < 3; n++)
                            if (e[n] === e[(n + 1) % 3]) {
                                r.push(o);
                                break
                            }
                    }
                    for (let o = r.length - 1; o >= 0; o--) {
                        const t = r[o];
                        this.faces.splice(t, 1);
                        for (let e = 0, n = this.faceVertexUvs.length; e < n; e++) this.faceVertexUvs[e].splice(t, 1)
                    }
                    const s = this.vertices.length - e.length;
                    return this.vertices = e, s
                },
                setFromPoints: function(t) {
                    this.vertices = [];
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        this.vertices.push(new Hn(n.x, n.y, n.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function() {
                    const t = this.faces,
                        e = t.length;
                    for (let o = 0; o < e; o++) t[o]._id = o;
                    t.sort((function(t, e) {
                        return t.materialIndex - e.materialIndex
                    }));
                    const n = this.faceVertexUvs[0],
                        i = this.faceVertexUvs[1];
                    let r, s;
                    n && n.length === e && (r = []), i && i.length === e && (s = []);
                    for (let o = 0; o < e; o++) {
                        const e = t[o]._id;
                        r && r.push(n[e]), s && s.push(i[e])
                    }
                    r && (this.faceVertexUvs[0] = r), s && (this.faceVertexUvs[1] = s)
                },
                toJSON: function() {
                    const t = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                        const e = this.parameters;
                        for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    const e = [];
                    for (let p = 0; p < this.vertices.length; p++) {
                        const t = this.vertices[p];
                        e.push(t.x, t.y, t.z)
                    }
                    const n = [],
                        i = [],
                        r = {},
                        s = [],
                        o = {},
                        a = [],
                        l = {};
                    for (let p = 0; p < this.faces.length; p++) {
                        const t = this.faces[p],
                            e = !0,
                            i = !1,
                            r = void 0 !== this.faceVertexUvs[0][p],
                            s = t.normal.length() > 0,
                            o = t.vertexNormals.length > 0,
                            a = 1 !== t.color.r || 1 !== t.color.g || 1 !== t.color.b,
                            l = t.vertexColors.length > 0;
                        let m = 0;
                        if (m = c(m, 0, 0), m = c(m, 1, e), m = c(m, 2, i), m = c(m, 3, r), m = c(m, 4, s), m = c(m, 5, o), m = c(m, 6, a), m = c(m, 7, l), n.push(m), n.push(t.a, t.b, t.c), n.push(t.materialIndex), r) {
                            const t = this.faceVertexUvs[0][p];
                            n.push(d(t[0]), d(t[1]), d(t[2]))
                        }
                        if (s && n.push(h(t.normal)), o) {
                            const e = t.vertexNormals;
                            n.push(h(e[0]), h(e[1]), h(e[2]))
                        }
                        if (a && n.push(u(t.color)), l) {
                            const e = t.vertexColors;
                            n.push(u(e[0]), u(e[1]), u(e[2]))
                        }
                    }

                    function c(t, e, n) {
                        return n ? t | 1 << e : t & ~(1 << e)
                    }

                    function h(t) {
                        const e = t.x.toString() + t.y.toString() + t.z.toString();
                        return void 0 !== r[e] ? r[e] : (r[e] = i.length / 3, i.push(t.x, t.y, t.z), r[e])
                    }

                    function u(t) {
                        const e = t.r.toString() + t.g.toString() + t.b.toString();
                        return void 0 !== o[e] ? o[e] : (o[e] = s.length, s.push(t.getHex()), o[e])
                    }

                    function d(t) {
                        const e = t.x.toString() + t.y.toString();
                        return void 0 !== l[e] ? l[e] : (l[e] = a.length / 2, a.push(t.x, t.y), l[e])
                    }
                    return t.data = {}, t.data.vertices = e, t.data.normals = i, s.length > 0 && (t.data.colors = s), a.length > 0 && (t.data.uvs = [a]), t.data.faces = n, t
                },
                clone: function() {
                    return (new Dl).copy(this)
                },
                copy: function(t) {
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    const e = t.vertices;
                    for (let u = 0, d = e.length; u < d; u++) this.vertices.push(e[u].clone());
                    const n = t.colors;
                    for (let u = 0, d = n.length; u < d; u++) this.colors.push(n[u].clone());
                    const i = t.faces;
                    for (let u = 0, d = i.length; u < d; u++) this.faces.push(i[u].clone());
                    for (let u = 0, d = t.faceVertexUvs.length; u < d; u++) {
                        const e = t.faceVertexUvs[u];
                        void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []);
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t],
                                i = [];
                            for (let t = 0, e = n.length; t < e; t++) {
                                const e = n[t];
                                i.push(e.clone())
                            }
                            this.faceVertexUvs[u].push(i)
                        }
                    }
                    const r = t.morphTargets;
                    for (let u = 0, d = r.length; u < d; u++) {
                        const t = {};
                        if (t.name = r[u].name, void 0 !== r[u].vertices) {
                            t.vertices = [];
                            for (let e = 0, n = r[u].vertices.length; e < n; e++) t.vertices.push(r[u].vertices[e].clone())
                        }
                        if (void 0 !== r[u].normals) {
                            t.normals = [];
                            for (let e = 0, n = r[u].normals.length; e < n; e++) t.normals.push(r[u].normals[e].clone())
                        }
                        this.morphTargets.push(t)
                    }
                    const s = t.morphNormals;
                    for (let u = 0, d = s.length; u < d; u++) {
                        const t = {};
                        if (void 0 !== s[u].vertexNormals) {
                            t.vertexNormals = [];
                            for (let e = 0, n = s[u].vertexNormals.length; e < n; e++) {
                                const n = s[u].vertexNormals[e],
                                    i = {};
                                i.a = n.a.clone(), i.b = n.b.clone(), i.c = n.c.clone(), t.vertexNormals.push(i)
                            }
                        }
                        if (void 0 !== s[u].faceNormals) {
                            t.faceNormals = [];
                            for (let e = 0, n = s[u].faceNormals.length; e < n; e++) t.faceNormals.push(s[u].faceNormals[e].clone())
                        }
                        this.morphNormals.push(t)
                    }
                    const o = t.skinWeights;
                    for (let u = 0, d = o.length; u < d; u++) this.skinWeights.push(o[u].clone());
                    const a = t.skinIndices;
                    for (let u = 0, d = a.length; u < d; u++) this.skinIndices.push(a[u].clone());
                    const l = t.lineDistances;
                    for (let u = 0, d = l.length; u < d; u++) this.lineDistances.push(l[u]);
                    const c = t.boundingBox;
                    null !== c && (this.boundingBox = c.clone());
                    const h = t.boundingSphere;
                    return null !== h && (this.boundingSphere = h.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            new Hn, new Hn, new Hn, new er;
            const Fl = function(t, e, n) {
                n = n || 2;
                const i = e && e.length,
                    r = i ? e[0] * n : t.length;
                let s = Ul(t, 0, r, n, !0);
                const o = [];
                if (!s || s.next === s.prev) return o;
                let a, l, c, h, u, d, p;
                if (i && (s = function(t, e, n, i) {
                        const r = [];
                        let s, o, a, l, c;
                        for (s = 0, o = e.length; s < o; s++) a = e[s] * i, l = s < o - 1 ? e[s + 1] * i : t.length, c = Ul(t, a, l, i, !1), c === c.next && (c.steiner = !0), r.push(Yl(c));
                        for (r.sort(jl), s = 0; s < r.length; s++) Wl(r[s], n), n = zl(n, n.next);
                        return n
                    }(t, e, s, n)), t.length > 80 * n) {
                    a = c = t[0], l = h = t[1];
                    for (let e = n; e < r; e += n) u = t[e], d = t[e + 1], u < a && (a = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
                    p = Math.max(c - a, h - l), p = 0 !== p ? 1 / p : 0
                }
                return kl(s, o, n, a, l, p), o
            };

            function Ul(t, e, n, i, r) {
                let s, o;
                if (r === function(t, e, n, i) {
                        let r = 0;
                        for (let s = e, o = n - i; s < n; s += i) r += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s;
                        return r
                    }(t, e, n, i) > 0)
                    for (s = e; s < n; s += i) o = rc(s, t[s], t[s + 1], o);
                else
                    for (s = n - i; s >= e; s -= i) o = rc(s, t[s], t[s + 1], o);
                return o && $l(o, o.next) && (sc(o), o = o.next), o
            }

            function zl(t, e) {
                if (!t) return t;
                e || (e = t);
                let n, i = t;
                do {
                    if (n = !1, i.steiner || !$l(i, i.next) && 0 !== Kl(i.prev, i, i.next)) i = i.next;
                    else {
                        if (sc(i), i = e = i.prev, i === i.next) break;
                        n = !0
                    }
                } while (n || i !== e);
                return e
            }

            function kl(t, e, n, i, r, s, o) {
                if (!t) return;
                !o && s && function(t, e, n, i) {
                    let r = t;
                    do {
                        null === r.z && (r.z = Xl(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                    } while (r !== t);
                    r.prevZ.nextZ = null, r.prevZ = null,
                        function(t) {
                            let e, n, i, r, s, o, a, l, c = 1;
                            do {
                                for (n = t, t = null, s = null, o = 0; n;) {
                                    for (o++, i = n, a = 0, e = 0; e < c && (a++, i = i.nextZ, i); e++);
                                    for (l = c; a > 0 || l > 0 && i;) 0 !== a && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : t = r, r.prevZ = s, s = r;
                                    n = i
                                }
                                s.nextZ = null, c *= 2
                            } while (o > 1)
                        }(r)
                }(t, i, r, s);
                let a, l, c = t;
                for (; t.prev !== t.next;)
                    if (a = t.prev, l = t.next, s ? Hl(t, i, r, s) : Bl(t)) e.push(a.i / n), e.push(t.i / n), e.push(l.i / n), sc(t), t = l.next, c = l.next;
                    else if ((t = l) === c) {
                    o ? 1 === o ? kl(t = Gl(zl(t), e, n), e, n, i, r, s, 2) : 2 === o && Vl(t, e, n, i, r, s) : kl(zl(t), e, n, i, r, s, 1);
                    break
                }
            }

            function Bl(t) {
                const e = t.prev,
                    n = t,
                    i = t.next;
                if (Kl(e, n, i) >= 0) return !1;
                let r = t.next.next;
                for (; r !== t.prev;) {
                    if (Jl(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Kl(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function Hl(t, e, n, i) {
                const r = t.prev,
                    s = t,
                    o = t.next;
                if (Kl(r, s, o) >= 0) return !1;
                const a = r.x < s.x ? r.x < o.x ? r.x : o.x : s.x < o.x ? s.x : o.x,
                    l = r.y < s.y ? r.y < o.y ? r.y : o.y : s.y < o.y ? s.y : o.y,
                    c = r.x > s.x ? r.x > o.x ? r.x : o.x : s.x > o.x ? s.x : o.x,
                    h = r.y > s.y ? r.y > o.y ? r.y : o.y : s.y > o.y ? s.y : o.y,
                    u = Xl(a, l, e, n, i),
                    d = Xl(c, h, e, n, i);
                let p = t.prevZ,
                    m = t.nextZ;
                for (; p && p.z >= u && m && m.z <= d;) {
                    if (p !== t.prev && p !== t.next && Jl(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && Kl(p.prev, p, p.next) >= 0) return !1;
                    if (p = p.prevZ, m !== t.prev && m !== t.next && Jl(r.x, r.y, s.x, s.y, o.x, o.y, m.x, m.y) && Kl(m.prev, m, m.next) >= 0) return !1;
                    m = m.nextZ
                }
                for (; p && p.z >= u;) {
                    if (p !== t.prev && p !== t.next && Jl(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && Kl(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ
                }
                for (; m && m.z <= d;) {
                    if (m !== t.prev && m !== t.next && Jl(r.x, r.y, s.x, s.y, o.x, o.y, m.x, m.y) && Kl(m.prev, m, m.next) >= 0) return !1;
                    m = m.nextZ
                }
                return !0
            }

            function Gl(t, e, n) {
                let i = t;
                do {
                    const r = i.prev,
                        s = i.next.next;
                    !$l(r, s) && Ql(r, i, i.next, s) && nc(r, s) && nc(s, r) && (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), sc(i), sc(i.next), i = t = s), i = i.next
                } while (i !== t);
                return zl(i)
            }

            function Vl(t, e, n, i, r, s) {
                let o = t;
                do {
                    let t = o.next.next;
                    for (; t !== o.prev;) {
                        if (o.i !== t.i && Zl(o, t)) {
                            let a = ic(o, t);
                            return o = zl(o, o.next), a = zl(a, a.next), kl(o, e, n, i, r, s), void kl(a, e, n, i, r, s)
                        }
                        t = t.next
                    }
                    o = o.next
                } while (o !== t)
            }

            function jl(t, e) {
                return t.x - e.x
            }

            function Wl(t, e) {
                if (e = function(t, e) {
                        let n = e;
                        const i = t.x,
                            r = t.y;
                        let s, o = -1 / 0;
                        do {
                            if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                                const t = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                if (t <= i && t > o) {
                                    if (o = t, t === i) {
                                        if (r === n.y) return n;
                                        if (r === n.next.y) return n.next
                                    }
                                    s = n.x < n.next.x ? n : n.next
                                }
                            }
                            n = n.next
                        } while (n !== e);
                        if (!s) return null;
                        if (i === o) return s;
                        const a = s,
                            l = s.x,
                            c = s.y;
                        let h, u = 1 / 0;
                        n = s;
                        do {
                            i >= n.x && n.x >= l && i !== n.x && Jl(r < c ? i : o, r, l, c, r < c ? o : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), nc(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && ql(s, n))) && (s = n, u = h)), n = n.next
                        } while (n !== a);
                        return s
                    }(t, e)) {
                    const n = ic(e, t);
                    zl(e, e.next), zl(n, n.next)
                }
            }

            function ql(t, e) {
                return Kl(t.prev, t, e.prev) < 0 && Kl(e.next, t, t.next) < 0
            }

            function Xl(t, e, n, i, r) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }

            function Yl(t) {
                let e = t,
                    n = t;
                do {
                    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                } while (e !== t);
                return n
            }

            function Jl(t, e, n, i, r, s, o, a) {
                return (r - o) * (e - a) - (t - o) * (s - a) >= 0 && (t - o) * (i - a) - (n - o) * (e - a) >= 0 && (n - o) * (s - a) - (r - o) * (i - a) >= 0
            }

            function Zl(t, e) {
                return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                    let n = t;
                    do {
                        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Ql(n, n.next, t, e)) return !0;
                        n = n.next
                    } while (n !== t);
                    return !1
                }(t, e) && (nc(t, e) && nc(e, t) && function(t, e) {
                    let n = t,
                        i = !1;
                    const r = (t.x + e.x) / 2,
                        s = (t.y + e.y) / 2;
                    do {
                        n.y > s !== n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                    } while (n !== t);
                    return i
                }(t, e) && (Kl(t.prev, t, e.prev) || Kl(t, e.prev, e)) || $l(t, e) && Kl(t.prev, t, t.next) > 0 && Kl(e.prev, e, e.next) > 0)
            }

            function Kl(t, e, n) {
                return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
            }

            function $l(t, e) {
                return t.x === e.x && t.y === e.y
            }

            function Ql(t, e, n, i) {
                const r = ec(Kl(t, e, n)),
                    s = ec(Kl(t, e, i)),
                    o = ec(Kl(n, i, t)),
                    a = ec(Kl(n, i, e));
                return r !== s && o !== a || (!(0 !== r || !tc(t, n, e)) || (!(0 !== s || !tc(t, i, e)) || (!(0 !== o || !tc(n, t, i)) || !(0 !== a || !tc(n, e, i)))))
            }

            function tc(t, e, n) {
                return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
            }

            function ec(t) {
                return t > 0 ? 1 : t < 0 ? -1 : 0
            }

            function nc(t, e) {
                return Kl(t.prev, t, t.next) < 0 ? Kl(t, e, t.next) >= 0 && Kl(t, t.prev, e) >= 0 : Kl(t, e, t.prev) < 0 || Kl(t, t.next, e) < 0
            }

            function ic(t, e) {
                const n = new oc(t.i, t.x, t.y),
                    i = new oc(e.i, e.x, e.y),
                    r = t.next,
                    s = e.prev;
                return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, s.next = i, i.prev = s, i
            }

            function rc(t, e, n, i) {
                const r = new oc(t, e, n);
                return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
            }

            function sc(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }

            function oc(t, e, n) {
                this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            const ac = {
                area: function(t) {
                    const e = t.length;
                    let n = 0;
                    for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
                    return .5 * n
                },
                isClockWise: function(t) {
                    return ac.area(t) < 0
                },
                triangulateShape: function(t, e) {
                    const n = [],
                        i = [],
                        r = [];
                    lc(t), cc(n, t);
                    let s = t.length;
                    e.forEach(lc);
                    for (let a = 0; a < e.length; a++) i.push(s), s += e[a].length, cc(n, e[a]);
                    const o = Fl(n, i);
                    for (let a = 0; a < o.length; a += 3) r.push(o.slice(a, a + 3));
                    return r
                }
            };

            function lc(t) {
                const e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop()
            }

            function cc(t, e) {
                for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
            }
            class hc extends Nr {
                constructor(t, e) {
                    super(), this.type = "ExtrudeBufferGeometry", this.parameters = {
                        shapes: t,
                        options: e
                    }, t = Array.isArray(t) ? t : [t];
                    const n = this,
                        i = [],
                        r = [];
                    for (let o = 0, a = t.length; o < a; o++) {
                        s(t[o])
                    }

                    function s(t) {
                        const s = [],
                            o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                            a = void 0 !== e.steps ? e.steps : 1;
                        let l = void 0 !== e.depth ? e.depth : 100,
                            c = void 0 === e.bevelEnabled || e.bevelEnabled,
                            h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                            u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
                            d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                            p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                        const m = e.extrudePath,
                            f = void 0 !== e.UVGenerator ? e.UVGenerator : uc;
                        void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
                        let g, v, y, x, b, _ = !1;
                        m && (g = m.getSpacedPoints(a), _ = !0, c = !1, v = m.computeFrenetFrames(a, !1), y = new Hn, x = new Hn, b = new Hn), c || (p = 0, h = 0, u = 0, d = 0);
                        const w = t.extractPoints(o);
                        let M = w.shape;
                        const S = w.holes;
                        if (!ac.isClockWise(M)) {
                            M = M.reverse();
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                ac.isClockWise(e) && (S[t] = e.reverse())
                            }
                        }
                        const T = ac.triangulateShape(M, S),
                            E = M;
                        for (let e = 0, n = S.length; e < n; e++) {
                            const t = S[e];
                            M = M.concat(t)
                        }

                        function A(t, e, n) {
                            return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
                        }
                        const L = M.length,
                            R = T.length;

                        function P(t, e, n) {
                            let i, r, s;
                            const o = t.x - e.x,
                                a = t.y - e.y,
                                l = n.x - t.x,
                                c = n.y - t.y,
                                h = o * o + a * a,
                                u = o * c - a * l;
                            if (Math.abs(u) > Number.EPSILON) {
                                const u = Math.sqrt(h),
                                    d = Math.sqrt(l * l + c * c),
                                    p = e.x - a / u,
                                    m = e.y + o / u,
                                    f = ((n.x - c / d - p) * c - (n.y + l / d - m) * l) / (o * c - a * l);
                                i = p + o * f - t.x, r = m + a * f - t.y;
                                const g = i * i + r * r;
                                if (g <= 2) return new Cn(i, r);
                                s = Math.sqrt(g / 2)
                            } else {
                                let t = !1;
                                o > Number.EPSILON ? l > Number.EPSILON && (t = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(c) && (t = !0), t ? (i = -a, r = o, s = Math.sqrt(h)) : (i = o, r = a, s = Math.sqrt(h / 2))
                            }
                            return new Cn(i / s, r / s)
                        }
                        const C = [];
                        for (let e = 0, n = E.length, i = n - 1, r = e + 1; e < n; e++, i++, r++) i === n && (i = 0), r === n && (r = 0), C[e] = P(E[e], E[i], E[r]);
                        const O = [];
                        let I, N = C.concat();
                        for (let e = 0, n = S.length; e < n; e++) {
                            const t = S[e];
                            I = [];
                            for (let e = 0, n = t.length, i = n - 1, r = e + 1; e < n; e++, i++, r++) i === n && (i = 0), r === n && (r = 0), I[e] = P(t[e], t[i], t[r]);
                            O.push(I), N = N.concat(I)
                        }
                        for (let e = 0; e < p; e++) {
                            const t = e / p,
                                n = h * Math.cos(t * Math.PI / 2),
                                i = u * Math.sin(t * Math.PI / 2) + d;
                            for (let e = 0, r = E.length; e < r; e++) {
                                const t = A(E[e], C[e], i);
                                U(t.x, t.y, -n)
                            }
                            for (let e = 0, r = S.length; e < r; e++) {
                                const t = S[e];
                                I = O[e];
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = A(t[e], I[e], i);
                                    U(r.x, r.y, -n)
                                }
                            }
                        }
                        const D = u + d;
                        for (let e = 0; e < L; e++) {
                            const t = c ? A(M[e], N[e], D) : M[e];
                            _ ? (x.copy(v.normals[0]).multiplyScalar(t.x), y.copy(v.binormals[0]).multiplyScalar(t.y), b.copy(g[0]).add(x).add(y), U(b.x, b.y, b.z)) : U(t.x, t.y, 0)
                        }
                        for (let e = 1; e <= a; e++)
                            for (let t = 0; t < L; t++) {
                                const n = c ? A(M[t], N[t], D) : M[t];
                                _ ? (x.copy(v.normals[e]).multiplyScalar(n.x), y.copy(v.binormals[e]).multiplyScalar(n.y), b.copy(g[e]).add(x).add(y), U(b.x, b.y, b.z)) : U(n.x, n.y, l / a * e)
                            }
                        for (let e = p - 1; e >= 0; e--) {
                            const t = e / p,
                                n = h * Math.cos(t * Math.PI / 2),
                                i = u * Math.sin(t * Math.PI / 2) + d;
                            for (let e = 0, r = E.length; e < r; e++) {
                                const t = A(E[e], C[e], i);
                                U(t.x, t.y, l + n)
                            }
                            for (let e = 0, r = S.length; e < r; e++) {
                                const t = S[e];
                                I = O[e];
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = A(t[e], I[e], i);
                                    _ ? U(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : U(r.x, r.y, l + n)
                                }
                            }
                        }

                        function F(t, e) {
                            let n = t.length;
                            for (; --n >= 0;) {
                                const i = n;
                                let r = n - 1;
                                r < 0 && (r = t.length - 1);
                                for (let t = 0, n = a + 2 * p; t < n; t++) {
                                    const n = L * t,
                                        s = L * (t + 1);
                                    k(e + i + n, e + r + n, e + r + s, e + i + s)
                                }
                            }
                        }

                        function U(t, e, n) {
                            s.push(t), s.push(e), s.push(n)
                        }

                        function z(t, e, r) {
                            B(t), B(e), B(r);
                            const s = i.length / 3,
                                o = f.generateTopUV(n, i, s - 3, s - 2, s - 1);
                            H(o[0]), H(o[1]), H(o[2])
                        }

                        function k(t, e, r, s) {
                            B(t), B(e), B(s), B(e), B(r), B(s);
                            const o = i.length / 3,
                                a = f.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
                            H(a[0]), H(a[1]), H(a[3]), H(a[1]), H(a[2]), H(a[3])
                        }

                        function B(t) {
                            i.push(s[3 * t + 0]), i.push(s[3 * t + 1]), i.push(s[3 * t + 2])
                        }

                        function H(t) {
                            r.push(t.x), r.push(t.y)
                        }! function() {
                            const t = i.length / 3;
                            if (c) {
                                let t = 0,
                                    e = L * t;
                                for (let n = 0; n < R; n++) {
                                    const t = T[n];
                                    z(t[2] + e, t[1] + e, t[0] + e)
                                }
                                t = a + 2 * p, e = L * t;
                                for (let n = 0; n < R; n++) {
                                    const t = T[n];
                                    z(t[0] + e, t[1] + e, t[2] + e)
                                }
                            } else {
                                for (let t = 0; t < R; t++) {
                                    const e = T[t];
                                    z(e[2], e[1], e[0])
                                }
                                for (let t = 0; t < R; t++) {
                                    const e = T[t];
                                    z(e[0] + L * a, e[1] + L * a, e[2] + L * a)
                                }
                            }
                            n.addGroup(t, i.length / 3 - t, 0)
                        }(),
                        function() {
                            const t = i.length / 3;
                            let e = 0;
                            F(E, e), e += E.length;
                            for (let n = 0, i = S.length; n < i; n++) {
                                const t = S[n];
                                F(t, e), e += t.length
                            }
                            n.addGroup(t, i.length / 3 - t, 1)
                        }()
                    }
                    this.setAttribute("position", new Mr(i, 3)), this.setAttribute("uv", new Mr(r, 2)), this.computeVertexNormals()
                }
                toJSON() {
                    const t = Nr.prototype.toJSON.call(this);
                    return function(t, e, n) {
                        if (n.shapes = [], Array.isArray(t))
                            for (let i = 0, r = t.length; i < r; i++) {
                                const e = t[i];
                                n.shapes.push(e.uuid)
                            } else n.shapes.push(t.uuid);
                        void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON());
                        return n
                    }(this.parameters.shapes, this.parameters.options, t)
                }
            }
            const uc = {
                generateTopUV: function(t, e, n, i, r) {
                    const s = e[3 * n],
                        o = e[3 * n + 1],
                        a = e[3 * i],
                        l = e[3 * i + 1],
                        c = e[3 * r],
                        h = e[3 * r + 1];
                    return [new Cn(s, o), new Cn(a, l), new Cn(c, h)]
                },
                generateSideWallUV: function(t, e, n, i, r, s) {
                    const o = e[3 * n],
                        a = e[3 * n + 1],
                        l = e[3 * n + 2],
                        c = e[3 * i],
                        h = e[3 * i + 1],
                        u = e[3 * i + 2],
                        d = e[3 * r],
                        p = e[3 * r + 1],
                        m = e[3 * r + 2],
                        f = e[3 * s],
                        g = e[3 * s + 1],
                        v = e[3 * s + 2];
                    return Math.abs(a - h) < .01 ? [new Cn(o, 1 - l), new Cn(c, 1 - u), new Cn(d, 1 - m), new Cn(f, 1 - v)] : [new Cn(a, 1 - l), new Cn(h, 1 - u), new Cn(p, 1 - m), new Cn(g, 1 - v)]
                }
            };
            class dc extends Dl {
                constructor(t, e) {
                    super(), this.type = "ExtrudeGeometry", this.parameters = {
                        shapes: t,
                        options: e
                    }, this.fromBufferGeometry(new hc(t, e)), this.mergeVertices()
                }
                toJSON() {
                    const t = super.toJSON();
                    return function(t, e, n) {
                        if (n.shapes = [], Array.isArray(t))
                            for (let i = 0, r = t.length; i < r; i++) {
                                const e = t[i];
                                n.shapes.push(e.uuid)
                            } else n.shapes.push(t.uuid);
                        void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON());
                        return n
                    }(this.parameters.shapes, this.parameters.options, t)
                }
            }

            function pc(t, e, n) {
                Nr.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                };
                const i = [],
                    r = [],
                    s = [],
                    o = [],
                    a = new Hn,
                    l = new Hn,
                    c = new Hn,
                    h = new Hn,
                    u = new Hn;
                t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                const d = e + 1;
                for (let p = 0; p <= n; p++) {
                    const i = p / n;
                    for (let n = 0; n <= e; n++) {
                        const d = n / e;
                        t(d, i, l), r.push(l.x, l.y, l.z), d - 1e-5 >= 0 ? (t(d - 1e-5, i, c), h.subVectors(l, c)) : (t(d + 1e-5, i, c), h.subVectors(c, l)), i - 1e-5 >= 0 ? (t(d, i - 1e-5, c), u.subVectors(l, c)) : (t(d, i + 1e-5, c), u.subVectors(c, l)), a.crossVectors(h, u).normalize(), s.push(a.x, a.y, a.z), o.push(d, i)
                    }
                }
                for (let p = 0; p < n; p++)
                    for (let t = 0; t < e; t++) {
                        const e = p * d + t,
                            n = p * d + t + 1,
                            r = (p + 1) * d + t + 1,
                            s = (p + 1) * d + t;
                        i.push(e, n, s), i.push(n, r, s)
                    }
                this.setIndex(i), this.setAttribute("position", new Mr(r, 3)), this.setAttribute("normal", new Mr(s, 3)), this.setAttribute("uv", new Mr(o, 2))
            }

            function mc(t, e, n) {
                Dl.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                }, this.fromBufferGeometry(new pc(t, e, n)), this.mergeVertices()
            }
            pc.prototype = Object.create(Nr.prototype), pc.prototype.constructor = pc, mc.prototype = Object.create(Dl.prototype), mc.prototype.constructor = mc;
            class fc extends Nr {
                constructor(t, e) {
                    super(), this.type = "ShapeBufferGeometry", this.parameters = {
                        shapes: t,
                        curveSegments: e
                    }, e = e || 12;
                    const n = [],
                        i = [],
                        r = [],
                        s = [];
                    let o = 0,
                        a = 0;
                    if (!1 === Array.isArray(t)) l(t);
                    else
                        for (let c = 0; c < t.length; c++) l(t[c]), this.addGroup(o, a, c), o += a, a = 0;

                    function l(t) {
                        const o = i.length / 3,
                            l = t.extractPoints(e);
                        let c = l.shape;
                        const h = l.holes;
                        !1 === ac.isClockWise(c) && (c = c.reverse());
                        for (let e = 0, n = h.length; e < n; e++) {
                            const t = h[e];
                            !0 === ac.isClockWise(t) && (h[e] = t.reverse())
                        }
                        const u = ac.triangulateShape(c, h);
                        for (let e = 0, n = h.length; e < n; e++) {
                            const t = h[e];
                            c = c.concat(t)
                        }
                        for (let e = 0, n = c.length; e < n; e++) {
                            const t = c[e];
                            i.push(t.x, t.y, 0), r.push(0, 0, 1), s.push(t.x, t.y)
                        }
                        for (let e = 0, i = u.length; e < i; e++) {
                            const t = u[e],
                                i = t[0] + o,
                                r = t[1] + o,
                                s = t[2] + o;
                            n.push(i, r, s), a += 3
                        }
                    }
                    this.setIndex(n), this.setAttribute("position", new Mr(i, 3)), this.setAttribute("normal", new Mr(r, 3)), this.setAttribute("uv", new Mr(s, 2))
                }
                toJSON() {
                    const t = Nr.prototype.toJSON.call(this);
                    return function(t, e) {
                        if (e.shapes = [], Array.isArray(t))
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = t[n];
                                e.shapes.push(i.uuid)
                            } else e.shapes.push(t.uuid);
                        return e
                    }(this.parameters.shapes, t)
                }
            }
            class gc extends Dl {
                constructor(t, e) {
                    super(), this.type = "ShapeGeometry", "object" === typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                        shapes: t,
                        curveSegments: e
                    }, this.fromBufferGeometry(new fc(t, e)), this.mergeVertices()
                }
                toJSON() {
                    const t = Dl.prototype.toJSON.call(this);
                    return function(t, e) {
                        if (e.shapes = [], Array.isArray(t))
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = t[n];
                                e.shapes.push(i.uuid)
                            } else e.shapes.push(t.uuid);
                        return e
                    }(this.parameters.shapes, t)
                }
            }

            function vc(t) {
                ur.call(this), this.type = "ShadowMaterial", this.color = new lr(0), this.transparent = !0, this.setValues(t)
            }

            function yc(t) {
                as.call(this, t), this.type = "RawShaderMaterial"
            }

            function xc(t) {
                ur.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new lr(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new lr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _n, this.normalScale = new Cn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t)
            }

            function bc(t) {
                xc.call(this), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Cn(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", {
                    get: function() {
                        return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
                    },
                    set: function(t) {
                        this.reflectivity = Pn.clamp(2.5 * (t - 1) / (t + 1), 0, 1)
                    }
                }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t)
            }

            function _c(t) {
                ur.call(this), this.type = "MeshPhongMaterial", this.color = new lr(16777215), this.specular = new lr(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new lr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _n, this.normalScale = new Cn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = yt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function wc(t) {
                ur.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.color = new lr(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new lr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _n, this.normalScale = new Cn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Mc(t) {
                ur.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _n, this.normalScale = new Cn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Sc(t) {
                ur.call(this), this.type = "MeshLambertMaterial", this.color = new lr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new lr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = yt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Tc(t) {
                ur.call(this), this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new lr(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = _n, this.normalScale = new Cn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Ec(t) {
                cl.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
            }
            vc.prototype = Object.create(ur.prototype), vc.prototype.constructor = vc, vc.prototype.isShadowMaterial = !0, vc.prototype.copy = function(t) {
                return ur.prototype.copy.call(this, t), this.color.copy(t.color), this
            }, yc.prototype = Object.create(as.prototype), yc.prototype.constructor = yc, yc.prototype.isRawShaderMaterial = !0, xc.prototype = Object.create(ur.prototype), xc.prototype.constructor = xc, xc.prototype.isMeshStandardMaterial = !0, xc.prototype.copy = function(t) {
                return ur.prototype.copy.call(this, t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this
            }, bc.prototype = Object.create(xc.prototype), bc.prototype.constructor = bc, bc.prototype.isMeshPhysicalMaterial = !0, bc.prototype.copy = function(t) {
                return xc.prototype.copy.call(this, t), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new lr).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this
            }, _c.prototype = Object.create(ur.prototype), _c.prototype.constructor = _c, _c.prototype.isMeshPhongMaterial = !0, _c.prototype.copy = function(t) {
                return ur.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, wc.prototype = Object.create(ur.prototype), wc.prototype.constructor = wc, wc.prototype.isMeshToonMaterial = !0, wc.prototype.copy = function(t) {
                return ur.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Mc.prototype = Object.create(ur.prototype), Mc.prototype.constructor = Mc, Mc.prototype.isMeshNormalMaterial = !0, Mc.prototype.copy = function(t) {
                return ur.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Sc.prototype = Object.create(ur.prototype), Sc.prototype.constructor = Sc, Sc.prototype.isMeshLambertMaterial = !0, Sc.prototype.copy = function(t) {
                return ur.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Tc.prototype = Object.create(ur.prototype), Tc.prototype.constructor = Tc, Tc.prototype.isMeshMatcapMaterial = !0, Tc.prototype.copy = function(t) {
                return ur.prototype.copy.call(this, t), this.defines = {
                    MATCAP: ""
                }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Ec.prototype = Object.create(cl.prototype), Ec.prototype.constructor = Ec, Ec.prototype.isLineDashedMaterial = !0, Ec.prototype.copy = function(t) {
                return cl.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
            };
            var Ac = Object.freeze({
                __proto__: null,
                ShadowMaterial: vc,
                SpriteMaterial: Na,
                RawShaderMaterial: yc,
                ShaderMaterial: as,
                PointsMaterial: bl,
                MeshPhysicalMaterial: bc,
                MeshStandardMaterial: xc,
                MeshPhongMaterial: _c,
                MeshToonMaterial: wc,
                MeshNormalMaterial: Mc,
                MeshLambertMaterial: Sc,
                MeshDepthMaterial: fa,
                MeshDistanceMaterial: ga,
                MeshBasicMaterial: dr,
                MeshMatcapMaterial: Tc,
                LineDashedMaterial: Ec,
                LineBasicMaterial: cl,
                Material: ur
            });
            const Lc = {
                arraySlice: function(t, e, n) {
                    return Lc.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
                },
                convertArray: function(t, e, n) {
                    return !t || !n && t.constructor === e ? t : "number" === typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                },
                isTypedArray: function(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView)
                },
                getKeyframeOrder: function(t) {
                    const e = t.length,
                        n = new Array(e);
                    for (let i = 0; i !== e; ++i) n[i] = i;
                    return n.sort((function(e, n) {
                        return t[e] - t[n]
                    })), n
                },
                sortedArray: function(t, e, n) {
                    const i = t.length,
                        r = new t.constructor(i);
                    for (let s = 0, o = 0; o !== i; ++s) {
                        const i = n[s] * e;
                        for (let n = 0; n !== e; ++n) r[o++] = t[i + n]
                    }
                    return r
                },
                flattenJSON: function(t, e, n, i) {
                    let r = 1,
                        s = t[0];
                    for (; void 0 !== s && void 0 === s[i];) s = t[r++];
                    if (void 0 === s) return;
                    let o = s[i];
                    if (void 0 !== o)
                        if (Array.isArray(o))
                            do {
                                o = s[i], void 0 !== o && (e.push(s.time), n.push.apply(n, o)), s = t[r++]
                            } while (void 0 !== s);
                        else if (void 0 !== o.toArray)
                        do {
                            o = s[i], void 0 !== o && (e.push(s.time), o.toArray(n, n.length)), s = t[r++]
                        } while (void 0 !== s);
                    else
                        do {
                            o = s[i], void 0 !== o && (e.push(s.time), n.push(o)), s = t[r++]
                        } while (void 0 !== s)
                },
                subclip: function(t, e, n, i, r) {
                    r = r || 30;
                    const s = t.clone();
                    s.name = e;
                    const o = [];
                    for (let l = 0; l < s.tracks.length; ++l) {
                        const t = s.tracks[l],
                            e = t.getValueSize(),
                            a = [],
                            c = [];
                        for (let s = 0; s < t.times.length; ++s) {
                            const o = t.times[s] * r;
                            if (!(o < n || o >= i)) {
                                a.push(t.times[s]);
                                for (let n = 0; n < e; ++n) c.push(t.values[s * e + n])
                            }
                        }
                        0 !== a.length && (t.times = Lc.convertArray(a, t.times.constructor), t.values = Lc.convertArray(c, t.values.constructor), o.push(t))
                    }
                    s.tracks = o;
                    let a = 1 / 0;
                    for (let l = 0; l < s.tracks.length; ++l) a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
                    for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
                    return s.resetDuration(), s
                },
                makeClipAdditive: function(t, e, n, i) {
                    void 0 === e && (e = 0), void 0 === n && (n = t), (void 0 === i || i <= 0) && (i = 30);
                    const r = n.tracks.length,
                        s = e / i;
                    for (let o = 0; o < r; ++o) {
                        const e = n.tracks[o],
                            i = e.ValueTypeName;
                        if ("bool" === i || "string" === i) continue;
                        const r = t.tracks.find((function(t) {
                            return t.name === e.name && t.ValueTypeName === i
                        }));
                        if (void 0 === r) continue;
                        let a = 0;
                        const l = e.getValueSize();
                        e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
                        let c = 0;
                        const h = r.getValueSize();
                        r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                        const u = e.times.length - 1;
                        let d;
                        if (s <= e.times[0]) {
                            const t = a,
                                n = l - a;
                            d = Lc.arraySlice(e.values, t, n)
                        } else if (s >= e.times[u]) {
                            const t = u * l + a,
                                n = t + l - a;
                            d = Lc.arraySlice(e.values, t, n)
                        } else {
                            const t = e.createInterpolant(),
                                n = a,
                                i = l - a;
                            t.evaluate(s), d = Lc.arraySlice(t.resultBuffer, n, i)
                        }
                        if ("quaternion" === i) {
                            (new Bn).fromArray(d).normalize().conjugate().toArray(d)
                        }
                        const p = r.times.length;
                        for (let t = 0; t < p; ++t) {
                            const e = t * h + c;
                            if ("quaternion" === i) Bn.multiplyQuaternionsFlat(r.values, e, d, 0, r.values, e);
                            else {
                                const t = h - 2 * c;
                                for (let n = 0; n < t; ++n) r.values[e + n] -= d[n]
                            }
                        }
                    }
                    return t.blendMode = cn, t
                }
            };

            function Rc(t, e, n, i) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n
            }

            function Pc(t, e, n, i) {
                Rc.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function Cc(t, e, n, i) {
                Rc.call(this, t, e, n, i)
            }

            function Oc(t, e, n, i) {
                Rc.call(this, t, e, n, i)
            }

            function Ic(t, e, n, i) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = Lc.convertArray(e, this.TimeBufferType), this.values = Lc.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
            }

            function Nc(t, e, n) {
                Ic.call(this, t, e, n)
            }

            function Dc(t, e, n, i) {
                Ic.call(this, t, e, n, i)
            }

            function Fc(t, e, n, i) {
                Ic.call(this, t, e, n, i)
            }

            function Uc(t, e, n, i) {
                Rc.call(this, t, e, n, i)
            }

            function zc(t, e, n, i) {
                Ic.call(this, t, e, n, i)
            }

            function kc(t, e, n, i) {
                Ic.call(this, t, e, n, i)
            }

            function Bc(t, e, n, i) {
                Ic.call(this, t, e, n, i)
            }

            function Hc(t, e, n, i) {
                this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.blendMode = void 0 !== i ? i : ln, this.uuid = Pn.generateUUID(), this.duration < 0 && this.resetDuration()
            }

            function Gc(t) {
                if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                const e = function(t) {
                    switch (t.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return Fc;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return Bc;
                        case "color":
                            return Dc;
                        case "quaternion":
                            return zc;
                        case "bool":
                        case "boolean":
                            return Nc;
                        case "string":
                            return kc
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                }(t.type);
                if (void 0 === t.times) {
                    const e = [],
                        n = [];
                    Lc.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            }
            Object.assign(Rc.prototype, {
                evaluate: function(t) {
                    const e = this.parameterPositions;
                    let n = this._cachedIndex,
                        i = e[n],
                        r = e[n - 1];
                    t: {
                        e: {
                            let s;n: {
                                i: if (!(t < i)) {
                                    for (let s = n + 2;;) {
                                        if (void 0 === i) {
                                            if (t < r) break i;
                                            return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r)
                                        }
                                        if (n === s) break;
                                        if (r = i, i = e[++n], t < i) break e
                                    }
                                    s = e.length;
                                    break n
                                }if (t >= r) break t; {
                                    const o = e[1];
                                    t < o && (n = 2, r = o);
                                    for (let s = n - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                        if (n === s) break;
                                        if (i = r, r = e[--n - 1], t >= r) break e
                                    }
                                    s = n, n = 0
                                }
                            }
                            for (; n < s;) {
                                const i = n + s >>> 1;
                                t < e[i] ? s = i : n = i + 1
                            }
                            if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                            if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, r, i)
                    }
                    return this.interpolate_(n, r, t, i)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function() {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function(t) {
                    const e = this.resultBuffer,
                        n = this.sampleValues,
                        i = this.valueSize,
                        r = t * i;
                    for (let s = 0; s !== i; ++s) e[s] = n[r + s];
                    return e
                },
                interpolate_: function() {
                    throw new Error("call to abstract method")
                },
                intervalChanged_: function() {}
            }), Object.assign(Rc.prototype, {
                beforeStart_: Rc.prototype.copySampleValue_,
                afterEnd_: Rc.prototype.copySampleValue_
            }), Pc.prototype = Object.assign(Object.create(Rc.prototype), {
                constructor: Pc,
                DefaultSettings_: {
                    endingStart: sn,
                    endingEnd: sn
                },
                intervalChanged_: function(t, e, n) {
                    const i = this.parameterPositions;
                    let r = t - 2,
                        s = t + 1,
                        o = i[r],
                        a = i[s];
                    if (void 0 === o) switch (this.getSettings_().endingStart) {
                        case on:
                            r = t, o = 2 * e - n;
                            break;
                        case an:
                            r = i.length - 2, o = e + i[r] - i[r + 1];
                            break;
                        default:
                            r = t, o = n
                    }
                    if (void 0 === a) switch (this.getSettings_().endingEnd) {
                        case on:
                            s = t, a = 2 * n - e;
                            break;
                        case an:
                            s = 1, a = n + i[1] - i[0];
                            break;
                        default:
                            s = t - 1, a = e
                    }
                    const l = .5 * (n - e),
                        c = this.valueSize;
                    this._weightPrev = l / (e - o), this._weightNext = l / (a - n), this._offsetPrev = r * c, this._offsetNext = s * c
                },
                interpolate_: function(t, e, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = t * o,
                        l = a - o,
                        c = this._offsetPrev,
                        h = this._offsetNext,
                        u = this._weightPrev,
                        d = this._weightNext,
                        p = (n - e) / (i - e),
                        m = p * p,
                        f = m * p,
                        g = -u * f + 2 * u * m - u * p,
                        v = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1,
                        y = (-1 - d) * f + (1.5 + d) * m + .5 * p,
                        x = d * f - d * m;
                    for (let b = 0; b !== o; ++b) r[b] = g * s[c + b] + v * s[l + b] + y * s[a + b] + x * s[h + b];
                    return r
                }
            }), Cc.prototype = Object.assign(Object.create(Rc.prototype), {
                constructor: Cc,
                interpolate_: function(t, e, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = t * o,
                        l = a - o,
                        c = (n - e) / (i - e),
                        h = 1 - c;
                    for (let u = 0; u !== o; ++u) r[u] = s[l + u] * h + s[a + u] * c;
                    return r
                }
            }), Oc.prototype = Object.assign(Object.create(Rc.prototype), {
                constructor: Oc,
                interpolate_: function(t) {
                    return this.copySampleValue_(t - 1)
                }
            }), Object.assign(Ic, {
                toJSON: function(t) {
                    const e = t.constructor;
                    let n;
                    if (void 0 !== e.toJSON) n = e.toJSON(t);
                    else {
                        n = {
                            name: t.name,
                            times: Lc.convertArray(t.times, Array),
                            values: Lc.convertArray(t.values, Array)
                        };
                        const e = t.getInterpolation();
                        e !== t.DefaultInterpolation && (n.interpolation = e)
                    }
                    return n.type = t.ValueTypeName, n
                }
            }), Object.assign(Ic.prototype, {
                constructor: Ic,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: 2301,
                InterpolantFactoryMethodDiscrete: function(t) {
                    return new Oc(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodLinear: function(t) {
                    return new Cc(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodSmooth: function(t) {
                    return new Pc(this.times, this.values, this.getValueSize(), t)
                },
                setInterpolation: function(t) {
                    let e;
                    switch (t) {
                        case rn:
                            e = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case 2301:
                            e = this.InterpolantFactoryMethodLinear;
                            break;
                        case 2302:
                            e = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === e) {
                        const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (t === this.DefaultInterpolation) throw new Error(e);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return console.warn("THREE.KeyframeTrack:", e), this
                    }
                    return this.createInterpolant = e, this
                },
                getInterpolation: function() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return rn;
                        case this.InterpolantFactoryMethodLinear:
                            return 2301;
                        case this.InterpolantFactoryMethodSmooth:
                            return 2302
                    }
                },
                getValueSize: function() {
                    return this.values.length / this.times.length
                },
                shift: function(t) {
                    if (0 !== t) {
                        const e = this.times;
                        for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
                    }
                    return this
                },
                scale: function(t) {
                    if (1 !== t) {
                        const e = this.times;
                        for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
                    }
                    return this
                },
                trim: function(t, e) {
                    const n = this.times,
                        i = n.length;
                    let r = 0,
                        s = i - 1;
                    for (; r !== i && n[r] < t;) ++r;
                    for (; - 1 !== s && n[s] > e;) --s;
                    if (++s, 0 !== r || s !== i) {
                        r >= s && (s = Math.max(s, 1), r = s - 1);
                        const t = this.getValueSize();
                        this.times = Lc.arraySlice(n, r, s), this.values = Lc.arraySlice(this.values, r * t, s * t)
                    }
                    return this
                },
                validate: function() {
                    let t = !0;
                    const e = this.getValueSize();
                    e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                    const n = this.times,
                        i = this.values,
                        r = n.length;
                    0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                    let s = null;
                    for (let o = 0; o !== r; o++) {
                        const e = n[o];
                        if ("number" === typeof e && isNaN(e)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, e), t = !1;
                            break
                        }
                        if (null !== s && s > e) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, o, e, s), t = !1;
                            break
                        }
                        s = e
                    }
                    if (void 0 !== i && Lc.isTypedArray(i))
                        for (let o = 0, a = i.length; o !== a; ++o) {
                            const e = i[o];
                            if (isNaN(e)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, e), t = !1;
                                break
                            }
                        }
                    return t
                },
                optimize: function() {
                    const t = Lc.arraySlice(this.times),
                        e = Lc.arraySlice(this.values),
                        n = this.getValueSize(),
                        i = 2302 === this.getInterpolation(),
                        r = t.length - 1;
                    let s = 1;
                    for (let o = 1; o < r; ++o) {
                        let r = !1;
                        const a = t[o];
                        if (a !== t[o + 1] && (1 !== o || a !== a[0]))
                            if (i) r = !0;
                            else {
                                const t = o * n,
                                    i = t - n,
                                    s = t + n;
                                for (let o = 0; o !== n; ++o) {
                                    const n = e[t + o];
                                    if (n !== e[i + o] || n !== e[s + o]) {
                                        r = !0;
                                        break
                                    }
                                }
                            }
                        if (r) {
                            if (o !== s) {
                                t[s] = t[o];
                                const i = o * n,
                                    r = s * n;
                                for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
                            }++s
                        }
                    }
                    if (r > 0) {
                        t[s] = t[r];
                        for (let t = r * n, i = s * n, o = 0; o !== n; ++o) e[i + o] = e[t + o];
                        ++s
                    }
                    return s !== t.length ? (this.times = Lc.arraySlice(t, 0, s), this.values = Lc.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
                },
                clone: function() {
                    const t = Lc.arraySlice(this.times, 0),
                        e = Lc.arraySlice(this.values, 0),
                        n = new(0, this.constructor)(this.name, t, e);
                    return n.createInterpolant = this.createInterpolant, n
                }
            }), Nc.prototype = Object.assign(Object.create(Ic.prototype), {
                constructor: Nc,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: rn,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), Dc.prototype = Object.assign(Object.create(Ic.prototype), {
                constructor: Dc,
                ValueTypeName: "color"
            }), Fc.prototype = Object.assign(Object.create(Ic.prototype), {
                constructor: Fc,
                ValueTypeName: "number"
            }), Uc.prototype = Object.assign(Object.create(Rc.prototype), {
                constructor: Uc,
                interpolate_: function(t, e, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = (n - e) / (i - e);
                    let l = t * o;
                    for (let c = l + o; l !== c; l += 4) Bn.slerpFlat(r, 0, s, l - o, s, l, a);
                    return r
                }
            }), zc.prototype = Object.assign(Object.create(Ic.prototype), {
                constructor: zc,
                ValueTypeName: "quaternion",
                DefaultInterpolation: 2301,
                InterpolantFactoryMethodLinear: function(t) {
                    return new Uc(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodSmooth: void 0
            }), kc.prototype = Object.assign(Object.create(Ic.prototype), {
                constructor: kc,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: rn,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), Bc.prototype = Object.assign(Object.create(Ic.prototype), {
                constructor: Bc,
                ValueTypeName: "vector"
            }), Object.assign(Hc, {
                parse: function(t) {
                    const e = [],
                        n = t.tracks,
                        i = 1 / (t.fps || 1);
                    for (let r = 0, s = n.length; r !== s; ++r) e.push(Gc(n[r]).scale(i));
                    return new Hc(t.name, t.duration, e, t.blendMode)
                },
                toJSON: function(t) {
                    const e = [],
                        n = t.tracks,
                        i = {
                            name: t.name,
                            duration: t.duration,
                            tracks: e,
                            uuid: t.uuid,
                            blendMode: t.blendMode
                        };
                    for (let r = 0, s = n.length; r !== s; ++r) e.push(Ic.toJSON(n[r]));
                    return i
                },
                CreateFromMorphTargetSequence: function(t, e, n, i) {
                    const r = e.length,
                        s = [];
                    for (let o = 0; o < r; o++) {
                        let t = [],
                            a = [];
                        t.push((o + r - 1) % r, o, (o + 1) % r), a.push(0, 1, 0);
                        const l = Lc.getKeyframeOrder(t);
                        t = Lc.sortedArray(t, 1, l), a = Lc.sortedArray(a, 1, l), i || 0 !== t[0] || (t.push(r), a.push(a[0])), s.push(new Fc(".morphTargetInfluences[" + e[o].name + "]", t, a).scale(1 / n))
                    }
                    return new Hc(t, -1, s)
                },
                findByName: function(t, e) {
                    let n = t;
                    if (!Array.isArray(t)) {
                        const e = t;
                        n = e.geometry && e.geometry.animations || e.animations
                    }
                    for (let i = 0; i < n.length; i++)
                        if (n[i].name === e) return n[i];
                    return null
                },
                CreateClipsFromMorphTargetSequences: function(t, e, n) {
                    const i = {},
                        r = /^([\w-]*?)([\d]+)$/;
                    for (let o = 0, a = t.length; o < a; o++) {
                        const e = t[o],
                            n = e.name.match(r);
                        if (n && n.length > 1) {
                            const t = n[1];
                            let r = i[t];
                            r || (i[t] = r = []), r.push(e)
                        }
                    }
                    const s = [];
                    for (const o in i) s.push(Hc.CreateFromMorphTargetSequence(o, i[o], e, n));
                    return s
                },
                parseAnimation: function(t, e) {
                    if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    const n = function(t, e, n, i, r) {
                            if (0 !== n.length) {
                                const s = [],
                                    o = [];
                                Lc.flattenJSON(n, s, o, i), 0 !== s.length && r.push(new t(e, s, o))
                            }
                        },
                        i = [],
                        r = t.name || "default",
                        s = t.fps || 30,
                        o = t.blendMode;
                    let a = t.length || -1;
                    const l = t.hierarchy || [];
                    for (let c = 0; c < l.length; c++) {
                        const t = l[c].keys;
                        if (t && 0 !== t.length)
                            if (t[0].morphTargets) {
                                const e = {};
                                let n;
                                for (n = 0; n < t.length; n++)
                                    if (t[n].morphTargets)
                                        for (let i = 0; i < t[n].morphTargets.length; i++) e[t[n].morphTargets[i]] = -1;
                                for (const r in e) {
                                    const e = [],
                                        s = [];
                                    for (let i = 0; i !== t[n].morphTargets.length; ++i) {
                                        const i = t[n];
                                        e.push(i.time), s.push(i.morphTarget === r ? 1 : 0)
                                    }
                                    i.push(new Fc(".morphTargetInfluence[" + r + "]", e, s))
                                }
                                a = e.length * (s || 1)
                            } else {
                                const r = ".bones[" + e[c].name + "]";
                                n(Bc, r + ".position", t, "pos", i), n(zc, r + ".quaternion", t, "rot", i), n(Bc, r + ".scale", t, "scl", i)
                            }
                    }
                    return 0 === i.length ? null : new Hc(r, a, i, o)
                }
            }), Object.assign(Hc.prototype, {
                resetDuration: function() {
                    let t = 0;
                    for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                        const n = this.tracks[e];
                        t = Math.max(t, n.times[n.times.length - 1])
                    }
                    return this.duration = t, this
                },
                trim: function() {
                    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                    return this
                },
                validate: function() {
                    let t = !0;
                    for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                    return t
                },
                optimize: function() {
                    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                    return this
                },
                clone: function() {
                    const t = [];
                    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                    return new Hc(this.name, this.duration, t, this.blendMode)
                }
            });
            const Vc = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            };
            const jc = new function(t, e, n) {
                const i = this;
                let r = !1,
                    s = 0,
                    o = 0,
                    a = void 0;
                const l = [];
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
                    o++, !1 === r && void 0 !== i.onStart && i.onStart(t, s, o), r = !0
                }, this.itemEnd = function(t) {
                    s++, void 0 !== i.onProgress && i.onProgress(t, s, o), s === o && (r = !1, void 0 !== i.onLoad && i.onLoad())
                }, this.itemError = function(t) {
                    void 0 !== i.onError && i.onError(t)
                }, this.resolveURL = function(t) {
                    return a ? a(t) : t
                }, this.setURLModifier = function(t) {
                    return a = t, this
                }, this.addHandler = function(t, e) {
                    return l.push(t, e), this
                }, this.removeHandler = function(t) {
                    const e = l.indexOf(t);
                    return -1 !== e && l.splice(e, 2), this
                }, this.getHandler = function(t) {
                    for (let e = 0, n = l.length; e < n; e += 2) {
                        const n = l[e],
                            i = l[e + 1];
                        if (n.global && (n.lastIndex = 0), n.test(t)) return i
                    }
                    return null
                }
            };

            function Wc(t) {
                this.manager = void 0 !== t ? t : jc, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
            }
            Object.assign(Wc.prototype, {
                load: function() {},
                loadAsync: function(t, e) {
                    const n = this;
                    return new Promise((function(i, r) {
                        n.load(t, i, e, r)
                    }))
                },
                parse: function() {},
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setWithCredentials: function(t) {
                    return this.withCredentials = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResourcePath: function(t) {
                    return this.resourcePath = t, this
                },
                setRequestHeader: function(t) {
                    return this.requestHeader = t, this
                }
            });
            const qc = {};

            function Xc(t) {
                Wc.call(this, t)
            }

            function Yc(t) {
                Wc.call(this, t)
            }

            function Jc(t) {
                Wc.call(this, t)
            }

            function Zc(t) {
                Wc.call(this, t)
            }

            function Kc(t) {
                Wc.call(this, t)
            }

            function $c(t) {
                Wc.call(this, t)
            }

            function Qc(t) {
                Wc.call(this, t)
            }

            function th() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            function eh(t, e, n, i, r, s, o, a) {
                th.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = s || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = a || 0
            }

            function nh(t, e, n, i, r, s) {
                eh.call(this, t, e, n, n, i, r, s), this.type = "ArcCurve"
            }

            function ih() {
                let t = 0,
                    e = 0,
                    n = 0,
                    i = 0;

                function r(r, s, o, a) {
                    t = r, e = o, n = -3 * r + 3 * s - 2 * o - a, i = 2 * r - 2 * s + o + a
                }
                return {
                    initCatmullRom: function(t, e, n, i, s) {
                        r(e, n, s * (n - t), s * (i - e))
                    },
                    initNonuniformCatmullRom: function(t, e, n, i, s, o, a) {
                        let l = (e - t) / s - (n - t) / (s + o) + (n - e) / o,
                            c = (n - e) / o - (i - e) / (o + a) + (i - n) / a;
                        l *= o, c *= o, r(e, n, l, c)
                    },
                    calc: function(r) {
                        const s = r * r;
                        return t + e * r + n * s + i * (s * r)
                    }
                }
            }
            Xc.prototype = Object.assign(Object.create(Wc.prototype), {
                constructor: Xc,
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const r = this,
                        s = Vc.get(t);
                    if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                        e && e(s), r.manager.itemEnd(t)
                    }), 0), s;
                    if (void 0 !== qc[t]) return void qc[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    });
                    const o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                    let a;
                    if (o) {
                        const n = o[1],
                            s = !!o[2];
                        let a = o[3];
                        a = decodeURIComponent(a), s && (a = atob(a));
                        try {
                            let i;
                            const s = (this.responseType || "").toLowerCase();
                            switch (s) {
                                case "arraybuffer":
                                case "blob":
                                    const t = new Uint8Array(a.length);
                                    for (let n = 0; n < a.length; n++) t[n] = a.charCodeAt(n);
                                    i = "blob" === s ? new Blob([t.buffer], {
                                        type: n
                                    }) : t.buffer;
                                    break;
                                case "document":
                                    const e = new DOMParser;
                                    i = e.parseFromString(a, n);
                                    break;
                                case "json":
                                    i = JSON.parse(a);
                                    break;
                                default:
                                    i = a
                            }
                            setTimeout((function() {
                                e && e(i), r.manager.itemEnd(t)
                            }), 0)
                        } catch (l) {
                            setTimeout((function() {
                                i && i(l), r.manager.itemError(t), r.manager.itemEnd(t)
                            }), 0)
                        }
                    } else {
                        qc[t] = [], qc[t].push({
                            onLoad: e,
                            onProgress: n,
                            onError: i
                        }), a = new XMLHttpRequest, a.open("GET", t, !0), a.addEventListener("load", (function(e) {
                            const n = this.response,
                                i = qc[t];
                            if (delete qc[t], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Vc.add(t, n);
                                for (let t = 0, e = i.length; t < e; t++) {
                                    const e = i[t];
                                    e.onLoad && e.onLoad(n)
                                }
                                r.manager.itemEnd(t)
                            } else {
                                for (let t = 0, n = i.length; t < n; t++) {
                                    const n = i[t];
                                    n.onError && n.onError(e)
                                }
                                r.manager.itemError(t), r.manager.itemEnd(t)
                            }
                        }), !1), a.addEventListener("progress", (function(e) {
                            const n = qc[t];
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                i.onProgress && i.onProgress(e)
                            }
                        }), !1), a.addEventListener("error", (function(e) {
                            const n = qc[t];
                            delete qc[t];
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                i.onError && i.onError(e)
                            }
                            r.manager.itemError(t), r.manager.itemEnd(t)
                        }), !1), a.addEventListener("abort", (function(e) {
                            const n = qc[t];
                            delete qc[t];
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                i.onError && i.onError(e)
                            }
                            r.manager.itemError(t), r.manager.itemEnd(t)
                        }), !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                        for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]);
                        a.send(null)
                    }
                    return r.manager.itemStart(t), a
                },
                setResponseType: function(t) {
                    return this.responseType = t, this
                },
                setMimeType: function(t) {
                    return this.mimeType = t, this
                }
            }), Yc.prototype = Object.assign(Object.create(Wc.prototype), {
                constructor: Yc,
                load: function(t, e, n, i) {
                    const r = this,
                        s = new Xc(r.manager);
                    s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(n) {
                        try {
                            e(r.parse(JSON.parse(n)))
                        } catch (s) {
                            i ? i(s) : console.error(s), r.manager.itemError(t)
                        }
                    }), n, i)
                },
                parse: function(t) {
                    const e = [];
                    for (let n = 0; n < t.length; n++) {
                        const i = Hc.parse(t[n]);
                        e.push(i)
                    }
                    return e
                }
            }), Jc.prototype = Object.assign(Object.create(Wc.prototype), {
                constructor: Jc,
                load: function(t, e, n, i) {
                    const r = this,
                        s = [],
                        o = new Ll;
                    o.image = s;
                    const a = new Xc(this.manager);
                    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(r.withCredentials);
                    let l = 0;

                    function c(c) {
                        a.load(t[c], (function(t) {
                            const n = r.parse(t, !0);
                            s[c] = {
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmaps: n.mipmaps
                            }, l += 1, 6 === l && (1 === n.mipmapCount && (o.minFilter = kt), o.format = n.format, o.needsUpdate = !0, e && e(o))
                        }), n, i)
                    }
                    if (Array.isArray(t))
                        for (let h = 0, u = t.length; h < u; ++h) c(h);
                    else a.load(t, (function(t) {
                        const n = r.parse(t, !0);
                        if (n.isCubemap) {
                            const t = n.mipmaps.length / n.mipmapCount;
                            for (let e = 0; e < t; e++) {
                                s[e] = {
                                    mipmaps: []
                                };
                                for (let t = 0; t < n.mipmapCount; t++) s[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), s[e].format = n.format, s[e].width = n.width, s[e].height = n.height
                            }
                        } else o.image.width = n.width, o.image.height = n.height, o.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (o.minFilter = kt), o.format = n.format, o.needsUpdate = !0, e && e(o)
                    }), n, i);
                    return o
                }
            }), Zc.prototype = Object.assign(Object.create(Wc.prototype), {
                constructor: Zc,
                load: function(t, e, n, i) {
                    void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const r = this,
                        s = Vc.get(t);
                    if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                        e && e(s), r.manager.itemEnd(t)
                    }), 0), s;
                    const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                    function a() {
                        o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), Vc.add(t, this), e && e(this), r.manager.itemEnd(t)
                    }

                    function l(e) {
                        o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    }
                    return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o
                }
            }), Kc.prototype = Object.assign(Object.create(Wc.prototype), {
                constructor: Kc,
                load: function(t, e, n, i) {
                    const r = new ps,
                        s = new Zc(this.manager);
                    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                    let o = 0;

                    function a(n) {
                        s.load(t[n], (function(t) {
                            r.images[n] = t, o++, 6 === o && (r.needsUpdate = !0, e && e(r))
                        }), void 0, i)
                    }
                    for (let l = 0; l < t.length; ++l) a(l);
                    return r
                }
            }), $c.prototype = Object.assign(Object.create(Wc.prototype), {
                constructor: $c,
                load: function(t, e, n, i) {
                    const r = this,
                        s = new fs,
                        o = new Xc(this.manager);
                    return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(r.withCredentials), o.load(t, (function(t) {
                        const n = r.parse(t);
                        n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : Nt, s.wrapT = void 0 !== n.wrapT ? n.wrapT : Nt, s.magFilter = void 0 !== n.magFilter ? n.magFilter : kt, s.minFilter = void 0 !== n.minFilter ? n.minFilter : kt, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = Ht), 1 === n.mipmapCount && (s.minFilter = kt), s.needsUpdate = !0, e && e(s, n))
                    }), n, i), s
                }
            }), Qc.prototype = Object.assign(Object.create(Wc.prototype), {
                constructor: Qc,
                load: function(t, e, n, i) {
                    const r = new Fn,
                        s = new Zc(this.manager);
                    return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function(n) {
                        r.image = n;
                        const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                        r.format = i ? ee : ne, r.needsUpdate = !0, void 0 !== e && e(r)
                    }), n, i), r
                }
            }), Object.assign(th.prototype, {
                getPoint: function() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function(t, e) {
                    const n = this.getUtoTmapping(t);
                    return this.getPoint(n, e)
                },
                getPoints: function(t) {
                    void 0 === t && (t = 5);
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return e
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 5);
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                    return e
                },
                getLength: function() {
                    const t = this.getLengths();
                    return t[t.length - 1]
                },
                getLengths: function(t) {
                    if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    const e = [];
                    let n, i = this.getPoint(0),
                        r = 0;
                    e.push(0);
                    for (let s = 1; s <= t; s++) n = this.getPoint(s / t), r += n.distanceTo(i), e.push(r), i = n;
                    return this.cacheArcLengths = e, e
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(t, e) {
                    const n = this.getLengths();
                    let i = 0;
                    const r = n.length;
                    let s;
                    s = e || t * n[r - 1];
                    let o, a = 0,
                        l = r - 1;
                    for (; a <= l;)
                        if (i = Math.floor(a + (l - a) / 2), o = n[i] - s, o < 0) a = i + 1;
                        else {
                            if (!(o > 0)) {
                                l = i;
                                break
                            }
                            l = i - 1
                        }
                    if (i = l, n[i] === s) return i / (r - 1);
                    const c = n[i];
                    return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
                },
                getTangent: function(t, e) {
                    let n = t - 1e-4,
                        i = t + 1e-4;
                    n < 0 && (n = 0), i > 1 && (i = 1);
                    const r = this.getPoint(n),
                        s = this.getPoint(i),
                        o = e || (r.isVector2 ? new Cn : new Hn);
                    return o.copy(s).sub(r).normalize(), o
                },
                getTangentAt: function(t, e) {
                    const n = this.getUtoTmapping(t);
                    return this.getTangent(n, e)
                },
                computeFrenetFrames: function(t, e) {
                    const n = new Hn,
                        i = [],
                        r = [],
                        s = [],
                        o = new Hn,
                        a = new fi;
                    for (let d = 0; d <= t; d++) {
                        const e = d / t;
                        i[d] = this.getTangentAt(e, new Hn), i[d].normalize()
                    }
                    r[0] = new Hn, s[0] = new Hn;
                    let l = Number.MAX_VALUE;
                    const c = Math.abs(i[0].x),
                        h = Math.abs(i[0].y),
                        u = Math.abs(i[0].z);
                    c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), o.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], o), s[0].crossVectors(i[0], r[0]);
                    for (let d = 1; d <= t; d++) {
                        if (r[d] = r[d - 1].clone(), s[d] = s[d - 1].clone(), o.crossVectors(i[d - 1], i[d]), o.length() > Number.EPSILON) {
                            o.normalize();
                            const t = Math.acos(Pn.clamp(i[d - 1].dot(i[d]), -1, 1));
                            r[d].applyMatrix4(a.makeRotationAxis(o, t))
                        }
                        s[d].crossVectors(i[d], r[d])
                    }
                    if (!0 === e) {
                        let e = Math.acos(Pn.clamp(r[0].dot(r[t]), -1, 1));
                        e /= t, i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e);
                        for (let n = 1; n <= t; n++) r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n])
                    }
                    return {
                        tangents: i,
                        normals: r,
                        binormals: s
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                },
                toJSON: function() {
                    const t = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                },
                fromJSON: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
            }), eh.prototype = Object.create(th.prototype), eh.prototype.constructor = eh, eh.prototype.isEllipseCurve = !0, eh.prototype.getPoint = function(t, e) {
                const n = e || new Cn,
                    i = 2 * Math.PI;
                let r = this.aEndAngle - this.aStartAngle;
                const s = Math.abs(r) < Number.EPSILON;
                for (; r < 0;) r += i;
                for (; r > i;) r -= i;
                r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
                const o = this.aStartAngle + t * r;
                let a = this.aX + this.xRadius * Math.cos(o),
                    l = this.aY + this.yRadius * Math.sin(o);
                if (0 !== this.aRotation) {
                    const t = Math.cos(this.aRotation),
                        e = Math.sin(this.aRotation),
                        n = a - this.aX,
                        i = l - this.aY;
                    a = n * t - i * e + this.aX, l = n * e + i * t + this.aY
                }
                return n.set(a, l)
            }, eh.prototype.copy = function(t) {
                return th.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, eh.prototype.toJSON = function() {
                const t = th.prototype.toJSON.call(this);
                return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
            }, eh.prototype.fromJSON = function(t) {
                return th.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, nh.prototype = Object.create(eh.prototype), nh.prototype.constructor = nh, nh.prototype.isArcCurve = !0;
            const rh = new Hn,
                sh = new ih,
                oh = new ih,
                ah = new ih;

            function lh(t, e, n, i) {
                th.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = void 0 !== i ? i : .5
            }

            function ch(t, e, n, i, r) {
                const s = .5 * (i - e),
                    o = .5 * (r - n),
                    a = t * t;
                return (2 * n - 2 * i + s + o) * (t * a) + (-3 * n + 3 * i - 2 * s - o) * a + s * t + n
            }

            function hh(t, e, n, i) {
                return function(t, e) {
                    const n = 1 - t;
                    return n * n * e
                }(t, e) + function(t, e) {
                    return 2 * (1 - t) * t * e
                }(t, n) + function(t, e) {
                    return t * t * e
                }(t, i)
            }

            function uh(t, e, n, i, r) {
                return function(t, e) {
                    const n = 1 - t;
                    return n * n * n * e
                }(t, e) + function(t, e) {
                    const n = 1 - t;
                    return 3 * n * n * t * e
                }(t, n) + function(t, e) {
                    return 3 * (1 - t) * t * t * e
                }(t, i) + function(t, e) {
                    return t * t * t * e
                }(t, r)
            }

            function dh(t, e, n, i) {
                th.call(this), this.type = "CubicBezierCurve", this.v0 = t || new Cn, this.v1 = e || new Cn, this.v2 = n || new Cn, this.v3 = i || new Cn
            }

            function ph(t, e, n, i) {
                th.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new Hn, this.v1 = e || new Hn, this.v2 = n || new Hn, this.v3 = i || new Hn
            }

            function mh(t, e) {
                th.call(this), this.type = "LineCurve", this.v1 = t || new Cn, this.v2 = e || new Cn
            }

            function fh(t, e) {
                th.call(this), this.type = "LineCurve3", this.v1 = t || new Hn, this.v2 = e || new Hn
            }

            function gh(t, e, n) {
                th.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new Cn, this.v1 = e || new Cn, this.v2 = n || new Cn
            }

            function vh(t, e, n) {
                th.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new Hn, this.v1 = e || new Hn, this.v2 = n || new Hn
            }

            function yh(t) {
                th.call(this), this.type = "SplineCurve", this.points = t || []
            }
            lh.prototype = Object.create(th.prototype), lh.prototype.constructor = lh, lh.prototype.isCatmullRomCurve3 = !0, lh.prototype.getPoint = function(t, e) {
                const n = e || new Hn,
                    i = this.points,
                    r = i.length,
                    s = (r - (this.closed ? 0 : 1)) * t;
                let o, a, l = Math.floor(s),
                    c = s - l;
                this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? o = i[(l - 1) % r] : (rh.subVectors(i[0], i[1]).add(i[0]), o = rh);
                const h = i[l % r],
                    u = i[(l + 1) % r];
                if (this.closed || l + 2 < r ? a = i[(l + 2) % r] : (rh.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), a = rh), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    const t = "chordal" === this.curveType ? .5 : .25;
                    let e = Math.pow(o.distanceToSquared(h), t),
                        n = Math.pow(h.distanceToSquared(u), t),
                        i = Math.pow(u.distanceToSquared(a), t);
                    n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), sh.initNonuniformCatmullRom(o.x, h.x, u.x, a.x, e, n, i), oh.initNonuniformCatmullRom(o.y, h.y, u.y, a.y, e, n, i), ah.initNonuniformCatmullRom(o.z, h.z, u.z, a.z, e, n, i)
                } else "catmullrom" === this.curveType && (sh.initCatmullRom(o.x, h.x, u.x, a.x, this.tension), oh.initCatmullRom(o.y, h.y, u.y, a.y, this.tension), ah.initCatmullRom(o.z, h.z, u.z, a.z, this.tension));
                return n.set(sh.calc(c), oh.calc(c), ah.calc(c)), n
            }, lh.prototype.copy = function(t) {
                th.prototype.copy.call(this, t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, lh.prototype.toJSON = function() {
                const t = th.prototype.toJSON.call(this);
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
            }, lh.prototype.fromJSON = function(t) {
                th.prototype.fromJSON.call(this, t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new Hn).fromArray(n))
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, dh.prototype = Object.create(th.prototype), dh.prototype.constructor = dh, dh.prototype.isCubicBezierCurve = !0, dh.prototype.getPoint = function(t, e) {
                const n = e || new Cn,
                    i = this.v0,
                    r = this.v1,
                    s = this.v2,
                    o = this.v3;
                return n.set(uh(t, i.x, r.x, s.x, o.x), uh(t, i.y, r.y, s.y, o.y)), n
            }, dh.prototype.copy = function(t) {
                return th.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, dh.prototype.toJSON = function() {
                const t = th.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, dh.prototype.fromJSON = function(t) {
                return th.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, ph.prototype = Object.create(th.prototype), ph.prototype.constructor = ph, ph.prototype.isCubicBezierCurve3 = !0, ph.prototype.getPoint = function(t, e) {
                const n = e || new Hn,
                    i = this.v0,
                    r = this.v1,
                    s = this.v2,
                    o = this.v3;
                return n.set(uh(t, i.x, r.x, s.x, o.x), uh(t, i.y, r.y, s.y, o.y), uh(t, i.z, r.z, s.z, o.z)), n
            }, ph.prototype.copy = function(t) {
                return th.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, ph.prototype.toJSON = function() {
                const t = th.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, ph.prototype.fromJSON = function(t) {
                return th.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, mh.prototype = Object.create(th.prototype), mh.prototype.constructor = mh, mh.prototype.isLineCurve = !0, mh.prototype.getPoint = function(t, e) {
                const n = e || new Cn;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }, mh.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, mh.prototype.getTangent = function(t, e) {
                const n = e || new Cn;
                return n.copy(this.v2).sub(this.v1).normalize(), n
            }, mh.prototype.copy = function(t) {
                return th.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, mh.prototype.toJSON = function() {
                const t = th.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, mh.prototype.fromJSON = function(t) {
                return th.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, fh.prototype = Object.create(th.prototype), fh.prototype.constructor = fh, fh.prototype.isLineCurve3 = !0, fh.prototype.getPoint = function(t, e) {
                const n = e || new Hn;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }, fh.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, fh.prototype.copy = function(t) {
                return th.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, fh.prototype.toJSON = function() {
                const t = th.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, fh.prototype.fromJSON = function(t) {
                return th.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, gh.prototype = Object.create(th.prototype), gh.prototype.constructor = gh, gh.prototype.isQuadraticBezierCurve = !0, gh.prototype.getPoint = function(t, e) {
                const n = e || new Cn,
                    i = this.v0,
                    r = this.v1,
                    s = this.v2;
                return n.set(hh(t, i.x, r.x, s.x), hh(t, i.y, r.y, s.y)), n
            }, gh.prototype.copy = function(t) {
                return th.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, gh.prototype.toJSON = function() {
                const t = th.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, gh.prototype.fromJSON = function(t) {
                return th.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, vh.prototype = Object.create(th.prototype), vh.prototype.constructor = vh, vh.prototype.isQuadraticBezierCurve3 = !0, vh.prototype.getPoint = function(t, e) {
                const n = e || new Hn,
                    i = this.v0,
                    r = this.v1,
                    s = this.v2;
                return n.set(hh(t, i.x, r.x, s.x), hh(t, i.y, r.y, s.y), hh(t, i.z, r.z, s.z)), n
            }, vh.prototype.copy = function(t) {
                return th.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, vh.prototype.toJSON = function() {
                const t = th.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, vh.prototype.fromJSON = function(t) {
                return th.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, yh.prototype = Object.create(th.prototype), yh.prototype.constructor = yh, yh.prototype.isSplineCurve = !0, yh.prototype.getPoint = function(t, e) {
                const n = e || new Cn,
                    i = this.points,
                    r = (i.length - 1) * t,
                    s = Math.floor(r),
                    o = r - s,
                    a = i[0 === s ? s : s - 1],
                    l = i[s],
                    c = i[s > i.length - 2 ? i.length - 1 : s + 1],
                    h = i[s > i.length - 3 ? i.length - 1 : s + 2];
                return n.set(ch(o, a.x, l.x, c.x, h.x), ch(o, a.y, l.y, c.y, h.y)), n
            }, yh.prototype.copy = function(t) {
                th.prototype.copy.call(this, t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push(n.clone())
                }
                return this
            }, yh.prototype.toJSON = function() {
                const t = th.prototype.toJSON.call(this);
                t.points = [];
                for (let e = 0, n = this.points.length; e < n; e++) {
                    const n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t
            }, yh.prototype.fromJSON = function(t) {
                th.prototype.fromJSON.call(this, t), this.points = [];
                for (let e = 0, n = t.points.length; e < n; e++) {
                    const n = t.points[e];
                    this.points.push((new Cn).fromArray(n))
                }
                return this
            };
            var xh = Object.freeze({
                __proto__: null,
                ArcCurve: nh,
                CatmullRomCurve3: lh,
                CubicBezierCurve: dh,
                CubicBezierCurve3: ph,
                EllipseCurve: eh,
                LineCurve: mh,
                LineCurve3: fh,
                QuadraticBezierCurve: gh,
                QuadraticBezierCurve3: vh,
                SplineCurve: yh
            });

            function bh() {
                th.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            function _h(t) {
                bh.call(this), this.type = "Path", this.currentPoint = new Cn, t && this.setFromPoints(t)
            }

            function wh(t) {
                _h.call(this, t), this.uuid = Pn.generateUUID(), this.type = "Shape", this.holes = []
            }

            function Mh(t, e) {
                Bi.call(this), this.type = "Light", this.color = new lr(t), this.intensity = void 0 !== e ? e : 1
            }

            function Sh(t, e, n) {
                Mh.call(this, t, n), this.type = "HemisphereLight", this.position.copy(Bi.DefaultUp), this.updateMatrix(), this.groundColor = new lr(e)
            }

            function Th(t) {
                this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Cn(512, 512), this.map = null, this.mapPass = null, this.matrix = new fi, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new ys, this._frameExtents = new Cn(1, 1), this._viewportCount = 1, this._viewports = [new Un(0, 0, 1, 1)]
            }

            function Eh() {
                Th.call(this, new cs(50, 1, .5, 500)), this.focus = 1
            }

            function Ah(t, e, n, i, r, s) {
                Mh.call(this, t, e), this.type = "SpotLight", this.position.copy(Bi.DefaultUp), this.updateMatrix(), this.target = new Bi, Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / Math.PI
                    }
                }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== s ? s : 1, this.shadow = new Eh
            }

            function Lh() {
                Th.call(this, new cs(90, 1, .5, 500)), this._frameExtents = new Cn(4, 2), this._viewportCount = 6, this._viewports = [new Un(2, 1, 1, 1), new Un(0, 1, 1, 1), new Un(3, 1, 1, 1), new Un(1, 1, 1, 1), new Un(3, 0, 1, 1), new Un(1, 0, 1, 1)], this._cubeDirections = [new Hn(1, 0, 0), new Hn(-1, 0, 0), new Hn(0, 0, 1), new Hn(0, 0, -1), new Hn(0, 1, 0), new Hn(0, -1, 0)], this._cubeUps = [new Hn(0, 1, 0), new Hn(0, 1, 0), new Hn(0, 1, 0), new Hn(0, 1, 0), new Hn(0, 0, 1), new Hn(0, 0, -1)]
            }

            function Rh(t, e, n, i) {
                Mh.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new Lh
            }

            function Ph(t, e, n, i, r, s) {
                ls.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== s ? s : 2e3, this.updateProjectionMatrix()
            }

            function Ch() {
                Th.call(this, new Ph(-5, 5, 5, -5, .5, 500))
            }

            function Oh(t, e) {
                Mh.call(this, t, e), this.type = "DirectionalLight", this.position.copy(Bi.DefaultUp), this.updateMatrix(), this.target = new Bi, this.shadow = new Ch
            }

            function Ih(t, e) {
                Mh.call(this, t, e), this.type = "AmbientLight"
            }

            function Nh(t, e, n, i) {
                Mh.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10
            }
            bh.prototype = Object.assign(Object.create(th.prototype), {
                constructor: bh,
                add: function(t) {
                    this.curves.push(t)
                },
                closePath: function() {
                    const t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new mh(e, t))
                },
                getPoint: function(t) {
                    const e = t * this.getLength(),
                        n = this.getCurveLengths();
                    let i = 0;
                    for (; i < n.length;) {
                        if (n[i] >= e) {
                            const t = n[i] - e,
                                r = this.curves[i],
                                s = r.getLength(),
                                o = 0 === s ? 0 : 1 - t / s;
                            return r.getPointAt(o)
                        }
                        i++
                    }
                    return null
                },
                getLength: function() {
                    const t = this.getCurveLengths();
                    return t[t.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    const t = [];
                    let e = 0;
                    for (let n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e);
                    return this.cacheLengths = t, t
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 40);
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return this.autoClose && e.push(e[0]), e
                },
                getPoints: function(t) {
                    t = t || 12;
                    const e = [];
                    let n;
                    for (let i = 0, r = this.curves; i < r.length; i++) {
                        const s = r[i],
                            o = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t,
                            a = s.getPoints(o);
                        for (let t = 0; t < a.length; t++) {
                            const i = a[t];
                            n && n.equals(i) || (e.push(i), n = i)
                        }
                    }
                    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
                },
                copy: function(t) {
                    th.prototype.copy.call(this, t), this.curves = [];
                    for (let e = 0, n = t.curves.length; e < n; e++) {
                        const n = t.curves[e];
                        this.curves.push(n.clone())
                    }
                    return this.autoClose = t.autoClose, this
                },
                toJSON: function() {
                    const t = th.prototype.toJSON.call(this);
                    t.autoClose = this.autoClose, t.curves = [];
                    for (let e = 0, n = this.curves.length; e < n; e++) {
                        const n = this.curves[e];
                        t.curves.push(n.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    th.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                    for (let e = 0, n = t.curves.length; e < n; e++) {
                        const n = t.curves[e];
                        this.curves.push((new xh[n.type]).fromJSON(n))
                    }
                    return this
                }
            }), _h.prototype = Object.assign(Object.create(bh.prototype), {
                constructor: _h,
                setFromPoints: function(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
                    return this
                },
                moveTo: function(t, e) {
                    return this.currentPoint.set(t, e), this
                },
                lineTo: function(t, e) {
                    const n = new mh(this.currentPoint.clone(), new Cn(t, e));
                    return this.curves.push(n), this.currentPoint.set(t, e), this
                },
                quadraticCurveTo: function(t, e, n, i) {
                    const r = new gh(this.currentPoint.clone(), new Cn(t, e), new Cn(n, i));
                    return this.curves.push(r), this.currentPoint.set(n, i), this
                },
                bezierCurveTo: function(t, e, n, i, r, s) {
                    const o = new dh(this.currentPoint.clone(), new Cn(t, e), new Cn(n, i), new Cn(r, s));
                    return this.curves.push(o), this.currentPoint.set(r, s), this
                },
                splineThru: function(t) {
                    const e = new yh([this.currentPoint.clone()].concat(t));
                    return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this
                },
                arc: function(t, e, n, i, r, s) {
                    const o = this.currentPoint.x,
                        a = this.currentPoint.y;
                    return this.absarc(t + o, e + a, n, i, r, s), this
                },
                absarc: function(t, e, n, i, r, s) {
                    return this.absellipse(t, e, n, n, i, r, s), this
                },
                ellipse: function(t, e, n, i, r, s, o, a) {
                    const l = this.currentPoint.x,
                        c = this.currentPoint.y;
                    return this.absellipse(t + l, e + c, n, i, r, s, o, a), this
                },
                absellipse: function(t, e, n, i, r, s, o, a) {
                    const l = new eh(t, e, n, i, r, s, o, a);
                    if (this.curves.length > 0) {
                        const t = l.getPoint(0);
                        t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                    }
                    this.curves.push(l);
                    const c = l.getPoint(1);
                    return this.currentPoint.copy(c), this
                },
                copy: function(t) {
                    return bh.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
                },
                toJSON: function() {
                    const t = bh.prototype.toJSON.call(this);
                    return t.currentPoint = this.currentPoint.toArray(), t
                },
                fromJSON: function(t) {
                    return bh.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
                }
            }), wh.prototype = Object.assign(Object.create(_h.prototype), {
                constructor: wh,
                getPointsHoles: function(t) {
                    const e = [];
                    for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                    return e
                },
                extractPoints: function(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                },
                copy: function(t) {
                    _h.prototype.copy.call(this, t), this.holes = [];
                    for (let e = 0, n = t.holes.length; e < n; e++) {
                        const n = t.holes[e];
                        this.holes.push(n.clone())
                    }
                    return this
                },
                toJSON: function() {
                    const t = _h.prototype.toJSON.call(this);
                    t.uuid = this.uuid, t.holes = [];
                    for (let e = 0, n = this.holes.length; e < n; e++) {
                        const n = this.holes[e];
                        t.holes.push(n.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    _h.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                    for (let e = 0, n = t.holes.length; e < n; e++) {
                        const n = t.holes[e];
                        this.holes.push((new _h).fromJSON(n))
                    }
                    return this
                }
            }), Mh.prototype = Object.assign(Object.create(Bi.prototype), {
                constructor: Mh,
                isLight: !0,
                copy: function(t) {
                    return Bi.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
                },
                toJSON: function(t) {
                    const e = Bi.prototype.toJSON.call(this, t);
                    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                }
            }), Sh.prototype = Object.assign(Object.create(Mh.prototype), {
                constructor: Sh,
                isHemisphereLight: !0,
                copy: function(t) {
                    return Mh.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                }
            }), Object.assign(Th.prototype, {
                _projScreenMatrix: new fi,
                _lightPositionWorld: new Hn,
                _lookTarget: new Hn,
                getViewportCount: function() {
                    return this._viewportCount
                },
                getFrustum: function() {
                    return this._frustum
                },
                updateMatrices: function(t) {
                    const e = this.camera,
                        n = this.matrix,
                        i = this._projScreenMatrix,
                        r = this._lookTarget,
                        s = this._lightPositionWorld;
                    s.setFromMatrixPosition(t.matrixWorld), e.position.copy(s), r.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(r), e.updateMatrixWorld(), i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(i), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
                },
                getViewport: function(t) {
                    return this._viewports[t]
                },
                getFrameExtents: function() {
                    return this._frameExtents
                },
                copy: function(t) {
                    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    const t = {};
                    return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                }
            }), Eh.prototype = Object.assign(Object.create(Th.prototype), {
                constructor: Eh,
                isSpotLightShadow: !0,
                updateMatrices: function(t) {
                    const e = this.camera,
                        n = 2 * Pn.RAD2DEG * t.angle * this.focus,
                        i = this.mapSize.width / this.mapSize.height,
                        r = t.distance || e.far;
                    n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), Th.prototype.updateMatrices.call(this, t)
                }
            }), Ah.prototype = Object.assign(Object.create(Mh.prototype), {
                constructor: Ah,
                isSpotLight: !0,
                copy: function(t) {
                    return Mh.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), Lh.prototype = Object.assign(Object.create(Th.prototype), {
                constructor: Lh,
                isPointLightShadow: !0,
                updateMatrices: function(t, e) {
                    void 0 === e && (e = 0);
                    const n = this.camera,
                        i = this.matrix,
                        r = this._lightPositionWorld,
                        s = this._lookTarget,
                        o = this._projScreenMatrix;
                    r.setFromMatrixPosition(t.matrixWorld), n.position.copy(r), s.copy(n.position), s.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(s), n.updateMatrixWorld(), i.makeTranslation(-r.x, -r.y, -r.z), o.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(o)
                }
            }), Rh.prototype = Object.assign(Object.create(Mh.prototype), {
                constructor: Rh,
                isPointLight: !0,
                copy: function(t) {
                    return Mh.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                }
            }), Ph.prototype = Object.assign(Object.create(ls.prototype), {
                constructor: Ph,
                isOrthographicCamera: !0,
                copy: function(t, e) {
                    return ls.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                },
                setViewOffset: function(t, e, n, i, r, s) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    const t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        i = (this.top + this.bottom) / 2;
                    let r = n - t,
                        s = n + t,
                        o = i + e,
                        a = i - e;
                    if (null !== this.view && this.view.enabled) {
                        const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        r += t * this.view.offsetX, s = r + t * this.view.width, o -= e * this.view.offsetY, a = o - e * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    const e = Bi.prototype.toJSON.call(this, t);
                    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                }
            }), Ch.prototype = Object.assign(Object.create(Th.prototype), {
                constructor: Ch,
                isDirectionalLightShadow: !0,
                updateMatrices: function(t) {
                    Th.prototype.updateMatrices.call(this, t)
                }
            }), Oh.prototype = Object.assign(Object.create(Mh.prototype), {
                constructor: Oh,
                isDirectionalLight: !0,
                copy: function(t) {
                    return Mh.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), Ih.prototype = Object.assign(Object.create(Mh.prototype), {
                constructor: Ih,
                isAmbientLight: !0
            }), Nh.prototype = Object.assign(Object.create(Mh.prototype), {
                constructor: Nh,
                isRectAreaLight: !0,
                copy: function(t) {
                    return Mh.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
                },
                toJSON: function(t) {
                    const e = Mh.prototype.toJSON.call(this, t);
                    return e.object.width = this.width, e.object.height = this.height, e
                }
            });
            class Dh {
                constructor() {
                    Object.defineProperty(this, "isSphericalHarmonics3", {
                        value: !0
                    }), this.coefficients = [];
                    for (let t = 0; t < 9; t++) this.coefficients.push(new Hn)
                }
                set(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                    return this
                }
                zero() {
                    for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                    return this
                }
                getAt(t, e) {
                    const n = t.x,
                        i = t.y,
                        r = t.z,
                        s = this.coefficients;
                    return e.copy(s[0]).multiplyScalar(.282095), e.addScaledVector(s[1], .488603 * i), e.addScaledVector(s[2], .488603 * r), e.addScaledVector(s[3], .488603 * n), e.addScaledVector(s[4], n * i * 1.092548), e.addScaledVector(s[5], i * r * 1.092548), e.addScaledVector(s[6], .315392 * (3 * r * r - 1)), e.addScaledVector(s[7], n * r * 1.092548), e.addScaledVector(s[8], .546274 * (n * n - i * i)), e
                }
                getIrradianceAt(t, e) {
                    const n = t.x,
                        i = t.y,
                        r = t.z,
                        s = this.coefficients;
                    return e.copy(s[0]).multiplyScalar(.886227), e.addScaledVector(s[1], 1.023328 * i), e.addScaledVector(s[2], 1.023328 * r), e.addScaledVector(s[3], 1.023328 * n), e.addScaledVector(s[4], .858086 * n * i), e.addScaledVector(s[5], .858086 * i * r), e.addScaledVector(s[6], .743125 * r * r - .247708), e.addScaledVector(s[7], .858086 * n * r), e.addScaledVector(s[8], .429043 * (n * n - i * i)), e
                }
                add(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                    return this
                }
                addScaledSH(t, e) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
                    return this
                }
                scale(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                    return this
                }
                lerp(t, e) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
                    return this
                }
                equals(t) {
                    for (let e = 0; e < 9; e++)
                        if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                    return !0
                }
                copy(t) {
                    return this.set(t.coefficients)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                fromArray(t, e) {
                    void 0 === e && (e = 0);
                    const n = this.coefficients;
                    for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
                    return this
                }
                toArray(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    const n = this.coefficients;
                    for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
                    return t
                }
                static getBasisAt(t, e) {
                    const n = t.x,
                        i = t.y,
                        r = t.z;
                    e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
                }
            }

            function Fh(t, e) {
                Mh.call(this, void 0, e), this.type = "LightProbe", this.sh = void 0 !== t ? t : new Dh
            }

            function Uh(t) {
                Wc.call(this, t), this.textures = {}
            }
            Fh.prototype = Object.assign(Object.create(Mh.prototype), {
                constructor: Fh,
                isLightProbe: !0,
                copy: function(t) {
                    return Mh.prototype.copy.call(this, t), this.sh.copy(t.sh), this
                },
                fromJSON: function(t) {
                    return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
                },
                toJSON: function(t) {
                    const e = Mh.prototype.toJSON.call(this, t);
                    return e.object.sh = this.sh.toArray(), e
                }
            }), Uh.prototype = Object.assign(Object.create(Wc.prototype), {
                constructor: Uh,
                load: function(t, e, n, i) {
                    const r = this,
                        s = new Xc(r.manager);
                    s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(n) {
                        try {
                            e(r.parse(JSON.parse(n)))
                        } catch (s) {
                            i ? i(s) : console.error(s), r.manager.itemError(t)
                        }
                    }), n, i)
                },
                parse: function(t) {
                    const e = this.textures;

                    function n(t) {
                        return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                    }
                    const i = new Ac[t.type];
                    if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = (new lr).setHex(t.sheen)), void 0 !== t.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && i.specular.setHex(t.specular), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (i.skinning = t.skinning), void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.vertexTangents && (i.vertexTangents = t.vertexTangents), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" === typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms)
                        for (const r in t.uniforms) {
                            const e = t.uniforms[r];
                            switch (i.uniforms[r] = {}, e.type) {
                                case "t":
                                    i.uniforms[r].value = n(e.value);
                                    break;
                                case "c":
                                    i.uniforms[r].value = (new lr).setHex(e.value);
                                    break;
                                case "v2":
                                    i.uniforms[r].value = (new Cn).fromArray(e.value);
                                    break;
                                case "v3":
                                    i.uniforms[r].value = (new Hn).fromArray(e.value);
                                    break;
                                case "v4":
                                    i.uniforms[r].value = (new Un).fromArray(e.value);
                                    break;
                                case "m3":
                                    i.uniforms[r].value = (new On).fromArray(e.value);
                                    break;
                                case "m4":
                                    i.uniforms[r].value = (new fi).fromArray(e.value);
                                    break;
                                default:
                                    i.uniforms[r].value = e.value
                            }
                        }
                    if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                        for (const r in t.extensions) i.extensions[r] = t.extensions[r];
                    if (void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                        let e = t.normalScale;
                        !1 === Array.isArray(e) && (e = [e, e]), i.normalScale = (new Cn).fromArray(e)
                    }
                    return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new Cn).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmission && (i.transmission = t.transmission), void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)), i
                },
                setTextures: function(t) {
                    return this.textures = t, this
                }
            });
            const zh = {
                decodeText: function(t) {
                    if ("undefined" !== typeof TextDecoder) return (new TextDecoder).decode(t);
                    let e = "";
                    for (let i = 0, r = t.length; i < r; i++) e += String.fromCharCode(t[i]);
                    try {
                        return decodeURIComponent(escape(e))
                    } catch (n) {
                        return e
                    }
                },
                extractUrlBase: function(t) {
                    const e = t.lastIndexOf("/");
                    return -1 === e ? "./" : t.substr(0, e + 1)
                }
            };

            function kh() {
                Nr.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
            }

            function Bh(t, e, n, i) {
                "number" === typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), fr.call(this, t, e, n), this.meshPerAttribute = i || 1
            }

            function Hh(t) {
                Wc.call(this, t)
            }
            kh.prototype = Object.assign(Object.create(Nr.prototype), {
                constructor: kh,
                isInstancedBufferGeometry: !0,
                copy: function(t) {
                    return Nr.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    const t = Nr.prototype.toJSON.call(this);
                    return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
                }
            }), Bh.prototype = Object.assign(Object.create(fr.prototype), {
                constructor: Bh,
                isInstancedBufferAttribute: !0,
                copy: function(t) {
                    return fr.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                },
                toJSON: function() {
                    const t = fr.prototype.toJSON.call(this);
                    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                }
            }), Hh.prototype = Object.assign(Object.create(Wc.prototype), {
                constructor: Hh,
                load: function(t, e, n, i) {
                    const r = this,
                        s = new Xc(r.manager);
                    s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(n) {
                        try {
                            e(r.parse(JSON.parse(n)))
                        } catch (s) {
                            i ? i(s) : console.error(s), r.manager.itemError(t)
                        }
                    }), n, i)
                },
                parse: function(t) {
                    const e = {},
                        n = {};

                    function i(t, i) {
                        if (void 0 !== e[i]) return e[i];
                        const r = t.interleavedBuffers[i],
                            s = function(t, e) {
                                if (void 0 !== n[e]) return n[e];
                                const i = t.arrayBuffers[e],
                                    r = new Uint32Array(i).buffer;
                                return n[e] = r, r
                            }(t, r.buffer),
                            o = new Ca(new Gh[r.type](s), r.stride);
                        return o.uuid = r.uuid, e[i] = o, o
                    }
                    const r = t.isInstancedBufferGeometry ? new kh : new Nr,
                        s = t.data.index;
                    if (void 0 !== s) {
                        const t = new Gh[s.type](s.array);
                        r.setIndex(new fr(t, 1))
                    }
                    const o = t.data.attributes;
                    for (const h in o) {
                        const e = o[h];
                        let n;
                        if (e.isInterleavedBufferAttribute) {
                            n = new Ia(i(t.data, e.data), e.itemSize, e.offset, e.normalized)
                        } else {
                            const t = new Gh[e.type](e.array);
                            n = new(e.isInstancedBufferAttribute ? Bh : fr)(t, e.itemSize, e.normalized)
                        }
                        void 0 !== e.name && (n.name = e.name), r.setAttribute(h, n)
                    }
                    const a = t.data.morphAttributes;
                    if (a)
                        for (const h in a) {
                            const e = a[h],
                                n = [];
                            for (let r = 0, s = e.length; r < s; r++) {
                                const s = e[r];
                                let o;
                                if (s.isInterleavedBufferAttribute) {
                                    o = new Ia(i(t.data, s.data), s.itemSize, s.offset, s.normalized)
                                } else {
                                    o = new fr(new Gh[s.type](s.array), s.itemSize, s.normalized)
                                }
                                void 0 !== s.name && (o.name = s.name), n.push(o)
                            }
                            r.morphAttributes[h] = n
                        }
                    t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
                    const l = t.data.groups || t.data.drawcalls || t.data.offsets;
                    if (void 0 !== l)
                        for (let h = 0, u = l.length; h !== u; ++h) {
                            const t = l[h];
                            r.addGroup(t.start, t.count, t.materialIndex)
                        }
                    const c = t.data.boundingSphere;
                    if (void 0 !== c) {
                        const t = new Hn;
                        void 0 !== c.center && t.fromArray(c.center), r.boundingSphere = new oi(t, c.radius)
                    }
                    return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r
                }
            });
            const Gh = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" !== typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function Vh(t) {
                "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Wc.call(this, t), this.options = {
                    premultiplyAlpha: "none"
                }
            }

            function jh() {
                this.type = "ShapePath", this.color = new lr, this.subPaths = [], this.currentPath = null
            }

            function Wh(t) {
                this.type = "Font", this.data = t
            }

            function qh(t, e, n, i, r) {
                const s = r.glyphs[t] || r.glyphs["?"];
                if (!s) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + ".");
                const o = new jh;
                let a, l, c, h, u, d, p, m;
                if (s.o) {
                    const t = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
                    for (let r = 0, s = t.length; r < s;) {
                        switch (t[r++]) {
                            case "m":
                                a = t[r++] * e + n, l = t[r++] * e + i, o.moveTo(a, l);
                                break;
                            case "l":
                                a = t[r++] * e + n, l = t[r++] * e + i, o.lineTo(a, l);
                                break;
                            case "q":
                                c = t[r++] * e + n, h = t[r++] * e + i, u = t[r++] * e + n, d = t[r++] * e + i, o.quadraticCurveTo(u, d, c, h);
                                break;
                            case "b":
                                c = t[r++] * e + n, h = t[r++] * e + i, u = t[r++] * e + n, d = t[r++] * e + i, p = t[r++] * e + n, m = t[r++] * e + i, o.bezierCurveTo(u, d, p, m, c, h)
                        }
                    }
                }
                return {
                    offsetX: s.ha * e,
                    path: o
                }
            }

            function Xh(t) {
                Wc.call(this, t)
            }
            let Yh;
            Vh.prototype = Object.assign(Object.create(Wc.prototype), {
                constructor: Vh,
                isImageBitmapLoader: !0,
                setOptions: function(t) {
                    return this.options = t, this
                },
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const r = this,
                        s = Vc.get(t);
                    if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                        e && e(s), r.manager.itemEnd(t)
                    }), 0), s;
                    const o = {};
                    o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", fetch(t, o).then((function(t) {
                        return t.blob()
                    })).then((function(t) {
                        return createImageBitmap(t, r.options)
                    })).then((function(n) {
                        Vc.add(t, n), e && e(n), r.manager.itemEnd(t)
                    })).catch((function(e) {
                        i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    })), r.manager.itemStart(t)
                }
            }), Object.assign(jh.prototype, {
                moveTo: function(t, e) {
                    return this.currentPath = new _h, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
                },
                lineTo: function(t, e) {
                    return this.currentPath.lineTo(t, e), this
                },
                quadraticCurveTo: function(t, e, n, i) {
                    return this.currentPath.quadraticCurveTo(t, e, n, i), this
                },
                bezierCurveTo: function(t, e, n, i, r, s) {
                    return this.currentPath.bezierCurveTo(t, e, n, i, r, s), this
                },
                splineThru: function(t) {
                    return this.currentPath.splineThru(t), this
                },
                toShapes: function(t, e) {
                    function n(t) {
                        const e = [];
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n],
                                r = new wh;
                            r.curves = i.curves, e.push(r)
                        }
                        return e
                    }

                    function i(t, e) {
                        const n = e.length;
                        let i = !1;
                        for (let r = n - 1, s = 0; s < n; r = s++) {
                            let n = e[r],
                                o = e[s],
                                a = o.x - n.x,
                                l = o.y - n.y;
                            if (Math.abs(l) > Number.EPSILON) {
                                if (l < 0 && (n = e[s], a = -a, o = e[r], l = -l), t.y < n.y || t.y > o.y) continue;
                                if (t.y === n.y) {
                                    if (t.x === n.x) return !0
                                } else {
                                    const e = l * (t.x - n.x) - a * (t.y - n.y);
                                    if (0 === e) return !0;
                                    if (e < 0) continue;
                                    i = !i
                                }
                            } else {
                                if (t.y !== n.y) continue;
                                if (o.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= o.x) return !0
                            }
                        }
                        return i
                    }
                    const r = ac.isClockWise,
                        s = this.subPaths;
                    if (0 === s.length) return [];
                    if (!0 === e) return n(s);
                    let o, a, l;
                    const c = [];
                    if (1 === s.length) return a = s[0], l = new wh, l.curves = a.curves, c.push(l), c;
                    let h = !r(s[0].getPoints());
                    h = t ? !h : h;
                    const u = [],
                        d = [];
                    let p, m, f = [],
                        g = 0;
                    d[g] = void 0, f[g] = [];
                    for (let v = 0, y = s.length; v < y; v++) a = s[v], p = a.getPoints(), o = r(p), o = t ? !o : o, o ? (!h && d[g] && g++, d[g] = {
                        s: new wh,
                        p: p
                    }, d[g].s.curves = a.curves, h && g++, f[g] = []) : f[g].push({
                        h: a,
                        p: p[0]
                    });
                    if (!d[0]) return n(s);
                    if (d.length > 1) {
                        let t = !1;
                        const e = [];
                        for (let n = 0, i = d.length; n < i; n++) u[n] = [];
                        for (let n = 0, r = d.length; n < r; n++) {
                            const r = f[n];
                            for (let s = 0; s < r.length; s++) {
                                const o = r[s];
                                let a = !0;
                                for (let r = 0; r < d.length; r++) i(o.p, d[r].p) && (n !== r && e.push({
                                    froms: n,
                                    tos: r,
                                    hole: s
                                }), a ? (a = !1, u[r].push(o)) : t = !0);
                                a && u[n].push(o)
                            }
                        }
                        e.length > 0 && (t || (f = u))
                    }
                    for (let v = 0, y = d.length; v < y; v++) {
                        l = d[v].s, c.push(l), m = f[v];
                        for (let t = 0, e = m.length; t < e; t++) l.holes.push(m[t].h)
                    }
                    return c
                }
            }), Object.assign(Wh.prototype, {
                isFont: !0,
                generateShapes: function(t, e) {
                    void 0 === e && (e = 100);
                    const n = [],
                        i = function(t, e, n) {
                            const i = Array.from ? Array.from(t) : String(t).split(""),
                                r = e / n.resolution,
                                s = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r,
                                o = [];
                            let a = 0,
                                l = 0;
                            for (let c = 0; c < i.length; c++) {
                                const t = i[c];
                                if ("\n" === t) a = 0, l -= s;
                                else {
                                    const e = qh(t, r, a, l, n);
                                    a += e.offsetX, o.push(e.path)
                                }
                            }
                            return o
                        }(t, e, this.data);
                    for (let r = 0, s = i.length; r < s; r++) Array.prototype.push.apply(n, i[r].toShapes());
                    return n
                }
            }), Xh.prototype = Object.assign(Object.create(Wc.prototype), {
                constructor: Xh,
                load: function(t, e, n, i) {
                    const r = this,
                        s = new Xc(this.manager);
                    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(t) {
                        let n;
                        try {
                            n = JSON.parse(t)
                        } catch (s) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                        }
                        const i = r.parse(n);
                        e && e(i)
                    }), n, i)
                },
                parse: function(t) {
                    return new Wh(t)
                }
            });
            const Jh = function() {
                return void 0 === Yh && (Yh = new(window.AudioContext || window.webkitAudioContext)), Yh
            };

            function Zh(t) {
                Wc.call(this, t)
            }

            function Kh(t, e, n) {
                Fh.call(this, void 0, n);
                const i = (new lr).set(t),
                    r = (new lr).set(e),
                    s = new Hn(i.r, i.g, i.b),
                    o = new Hn(r.r, r.g, r.b),
                    a = Math.sqrt(Math.PI),
                    l = a * Math.sqrt(.75);
                this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)
            }

            function $h(t, e) {
                Fh.call(this, void 0, e);
                const n = (new lr).set(t);
                this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }
            Zh.prototype = Object.assign(Object.create(Wc.prototype), {
                constructor: Zh,
                load: function(t, e, n, i) {
                    const r = this,
                        s = new Xc(r.manager);
                    s.setResponseType("arraybuffer"), s.setPath(r.path), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(t, (function(n) {
                        try {
                            const t = n.slice(0);
                            Jh().decodeAudioData(t, (function(t) {
                                e(t)
                            }))
                        } catch (s) {
                            i ? i(s) : console.error(s), r.manager.itemError(t)
                        }
                    }), n, i)
                }
            }), Kh.prototype = Object.assign(Object.create(Fh.prototype), {
                constructor: Kh,
                isHemisphereLightProbe: !0,
                copy: function(t) {
                    return Fh.prototype.copy.call(this, t), this
                },
                toJSON: function(t) {
                    return Fh.prototype.toJSON.call(this, t)
                }
            }), $h.prototype = Object.assign(Object.create(Fh.prototype), {
                constructor: $h,
                isAmbientLightProbe: !0,
                copy: function(t) {
                    return Fh.prototype.copy.call(this, t), this
                },
                toJSON: function(t) {
                    return Fh.prototype.toJSON.call(this, t)
                }
            });
            const Qh = new fi,
                tu = new fi;
            Object.assign(function() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new cs, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new cs, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
                    focus: null,
                    fov: null,
                    aspect: null,
                    near: null,
                    far: null,
                    zoom: null,
                    eyeSep: null
                }
            }.prototype, {
                update: function(t) {
                    const e = this._cache;
                    if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
                        e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
                        const n = t.projectionMatrix.clone(),
                            i = e.eyeSep / 2,
                            r = i * e.near / e.focus,
                            s = e.near * Math.tan(Pn.DEG2RAD * e.fov * .5) / e.zoom;
                        let o, a;
                        tu.elements[12] = -i, Qh.elements[12] = i, o = -s * e.aspect + r, a = s * e.aspect + r, n.elements[0] = 2 * e.near / (a - o), n.elements[8] = (a + o) / (a - o), this.cameraL.projectionMatrix.copy(n), o = -s * e.aspect - r, a = s * e.aspect - r, n.elements[0] = 2 * e.near / (a - o), n.elements[8] = (a + o) / (a - o), this.cameraR.projectionMatrix.copy(n)
                    }
                    this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(tu), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Qh)
                }
            });

            function eu(t, e, n) {
                let i, r, s;
                switch (this.binding = t, this.valueSize = n, e) {
                    case "quaternion":
                        i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                        break;
                    case "string":
                    case "bool":
                        i = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                        break;
                    default:
                        i = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                }
                this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
            }
            Object.assign(eu.prototype, {
                accumulate: function(t, e) {
                    const n = this.buffer,
                        i = this.valueSize,
                        r = t * i + i;
                    let s = this.cumulativeWeight;
                    if (0 === s) {
                        for (let t = 0; t !== i; ++t) n[r + t] = n[t];
                        s = e
                    } else {
                        s += e;
                        const t = e / s;
                        this._mixBufferRegion(n, r, 0, t, i)
                    }
                    this.cumulativeWeight = s
                },
                accumulateAdditive: function(t) {
                    const e = this.buffer,
                        n = this.valueSize,
                        i = n * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t
                },
                apply: function(t) {
                    const e = this.valueSize,
                        n = this.buffer,
                        i = t * e + e,
                        r = this.cumulativeWeight,
                        s = this.cumulativeWeightAdditive,
                        o = this.binding;
                    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                        const t = e * this._origIndex;
                        this._mixBufferRegion(n, i, t, 1 - r, e)
                    }
                    s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
                    for (let a = e, l = e + e; a !== l; ++a)
                        if (n[a] !== n[a + e]) {
                            o.setValue(n, i);
                            break
                        }
                },
                saveOriginalState: function() {
                    const t = this.binding,
                        e = this.buffer,
                        n = this.valueSize,
                        i = n * this._origIndex;
                    t.getValue(e, i);
                    for (let r = n, s = i; r !== s; ++r) e[r] = e[i + r % n];
                    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                },
                restoreOriginalState: function() {
                    const t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t)
                },
                _setAdditiveIdentityNumeric: function() {
                    const t = this._addIndex * this.valueSize,
                        e = t + this.valueSize;
                    for (let n = t; n < e; n++) this.buffer[n] = 0
                },
                _setAdditiveIdentityQuaternion: function() {
                    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                },
                _setAdditiveIdentityOther: function() {
                    const t = this._origIndex * this.valueSize,
                        e = this._addIndex * this.valueSize;
                    for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
                },
                _select: function(t, e, n, i, r) {
                    if (i >= .5)
                        for (let s = 0; s !== r; ++s) t[e + s] = t[n + s]
                },
                _slerp: function(t, e, n, i) {
                    Bn.slerpFlat(t, e, t, e, t, n, i)
                },
                _slerpAdditive: function(t, e, n, i, r) {
                    const s = this._workIndex * r;
                    Bn.multiplyQuaternionsFlat(t, s, t, e, t, n), Bn.slerpFlat(t, e, t, e, t, s, i)
                },
                _lerp: function(t, e, n, i, r) {
                    const s = 1 - i;
                    for (let o = 0; o !== r; ++o) {
                        const r = e + o;
                        t[r] = t[r] * s + t[n + o] * i
                    }
                },
                _lerpAdditive: function(t, e, n, i, r) {
                    for (let s = 0; s !== r; ++s) {
                        const r = e + s;
                        t[r] = t[r] + t[n + s] * i
                    }
                }
            });
            const nu = new RegExp("[\\[\\]\\.:\\/]", "g"),
                iu = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                ru = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                su = /(WCOD+)?/.source.replace("WCOD", iu),
                ou = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                au = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                lu = new RegExp("^" + ru + su + ou + au + "$"),
                cu = ["material", "materials", "bones"];

            function hu(t, e, n) {
                const i = n || uu.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, i)
            }

            function uu(t, e, n) {
                this.path = e, this.parsedPath = n || uu.parseTrackName(e), this.node = uu.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
            }
            Object.assign(hu.prototype, {
                getValue: function(t, e) {
                    this.bind();
                    const n = this._targetGroup.nCachedObjects_,
                        i = this._bindings[n];
                    void 0 !== i && i.getValue(t, e)
                },
                setValue: function(t, e) {
                    const n = this._bindings;
                    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
                },
                bind: function() {
                    const t = this._bindings;
                    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                },
                unbind: function() {
                    const t = this._bindings;
                    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                }
            }), Object.assign(uu, {
                Composite: hu,
                create: function(t, e, n) {
                    return t && t.isAnimationObjectGroup ? new uu.Composite(t, e, n) : new uu(t, e, n)
                },
                sanitizeNodeName: function(t) {
                    return t.replace(/\s/g, "_").replace(nu, "")
                },
                parseTrackName: function(t) {
                    const e = lu.exec(t);
                    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                    const n = {
                            nodeName: e[2],
                            objectName: e[3],
                            objectIndex: e[4],
                            propertyName: e[5],
                            propertyIndex: e[6]
                        },
                        i = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== i && -1 !== i) {
                        const t = n.nodeName.substring(i + 1); - 1 !== cu.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return n
                },
                findNode: function(t, e) {
                    if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                    if (t.skeleton) {
                        const n = t.skeleton.getBoneByName(e);
                        if (void 0 !== n) return n
                    }
                    if (t.children) {
                        const n = function(t) {
                                for (let i = 0; i < t.length; i++) {
                                    const r = t[i];
                                    if (r.name === e || r.uuid === e) return r;
                                    const s = n(r.children);
                                    if (s) return s
                                }
                                return null
                            },
                            i = n(t.children);
                        if (i) return i
                    }
                    return null
                }
            }), Object.assign(uu.prototype, {
                _getValue_unavailable: function() {},
                _setValue_unavailable: function() {},
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function(t, e) {
                    t[e] = this.node[this.propertyName]
                }, function(t, e) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
                }, function(t, e) {
                    t[e] = this.resolvedProperty[this.propertyIndex]
                }, function(t, e) {
                    this.resolvedProperty.toArray(t, e)
                }],
                SetterByBindingTypeAndVersioning: [
                    [function(t, e) {
                        this.targetObject[this.propertyName] = t[e]
                    }, function(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
                    }, function(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                        this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e]
                    }, function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        this.resolvedProperty.fromArray(t, e)
                    }, function(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                    }]
                ],
                getValue: function(t, e) {
                    this.bind(), this.getValue(t, e)
                },
                setValue: function(t, e) {
                    this.bind(), this.setValue(t, e)
                },
                bind: function() {
                    let t = this.node;
                    const e = this.parsedPath,
                        n = e.objectName,
                        i = e.propertyName;
                    let r = e.propertyIndex;
                    if (t || (t = uu.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                    if (n) {
                        let i = e.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                t = t.skeleton.bones;
                                for (let e = 0; e < t.length; e++)
                                    if (t[e].name === i) {
                                        i = e;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                t = t[n]
                        }
                        if (void 0 !== i) {
                            if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                            t = t[i]
                        }
                    }
                    const s = t[i];
                    if (void 0 === s) {
                        const n = e.nodeName;
                        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
                    }
                    let o = this.Versioning.None;
                    this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                    let a = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === i) {
                            if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                        }
                        a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
                },
                unbind: function() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }), Object.assign(uu.prototype, {
                _getValue_unbound: uu.prototype.getValue,
                _setValue_unbound: uu.prototype.setValue
            }), Object.assign(function() {
                this.uuid = Pn.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                const t = {};
                this._indicesByUUID = t;
                for (let n = 0, i = arguments.length; n !== i; ++n) t[arguments[n].uuid] = n;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                const e = this;
                this.stats = {
                    objects: {
                        get total() {
                            return e._objects.length
                        },
                        get inUse() {
                            return this.total - e.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return e._bindings.length
                    }
                }
            }.prototype, {
                isAnimationObjectGroup: !0,
                add: function() {
                    const t = this._objects,
                        e = this._indicesByUUID,
                        n = this._paths,
                        i = this._parsedPaths,
                        r = this._bindings,
                        s = r.length;
                    let o = void 0,
                        a = t.length,
                        l = this.nCachedObjects_;
                    for (let c = 0, h = arguments.length; c !== h; ++c) {
                        const h = arguments[c],
                            u = h.uuid;
                        let d = e[u];
                        if (void 0 === d) {
                            d = a++, e[u] = d, t.push(h);
                            for (let t = 0, e = s; t !== e; ++t) r[t].push(new uu(h, n[t], i[t]))
                        } else if (d < l) {
                            o = t[d];
                            const a = --l,
                                c = t[a];
                            e[c.uuid] = d, t[d] = c, e[u] = a, t[a] = h;
                            for (let t = 0, e = s; t !== e; ++t) {
                                const e = r[t],
                                    s = e[a];
                                let o = e[d];
                                e[d] = s, void 0 === o && (o = new uu(h, n[t], i[t])), e[a] = o
                            }
                        } else t[d] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                    }
                    this.nCachedObjects_ = l
                },
                remove: function() {
                    const t = this._objects,
                        e = this._indicesByUUID,
                        n = this._bindings,
                        i = n.length;
                    let r = this.nCachedObjects_;
                    for (let s = 0, o = arguments.length; s !== o; ++s) {
                        const o = arguments[s],
                            a = o.uuid,
                            l = e[a];
                        if (void 0 !== l && l >= r) {
                            const s = r++,
                                c = t[s];
                            e[c.uuid] = l, t[l] = c, e[a] = s, t[s] = o;
                            for (let t = 0, e = i; t !== e; ++t) {
                                const e = n[t],
                                    i = e[s],
                                    r = e[l];
                                e[l] = i, e[s] = r
                            }
                        }
                    }
                    this.nCachedObjects_ = r
                },
                uncache: function() {
                    const t = this._objects,
                        e = this._indicesByUUID,
                        n = this._bindings,
                        i = n.length;
                    let r = this.nCachedObjects_,
                        s = t.length;
                    for (let o = 0, a = arguments.length; o !== a; ++o) {
                        const a = arguments[o].uuid,
                            l = e[a];
                        if (void 0 !== l)
                            if (delete e[a], l < r) {
                                const o = --r,
                                    a = t[o],
                                    c = --s,
                                    h = t[c];
                                e[a.uuid] = l, t[l] = a, e[h.uuid] = o, t[o] = h, t.pop();
                                for (let t = 0, e = i; t !== e; ++t) {
                                    const e = n[t],
                                        i = e[o],
                                        r = e[c];
                                    e[l] = i, e[o] = r, e.pop()
                                }
                            } else {
                                const r = --s,
                                    o = t[r];
                                e[o.uuid] = l, t[l] = o, t.pop();
                                for (let t = 0, e = i; t !== e; ++t) {
                                    const e = n[t];
                                    e[l] = e[r], e.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = r
                },
                subscribe_: function(t, e) {
                    const n = this._bindingsIndicesByPath;
                    let i = n[t];
                    const r = this._bindings;
                    if (void 0 !== i) return r[i];
                    const s = this._paths,
                        o = this._parsedPaths,
                        a = this._objects,
                        l = a.length,
                        c = this.nCachedObjects_,
                        h = new Array(l);
                    i = r.length, n[t] = i, s.push(t), o.push(e), r.push(h);
                    for (let u = c, d = a.length; u !== d; ++u) {
                        const n = a[u];
                        h[u] = new uu(n, t, e)
                    }
                    return h
                },
                unsubscribe_: function(t) {
                    const e = this._bindingsIndicesByPath,
                        n = e[t];
                    if (void 0 !== n) {
                        const i = this._paths,
                            r = this._parsedPaths,
                            s = this._bindings,
                            o = s.length - 1,
                            a = s[o];
                        e[t[o]] = n, s[n] = a, s.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop()
                    }
                }
            });
            class du {
                constructor(t, e, n, i) {
                    this._mixer = t, this._clip = e, this._localRoot = n || null, this.blendMode = i || e.blendMode;
                    const r = e.tracks,
                        s = r.length,
                        o = new Array(s),
                        a = {
                            endingStart: sn,
                            endingEnd: sn
                        };
                    for (let l = 0; l !== s; ++l) {
                        const t = r[l].createInterpolant(null);
                        o[l] = t, t.settings = a
                    }
                    this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = en, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                }
                play() {
                    return this._mixer._activateAction(this), this
                }
                stop() {
                    return this._mixer._deactivateAction(this), this.reset()
                }
                reset() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                }
                isRunning() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                }
                isScheduled() {
                    return this._mixer._isActiveAction(this)
                }
                startAt(t) {
                    return this._startTime = t, this
                }
                setLoop(t, e) {
                    return this.loop = t, this.repetitions = e, this
                }
                setEffectiveWeight(t) {
                    return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                }
                getEffectiveWeight() {
                    return this._effectiveWeight
                }
                fadeIn(t) {
                    return this._scheduleFading(t, 0, 1)
                }
                fadeOut(t) {
                    return this._scheduleFading(t, 1, 0)
                }
                crossFadeFrom(t, e, n) {
                    if (t.fadeOut(e), this.fadeIn(e), n) {
                        const n = this._clip.duration,
                            i = t._clip.duration,
                            r = i / n,
                            s = n / i;
                        t.warp(1, r, e), this.warp(s, 1, e)
                    }
                    return this
                }
                crossFadeTo(t, e, n) {
                    return t.crossFadeFrom(this, e, n)
                }
                stopFading() {
                    const t = this._weightInterpolant;
                    return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                }
                setEffectiveTimeScale(t) {
                    return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                }
                getEffectiveTimeScale() {
                    return this._effectiveTimeScale
                }
                setDuration(t) {
                    return this.timeScale = this._clip.duration / t, this.stopWarping()
                }
                syncWith(t) {
                    return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                }
                halt(t) {
                    return this.warp(this._effectiveTimeScale, 0, t)
                }
                warp(t, e, n) {
                    const i = this._mixer,
                        r = i.time,
                        s = this.timeScale;
                    let o = this._timeScaleInterpolant;
                    null === o && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
                    const a = o.parameterPositions,
                        l = o.sampleValues;
                    return a[0] = r, a[1] = r + n, l[0] = t / s, l[1] = e / s, this
                }
                stopWarping() {
                    const t = this._timeScaleInterpolant;
                    return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                }
                getMixer() {
                    return this._mixer
                }
                getClip() {
                    return this._clip
                }
                getRoot() {
                    return this._localRoot || this._mixer._root
                }
                _update(t, e, n, i) {
                    if (!this.enabled) return void this._updateWeight(t);
                    const r = this._startTime;
                    if (null !== r) {
                        const i = (t - r) * n;
                        if (i < 0 || 0 === n) return;
                        this._startTime = null, e = n * i
                    }
                    e *= this._updateTimeScale(t);
                    const s = this._updateTime(e),
                        o = this._updateWeight(t);
                    if (o > 0) {
                        const t = this._interpolants,
                            e = this._propertyBindings;
                        switch (this.blendMode) {
                            case cn:
                                for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(s), e[n].accumulateAdditive(o);
                                break;
                            case ln:
                            default:
                                for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(s), e[n].accumulate(i, o)
                        }
                    }
                }
                _updateWeight(t) {
                    let e = 0;
                    if (this.enabled) {
                        e = this.weight;
                        const n = this._weightInterpolant;
                        if (null !== n) {
                            const i = n.evaluate(t)[0];
                            e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = e, e
                }
                _updateTimeScale(t) {
                    let e = 0;
                    if (!this.paused) {
                        e = this.timeScale;
                        const n = this._timeScaleInterpolant;
                        if (null !== n) {
                            e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                        }
                    }
                    return this._effectiveTimeScale = e, e
                }
                _updateTime(t) {
                    const e = this._clip.duration,
                        n = this.loop;
                    let i = this.time + t,
                        r = this._loopCount;
                    const s = n === nn;
                    if (0 === t) return -1 === r ? i : s && 1 === (1 & r) ? e - i : i;
                    if (n === tn) {
                        -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        t: {
                            if (i >= e) i = e;
                            else {
                                if (!(i < 0)) {
                                    this.time = i;
                                    break t
                                }
                                i = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = i,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), i >= e || i < 0) {
                            const n = Math.floor(i / e);
                            i -= e * n, r += Math.abs(n);
                            const o = this.repetitions - r;
                            if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t > 0 ? 1 : -1
                            });
                            else {
                                if (1 === o) {
                                    const e = t < 0;
                                    this._setEndings(e, !e, s)
                                } else this._setEndings(!1, !1, s);
                                this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: n
                                })
                            }
                        } else this.time = i;
                        if (s && 1 === (1 & r)) return e - i
                    }
                    return i
                }
                _setEndings(t, e, n) {
                    const i = this._interpolantSettings;
                    n ? (i.endingStart = on, i.endingEnd = on) : (i.endingStart = t ? this.zeroSlopeAtStart ? on : sn : an, i.endingEnd = e ? this.zeroSlopeAtEnd ? on : sn : an)
                }
                _scheduleFading(t, e, n) {
                    const i = this._mixer,
                        r = i.time;
                    let s = this._weightInterpolant;
                    null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s);
                    const o = s.parameterPositions,
                        a = s.sampleValues;
                    return o[0] = r, a[0] = e, o[1] = r + t, a[1] = n, this
                }
            }

            function pu(t) {
                this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }
            pu.prototype = Object.assign(Object.create(An.prototype), {
                constructor: pu,
                _bindAction: function(t, e) {
                    const n = t._localRoot || this._root,
                        i = t._clip.tracks,
                        r = i.length,
                        s = t._propertyBindings,
                        o = t._interpolants,
                        a = n.uuid,
                        l = this._bindingsByRootAndName;
                    let c = l[a];
                    void 0 === c && (c = {}, l[a] = c);
                    for (let h = 0; h !== r; ++h) {
                        const t = i[h],
                            r = t.name;
                        let l = c[r];
                        if (void 0 !== l) s[h] = l;
                        else {
                            if (l = s[h], void 0 !== l) {
                                null === l._cacheIndex && (++l.referenceCount, this._addInactiveBinding(l, a, r));
                                continue
                            }
                            const i = e && e._propertyBindings[h].binding.parsedPath;
                            l = new eu(uu.create(n, r, i), t.ValueTypeName, t.getValueSize()), ++l.referenceCount, this._addInactiveBinding(l, a, r), s[h] = l
                        }
                        o[h].resultBuffer = l.buffer
                    }
                },
                _activateAction: function(t) {
                    if (!this._isActiveAction(t)) {
                        if (null === t._cacheIndex) {
                            const e = (t._localRoot || this._root).uuid,
                                n = t._clip.uuid,
                                i = this._actionsByClip[n];
                            this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                        }
                        const e = t._propertyBindings;
                        for (let t = 0, n = e.length; t !== n; ++t) {
                            const n = e[t];
                            0 === n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                        }
                        this._lendAction(t)
                    }
                },
                _deactivateAction: function(t) {
                    if (this._isActiveAction(t)) {
                        const e = t._propertyBindings;
                        for (let t = 0, n = e.length; t !== n; ++t) {
                            const n = e[t];
                            0 === --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                        }
                        this._takeBackAction(t)
                    }
                },
                _initMemoryManager: function() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    const t = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return t._actions.length
                            },
                            get inUse() {
                                return t._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return t._bindings.length
                            },
                            get inUse() {
                                return t._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return t._controlInterpolants.length
                            },
                            get inUse() {
                                return t._nActiveControlInterpolants
                            }
                        }
                    }
                },
                _isActiveAction: function(t) {
                    const e = t._cacheIndex;
                    return null !== e && e < this._nActiveActions
                },
                _addInactiveAction: function(t, e, n) {
                    const i = this._actions,
                        r = this._actionsByClip;
                    let s = r[e];
                    if (void 0 === s) s = {
                        knownActions: [t],
                        actionByRoot: {}
                    }, t._byClipCacheIndex = 0, r[e] = s;
                    else {
                        const e = s.knownActions;
                        t._byClipCacheIndex = e.length, e.push(t)
                    }
                    t._cacheIndex = i.length, i.push(t), s.actionByRoot[n] = t
                },
                _removeInactiveAction: function(t) {
                    const e = this._actions,
                        n = e[e.length - 1],
                        i = t._cacheIndex;
                    n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
                    const r = t._clip.uuid,
                        s = this._actionsByClip,
                        o = s[r],
                        a = o.knownActions,
                        l = a[a.length - 1],
                        c = t._byClipCacheIndex;
                    l._byClipCacheIndex = c, a[c] = l, a.pop(), t._byClipCacheIndex = null, delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete s[r], this._removeInactiveBindingsForAction(t)
                },
                _removeInactiveBindingsForAction: function(t) {
                    const e = t._propertyBindings;
                    for (let n = 0, i = e.length; n !== i; ++n) {
                        const t = e[n];
                        0 === --t.referenceCount && this._removeInactiveBinding(t)
                    }
                },
                _lendAction: function(t) {
                    const e = this._actions,
                        n = t._cacheIndex,
                        i = this._nActiveActions++,
                        r = e[i];
                    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                },
                _takeBackAction: function(t) {
                    const e = this._actions,
                        n = t._cacheIndex,
                        i = --this._nActiveActions,
                        r = e[i];
                    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                },
                _addInactiveBinding: function(t, e, n) {
                    const i = this._bindingsByRootAndName,
                        r = this._bindings;
                    let s = i[e];
                    void 0 === s && (s = {}, i[e] = s), s[n] = t, t._cacheIndex = r.length, r.push(t)
                },
                _removeInactiveBinding: function(t) {
                    const e = this._bindings,
                        n = t.binding,
                        i = n.rootNode.uuid,
                        r = n.path,
                        s = this._bindingsByRootAndName,
                        o = s[i],
                        a = e[e.length - 1],
                        l = t._cacheIndex;
                    a._cacheIndex = l, e[l] = a, e.pop(), delete o[r], 0 === Object.keys(o).length && delete s[i]
                },
                _lendBinding: function(t) {
                    const e = this._bindings,
                        n = t._cacheIndex,
                        i = this._nActiveBindings++,
                        r = e[i];
                    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                },
                _takeBackBinding: function(t) {
                    const e = this._bindings,
                        n = t._cacheIndex,
                        i = --this._nActiveBindings,
                        r = e[i];
                    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                },
                _lendControlInterpolant: function() {
                    const t = this._controlInterpolants,
                        e = this._nActiveControlInterpolants++;
                    let n = t[e];
                    return void 0 === n && (n = new Cc(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
                },
                _takeBackControlInterpolant: function(t) {
                    const e = this._controlInterpolants,
                        n = t.__cacheIndex,
                        i = --this._nActiveControlInterpolants,
                        r = e[i];
                    t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function(t, e, n) {
                    const i = e || this._root,
                        r = i.uuid;
                    let s = "string" === typeof t ? Hc.findByName(i, t) : t;
                    const o = null !== s ? s.uuid : t,
                        a = this._actionsByClip[o];
                    let l = null;
                    if (void 0 === n && (n = null !== s ? s.blendMode : ln), void 0 !== a) {
                        const t = a.actionByRoot[r];
                        if (void 0 !== t && t.blendMode === n) return t;
                        l = a.knownActions[0], null === s && (s = l._clip)
                    }
                    if (null === s) return null;
                    const c = new du(this, s, e, n);
                    return this._bindAction(c, l), this._addInactiveAction(c, o, r), c
                },
                existingAction: function(t, e) {
                    const n = e || this._root,
                        i = n.uuid,
                        r = "string" === typeof t ? Hc.findByName(n, t) : t,
                        s = r ? r.uuid : t,
                        o = this._actionsByClip[s];
                    return void 0 !== o && o.actionByRoot[i] || null
                },
                stopAllAction: function() {
                    const t = this._actions;
                    for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
                    return this
                },
                update: function(t) {
                    t *= this.timeScale;
                    const e = this._actions,
                        n = this._nActiveActions,
                        i = this.time += t,
                        r = Math.sign(t),
                        s = this._accuIndex ^= 1;
                    for (let l = 0; l !== n; ++l) {
                        e[l]._update(i, t, r, s)
                    }
                    const o = this._bindings,
                        a = this._nActiveBindings;
                    for (let l = 0; l !== a; ++l) o[l].apply(s);
                    return this
                },
                setTime: function(t) {
                    this.time = 0;
                    for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
                    return this.update(t)
                },
                getRoot: function() {
                    return this._root
                },
                uncacheClip: function(t) {
                    const e = this._actions,
                        n = t.uuid,
                        i = this._actionsByClip,
                        r = i[n];
                    if (void 0 !== r) {
                        const t = r.knownActions;
                        for (let n = 0, i = t.length; n !== i; ++n) {
                            const i = t[n];
                            this._deactivateAction(i);
                            const r = i._cacheIndex,
                                s = e[e.length - 1];
                            i._cacheIndex = null, i._byClipCacheIndex = null, s._cacheIndex = r, e[r] = s, e.pop(), this._removeInactiveBindingsForAction(i)
                        }
                        delete i[n]
                    }
                },
                uncacheRoot: function(t) {
                    const e = t.uuid,
                        n = this._actionsByClip;
                    for (const r in n) {
                        const t = n[r].actionByRoot[e];
                        void 0 !== t && (this._deactivateAction(t), this._removeInactiveAction(t))
                    }
                    const i = this._bindingsByRootAndName[e];
                    if (void 0 !== i)
                        for (const r in i) {
                            const t = i[r];
                            t.restoreOriginalState(), this._removeInactiveBinding(t)
                        }
                },
                uncacheAction: function(t, e) {
                    const n = this.existingAction(t, e);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            });
            class mu {
                constructor(t) {
                    "string" === typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
                }
                clone() {
                    return new mu(void 0 === this.value.clone ? this.value : this.value.clone())
                }
            }

            function fu(t, e, n) {
                Ca.call(this, t, e), this.meshPerAttribute = n || 1
            }

            function gu(t, e, n, i, r) {
                this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0
            }

            function vu(t, e, n, i) {
                this.ray = new mi(t, e), this.near = n || 0, this.far = i || 1 / 0, this.camera = null, this.layers = new Ei, this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                        }
                    }
                })
            }

            function yu(t, e) {
                return t.distance - e.distance
            }

            function xu(t, e, n, i) {
                if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) {
                    const i = t.children;
                    for (let t = 0, r = i.length; t < r; t++) xu(i[t], e, n, !0)
                }
            }
            fu.prototype = Object.assign(Object.create(Ca.prototype), {
                constructor: fu,
                isInstancedInterleavedBuffer: !0,
                copy: function(t) {
                    return Ca.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                },
                clone: function(t) {
                    const e = Ca.prototype.clone.call(this, t);
                    return e.meshPerAttribute = this.meshPerAttribute, e
                },
                toJSON: function(t) {
                    const e = Ca.prototype.toJSON.call(this, t);
                    return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
                }
            }), Object.defineProperty(gu.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(gu.prototype, {
                isGLBufferAttribute: !0,
                setBuffer: function(t) {
                    return this.buffer = t, this
                },
                setType: function(t, e) {
                    return this.type = t, this.elementSize = e, this
                },
                setItemSize: function(t) {
                    return this.itemSize = t, this
                },
                setCount: function(t) {
                    return this.count = t, this
                }
            }), Object.assign(vu.prototype, {
                set: function(t, e) {
                    this.ray.set(t, e)
                },
                setFromCamera: function(t, e) {
                    e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type.")
                },
                intersectObject: function(t, e, n) {
                    const i = n || [];
                    return xu(t, this, i, e), i.sort(yu), i
                },
                intersectObjects: function(t, e, n) {
                    const i = n || [];
                    if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
                    for (let r = 0, s = t.length; r < s; r++) xu(t[r], this, i, e);
                    return i.sort(yu), i
                }
            });
            class bu {
                constructor(t = 1, e = 0, n = 0) {
                    return this.radius = t, this.phi = e, this.theta = n, this
                }
                set(t, e, n) {
                    return this.radius = t, this.phi = e, this.theta = n, this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                }
                makeSafe() {
                    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                }
                setFromVector3(t) {
                    return this.setFromCartesianCoords(t.x, t.y, t.z)
                }
                setFromCartesianCoords(t, e, n) {
                    return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Pn.clamp(e / this.radius, -1, 1))), this
                }
            }
            const _u = new Cn;

            function wu(t) {
                Bi.call(this), this.material = t, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
            }
            wu.prototype = Object.create(Bi.prototype), wu.prototype.constructor = wu, wu.prototype.isImmediateRenderObject = !0;
            const Mu = new Hn,
                Su = new fi,
                Tu = new fi;
            class Eu extends yl {
                constructor(t) {
                    const e = function t(e) {
                            const n = [];
                            e && e.isBone && n.push(e);
                            for (let i = 0; i < e.children.length; i++) n.push.apply(n, t(e.children[i]));
                            return n
                        }(t),
                        n = new Nr,
                        i = [],
                        r = [],
                        s = new lr(0, 0, 1),
                        o = new lr(0, 1, 0);
                    for (let a = 0; a < e.length; a++) {
                        const t = e[a];
                        t.parent && t.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(o.r, o.g, o.b))
                    }
                    n.setAttribute("position", new Mr(i, 3)), n.setAttribute("color", new Mr(r, 3)), super(n, new cl({
                        vertexColors: !0,
                        depthTest: !1,
                        depthWrite: !1,
                        toneMapped: !1,
                        transparent: !0
                    })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                }
                updateMatrixWorld(t) {
                    const e = this.bones,
                        n = this.geometry,
                        i = n.getAttribute("position");
                    Tu.getInverse(this.root.matrixWorld);
                    for (let r = 0, s = 0; r < e.length; r++) {
                        const t = e[r];
                        t.parent && t.parent.isBone && (Su.multiplyMatrices(Tu, t.matrixWorld), Mu.setFromMatrixPosition(Su), i.setXYZ(s, Mu.x, Mu.y, Mu.z), Su.multiplyMatrices(Tu, t.parent.matrixWorld), Mu.setFromMatrixPosition(Su), i.setXYZ(s + 1, Mu.x, Mu.y, Mu.z), s += 2)
                    }
                    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                }
            }
            const Au = 4,
                Lu = 8,
                Ru = Math.pow(2, Lu),
                Pu = [.125, .215, .35, .446, .526, .582],
                Cu = Lu - Au + 1 + Pu.length,
                Ou = 20,
                Iu = {
                    [un]: 0,
                    [dn]: 1,
                    [mn]: 2,
                    [gn]: 3,
                    [vn]: 4,
                    [yn]: 5,
                    [pn]: 6
                },
                Nu = new Ph,
                {
                    _lodPlanes: Du,
                    _sizeLods: Fu,
                    _sigmas: Uu
                } = ju();
            let zu = null;
            const ku = (1 + Math.sqrt(5)) / 2,
                Bu = 1 / ku,
                Hu = [new Hn(1, 1, 1), new Hn(-1, 1, 1), new Hn(1, 1, -1), new Hn(-1, 1, -1), new Hn(0, ku, Bu), new Hn(0, ku, -Bu), new Hn(Bu, 0, ku), new Hn(-Bu, 0, ku), new Hn(ku, Bu, 0), new Hn(-ku, Bu, 0)];
            class Gu {
                constructor(t) {
                    this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function(t) {
                        const e = new Float32Array(t),
                            n = new Hn(0, 1, 0);
                        return new yc({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: t
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: e
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: n
                                },
                                inputEncoding: {
                                    value: Iu[un]
                                },
                                outputEncoding: {
                                    value: Iu[un]
                                }
                            },
                            vertexShader: Ju(),
                            fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${Zu()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                            blending: G,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }(Ou), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
                }
                fromScene(t, e = 0, n = .1, i = 100) {
                    zu = this._renderer.getRenderTarget();
                    const r = this._allocateTargets();
                    return this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
                }
                fromEquirectangular(t) {
                    return this._fromTexture(t)
                }
                fromCubemap(t) {
                    return this._fromTexture(t)
                }
                compileCubemapShader() {
                    null === this._cubemapShader && (this._cubemapShader = Yu(), this._compileMaterial(this._cubemapShader))
                }
                compileEquirectangularShader() {
                    null === this._equirectShader && (this._equirectShader = Xu(), this._compileMaterial(this._equirectShader))
                }
                dispose() {
                    this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
                    for (let t = 0; t < Du.length; t++) Du[t].dispose()
                }
                _cleanup(t) {
                    this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(zu), t.scissorTest = !1, qu(t, 0, 0, t.width, t.height)
                }
                _fromTexture(t) {
                    zu = this._renderer.getRenderTarget();
                    const e = this._allocateTargets(t);
                    return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
                }
                _allocateTargets(t) {
                    const e = {
                            magFilter: Ft,
                            minFilter: Ft,
                            generateMipmaps: !1,
                            type: Gt,
                            format: se,
                            encoding: Vu(t) ? t.encoding : mn,
                            depthBuffer: !1
                        },
                        n = Wu(e);
                    return n.depthBuffer = !t, this._pingPongRenderTarget = Wu(e), n
                }
                _compileMaterial(t) {
                    const e = new $r(Du[0], t);
                    this._renderer.compile(e, Nu)
                }
                _sceneToCubeUV(t, e, n, i) {
                    const r = new cs(90, 1, e, n),
                        s = [1, -1, 1, 1, 1, 1],
                        o = [1, 1, 1, -1, -1, -1],
                        a = this._renderer,
                        l = a.outputEncoding,
                        c = a.toneMapping,
                        h = a.getClearColor(),
                        u = a.getClearAlpha();
                    a.toneMapping = _t, a.outputEncoding = un;
                    let d = t.background;
                    if (d && d.isColor) {
                        d.convertSRGBToLinear();
                        const e = Math.max(d.r, d.g, d.b),
                            n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
                        d = d.multiplyScalar(Math.pow(2, -n));
                        const i = (n + 128) / 255;
                        a.setClearColor(d, i), t.background = null
                    }
                    for (let p = 0; p < 6; p++) {
                        const e = p % 3;
                        0 == e ? (r.up.set(0, s[p], 0), r.lookAt(o[p], 0, 0)) : 1 == e ? (r.up.set(0, 0, s[p]), r.lookAt(0, o[p], 0)) : (r.up.set(0, s[p], 0), r.lookAt(0, 0, o[p])), qu(i, e * Ru, p > 2 ? Ru : 0, Ru, Ru), a.setRenderTarget(i), a.render(t, r)
                    }
                    a.toneMapping = c, a.outputEncoding = l, a.setClearColor(h, u)
                }
                _textureToCubeUV(t, e) {
                    const n = this._renderer;
                    t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Yu()) : null == this._equirectShader && (this._equirectShader = Xu());
                    const i = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
                        r = new $r(Du[0], i),
                        s = i.uniforms;
                    s.envMap.value = t, t.isCubeTexture || s.texelSize.value.set(1 / t.image.width, 1 / t.image.height), s.inputEncoding.value = Iu[t.encoding], s.outputEncoding.value = Iu[e.texture.encoding], qu(e, 0, 0, 3 * Ru, 2 * Ru), n.setRenderTarget(e), n.render(r, Nu)
                }
                _applyPMREM(t) {
                    const e = this._renderer,
                        n = e.autoClear;
                    e.autoClear = !1;
                    for (let i = 1; i < Cu; i++) {
                        const e = Math.sqrt(Uu[i] * Uu[i] - Uu[i - 1] * Uu[i - 1]),
                            n = Hu[(i - 1) % Hu.length];
                        this._blur(t, i - 1, i, e, n)
                    }
                    e.autoClear = n
                }
                _blur(t, e, n, i, r) {
                    const s = this._pingPongRenderTarget;
                    this._halfBlur(t, s, e, n, i, "latitudinal", r), this._halfBlur(s, t, n, n, i, "longitudinal", r)
                }
                _halfBlur(t, e, n, i, r, s, o) {
                    const a = this._renderer,
                        l = this._blurMaterial;
                    "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                    const c = new $r(Du[i], l),
                        h = l.uniforms,
                        u = Fu[n] - 1,
                        d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / (2 * Ou - 1),
                        p = r / d,
                        m = isFinite(r) ? 1 + Math.floor(3 * p) : Ou;
                    m > Ou && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Ou}`);
                    const f = [];
                    let g = 0;
                    for (let y = 0; y < Ou; ++y) {
                        const t = y / p,
                            e = Math.exp(-t * t / 2);
                        f.push(e), 0 == y ? g += e : y < m && (g += 2 * e)
                    }
                    for (let y = 0; y < f.length; y++) f[y] = f[y] / g;
                    h.envMap.value = t.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === s, o && (h.poleAxis.value = o), h.dTheta.value = d, h.mipInt.value = Lu - n, h.inputEncoding.value = Iu[t.texture.encoding], h.outputEncoding.value = Iu[t.texture.encoding];
                    const v = Fu[i];
                    qu(e, 3 * Math.max(0, Ru - 2 * v), (0 === i ? 0 : 2 * Ru) + 2 * v * (i > Lu - Au ? i - Lu + Au : 0), 3 * v, 2 * v), a.setRenderTarget(e), a.render(c, Nu)
                }
            }

            function Vu(t) {
                return void 0 !== t && t.type === Gt && (t.encoding === un || t.encoding === dn || t.encoding === pn)
            }

            function ju() {
                const t = [],
                    e = [],
                    n = [];
                let i = Lu;
                for (let r = 0; r < Cu; r++) {
                    const s = Math.pow(2, i);
                    e.push(s);
                    let o = 1 / s;
                    r > Lu - Au ? o = Pu[r - Lu + Au - 1] : 0 == r && (o = 0), n.push(o);
                    const a = 1 / (s - 1),
                        l = -a / 2,
                        c = 1 + a / 2,
                        h = [l, l, c, l, c, c, l, l, c, c, l, c],
                        u = 6,
                        d = 6,
                        p = 3,
                        m = 2,
                        f = 1,
                        g = new Float32Array(p * d * u),
                        v = new Float32Array(m * d * u),
                        y = new Float32Array(f * d * u);
                    for (let t = 0; t < u; t++) {
                        const e = t % 3 * 2 / 3 - 1,
                            n = t > 2 ? 0 : -1,
                            i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                        g.set(i, p * d * t), v.set(h, m * d * t);
                        const r = [t, t, t, t, t, t];
                        y.set(r, f * d * t)
                    }
                    const x = new Nr;
                    x.setAttribute("position", new fr(g, p)), x.setAttribute("uv", new fr(v, m)), x.setAttribute("faceIndex", new fr(y, f)), t.push(x), i > Au && i--
                }
                return {
                    _lodPlanes: t,
                    _sizeLods: e,
                    _sigmas: n
                }
            }

            function Wu(t) {
                const e = new zn(3 * Ru, 3 * Ru, t);
                return e.texture.mapping = Ct, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
            }

            function qu(t, e, n, i, r) {
                t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
            }

            function Xu() {
                return new yc({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        texelSize: {
                            value: new Cn(1, 1)
                        },
                        inputEncoding: {
                            value: Iu[un]
                        },
                        outputEncoding: {
                            value: Iu[un]
                        }
                    },
                    vertexShader: Ju(),
                    fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${Zu()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                    blending: G,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function Yu() {
                return new yc({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        inputEncoding: {
                            value: Iu[un]
                        },
                        outputEncoding: {
                            value: Iu[un]
                        }
                    },
                    vertexShader: Ju(),
                    fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${Zu()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                    blending: G,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function Ju() {
                return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
            }

            function Zu() {
                return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
            }

            function Ku(t) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), lh.call(this, t), this.type = "catmullrom"
            }
            th.create = function(t, e) {
                return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(th.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
            }, Object.assign(bh.prototype, {
                createPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    const e = this.getPoints(t);
                    return this.createGeometry(e)
                },
                createSpacedPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    const e = this.getSpacedPoints(t);
                    return this.createGeometry(e)
                },
                createGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    const e = new Dl;
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n];
                        e.vertices.push(new Hn(i.x, i.y, i.z || 0))
                    }
                    return e
                }
            }), Object.assign(_h.prototype, {
                fromPoints: function(t) {
                    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
                }
            }), Ku.prototype = Object.create(lh.prototype), Object.assign(Ku.prototype, {
                initFromArray: function() {
                    console.error("THREE.Spline: .initFromArray() has been removed.")
                },
                getControlPointsArray: function() {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                },
                reparametrizeByArcLength: function() {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                }
            }), Eu.prototype.update = function() {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, Object.assign(Wc.prototype, {
                extractUrlBase: function(t) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), zh.extractUrlBase(t)
                }
            }), Wc.Handlers = {
                add: function() {
                    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                },
                get: function() {
                    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                }
            }, Object.assign(class {
                constructor(t, e) {
                    Object.defineProperty(this, "isBox2", {
                        value: !0
                    }), this.min = void 0 !== t ? t : new Cn(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Cn(-1 / 0, -1 / 0)
                }
                set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                }
                setFromPoints(t) {
                    this.makeEmpty();
                    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this
                }
                setFromCenterAndSize(t, e) {
                    const n = _u.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                }
                getCenter(t) {
                    return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new Cn), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(t) {
                    return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new Cn), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                }
                expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this
                }
                expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this
                }
                expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                }
                containsPoint(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                }
                containsBox(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                }
                getParameter(t, e) {
                    return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new Cn), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                }
                intersectsBox(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                }
                clampPoint(t, e) {
                    return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new Cn), e.copy(t).clamp(this.min, this.max)
                }
                distanceToPoint(t) {
                    return _u.copy(t).clamp(this.min, this.max).sub(t).length()
                }
                intersect(t) {
                    return this.min.max(t.min), this.max.min(t.max), this
                }
                union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                }
                translate(t) {
                    return this.min.add(t), this.max.add(t), this
                }
                equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), Object.assign(jn.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), Object.assign(oi.prototype, {
                empty: function() {
                    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                }
            }), ys.prototype.setFromMatrix = function(t) {
                return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
            }, Object.assign(Pn, {
                random16: function() {
                    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
                },
                nearestPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Pn.floorPowerOfTwo(t)
                },
                nextPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Pn.ceilPowerOfTwo(t)
                }
            }), Object.assign(On.prototype, {
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                },
                applyToBufferAttribute: function(t) {
                    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }
            }), Object.assign(fi.prototype, {
                extractPosition: function(t) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
                },
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                getPosition: function() {
                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Hn).setFromMatrixColumn(this, 3)
                },
                setRotationFromQuaternion: function(t) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
                },
                multiplyToArray: function() {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector4: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                },
                rotateAxis: function(t) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
                },
                crossVector: function(t) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                translate: function() {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function() {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function() {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function() {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function() {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                applyToBufferAttribute: function(t) {
                    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                },
                makeFrustum: function(t, e, n, i, r, s) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, s)
                }
            }), ji.prototype.isIntersectionLine = function(t) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
            }, Bn.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
            }, Object.assign(mi.prototype, {
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionPlane: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                }
            }), Object.assign(er.prototype, {
                area: function() {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                },
                barycoordFromPoint: function(t, e) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
                },
                midpoint: function(t) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
                },
                normal: function(t) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
                },
                plane: function(t) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
                }
            }), Object.assign(er, {
                barycoordFromPoint: function(t, e, n, i, r) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), er.getBarycoord(t, e, n, i, r)
                },
                normal: function(t, e, n, i) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), er.getNormal(t, e, n, i)
                }
            }), Object.assign(wh.prototype, {
                extractAllPoints: function(t) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
                },
                extrude: function(t) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new dc(this, t)
                },
                makeGeometry: function(t) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new gc(this, t)
                }
            }), Object.assign(Cn.prototype, {
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Hn.prototype, {
                setEulerFromRotationMatrix: function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
                },
                getScaleFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
                },
                getColumnFromMatrix: function(t, e) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
                },
                applyProjection: function(t) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
                },
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Un.prototype, {
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Dl.prototype, {
                computeTangents: function() {
                    console.error("THREE.Geometry: .computeTangents() has been removed.")
                },
                computeLineDistances: function() {
                    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                },
                applyMatrix: function(t) {
                    return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
                }
            }), Object.assign(Bi.prototype, {
                getChildByName: function(t) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
                },
                renderDepth: function() {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function(t, e) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
                },
                getWorldRotation: function() {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                },
                applyMatrix: function(t) {
                    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
                }
            }), Object.defineProperties(Bi.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function(t) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Object.assign($r.prototype, {
                setDrawMode: function() {
                    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }
            }), Object.defineProperties($r.prototype, {
                drawMode: {
                    get: function() {
                        return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                    },
                    set: function() {
                        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                    }
                }
            }), Object.defineProperties($a.prototype, {
                objects: {
                    get: function() {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                    }
                }
            }), Object.defineProperty(nl.prototype, "useVertexTexture", {
                get: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            }), Qa.prototype.initBones = function() {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }, Object.defineProperty(th.prototype, "__arcLengthDivisions", {
                get: function() {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                },
                set: function(t) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
                }
            }), cs.prototype.setLens = function(t, e) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
            }, Object.defineProperties(Mh.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                    }
                },
                shadowCameraLeft: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                    }
                },
                shadowCameraRight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                    }
                },
                shadowCameraTop: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                    }
                },
                shadowCameraBottom: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                    }
                },
                shadowCameraNear: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                    }
                },
                shadowCameraFar: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                    }
                },
                shadowMapHeight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                    }
                }
            }), Object.defineProperties(fr.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                dynamic: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage
                    },
                    set: function() {
                        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048)
                    }
                }
            }), Object.assign(fr.prototype, {
                setDynamic: function(t) {
                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : Tn), this
                },
                copyIndicesArray: function() {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                },
                setArray: function() {
                    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                }
            }), Object.assign(Nr.prototype, {
                addIndex: function(t) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
                },
                addAttribute: function(t, e) {
                    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new fr(arguments[1], arguments[2])))
                },
                addDrawCall: function(t, e, n) {
                    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
                },
                clearDrawCalls: function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                },
                computeTangents: function() {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                },
                removeAttribute: function(t) {
                    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
                },
                applyMatrix: function(t) {
                    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
                }
            }), Object.defineProperties(Nr.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), Object.defineProperties(kh.prototype, {
                maxInstancedCount: {
                    get: function() {
                        return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount
                    },
                    set: function(t) {
                        console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = t
                    }
                }
            }), Object.defineProperties(vu.prototype, {
                linePrecision: {
                    get: function() {
                        return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold
                    },
                    set: function(t) {
                        console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t
                    }
                }
            }), Object.defineProperties(Ca.prototype, {
                dynamic: {
                    get: function() {
                        return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), 35048 === this.usage
                    },
                    set: function(t) {
                        console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t)
                    }
                }
            }), Object.assign(Ca.prototype, {
                setDynamic: function(t) {
                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : Tn), this
                },
                setArray: function() {
                    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                }
            }), Object.assign(hc.prototype, {
                getArrays: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
                },
                addShapeList: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
                },
                addShape: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
                }
            }), Object.assign(Pa.prototype, {
                dispose: function() {
                    console.error("THREE.Scene: .dispose() has been removed.")
                }
            }), Object.defineProperties(mu.prototype, {
                dynamic: {
                    set: function() {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function() {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                    }
                }
            }), Object.defineProperties(ur.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new lr
                    }
                },
                shading: {
                    get: function() {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                    }
                },
                stencilMask: {
                    get: function() {
                        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
                    }
                }
            }), Object.defineProperties(_c.prototype, {
                metal: {
                    get: function() {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(bc.prototype, {
                transparency: {
                    get: function() {
                        return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission
                    },
                    set: function(t) {
                        console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = t
                    }
                }
            }), Object.defineProperties(as.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function(t) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                    }
                }
            }), Object.assign(La.prototype, {
                clearTarget: function(t, e, n, i) {
                    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i)
                },
                animate: function(t) {
                    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
                },
                getCurrentRenderTarget: function() {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                },
                getMaxAnisotropy: function() {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function() {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                },
                resetGLState: function() {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                },
                supportsFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(t) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
                },
                initMaterial: function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                },
                setFaceCulling: function() {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                },
                allocTextureUnit: function() {
                    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
                },
                setTexture: function() {
                    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
                },
                setTexture2D: function() {
                    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
                },
                setTextureCube: function() {
                    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
                },
                getActiveMipMapLevel: function() {
                    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
                }
            }), Object.defineProperties(La.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                context: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                    }
                },
                vr: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                    }
                },
                gammaInput: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                    }
                },
                gammaOutput: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? dn : un
                    }
                },
                toneMappingWhitePoint: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                    }
                }
            }), Object.defineProperties(xa.prototype, {
                cullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(zn.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                    }
                }
            }), Object.defineProperties(class extends Bi {
                constructor(t) {
                    super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                }
                getOutput() {
                    return this.gain
                }
                setNodeSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                }
                setMediaElementSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                }
                setMediaStreamSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
                }
                setBuffer(t) {
                    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                }
                play(t) {
                    if (void 0 === t && (t = 0), !0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                    if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                    this._startedAt = this.context.currentTime + t;
                    const e = this.context.createBufferSource();
                    return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                pause() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                stop() {
                    if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                connect() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this._connected = !0, this
                }
                disconnect() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this._connected = !1, this
                }
                getFilters() {
                    return this.filters
                }
                setFilters(t) {
                    return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
                }
                setDetune(t) {
                    if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                }
                getDetune() {
                    return this.detune
                }
                getFilter() {
                    return this.getFilters()[0]
                }
                setFilter(t) {
                    return this.setFilters(t ? [t] : [])
                }
                setPlaybackRate(t) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                getPlaybackRate() {
                    return this.playbackRate
                }
                onEnded() {
                    this.isPlaying = !1
                }
                getLoop() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                }
                setLoop(t) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                setLoopStart(t) {
                    return this.loopStart = t, this
                }
                setLoopEnd(t) {
                    return this.loopEnd = t, this
                }
                getVolume() {
                    return this.gain.gain.value
                }
                setVolume(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                }
            }.prototype, {
                load: {
                    value: function(t) {
                        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                        const e = this;
                        return (new Zh).load(t, (function(t) {
                            e.setBuffer(t)
                        })), this
                    }
                },
                startTime: {
                    set: function() {
                        console.warn("THREE.Audio: .startTime is now .play( delay ).")
                    }
                }
            }), ds.prototype.updateCubeMap = function(t, e) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
            }, Nn.crossOrigin = void 0, Nn.loadTexture = function(t, e, n, i) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                const r = new Qc;
                r.setCrossOrigin(this.crossOrigin);
                const s = r.load(t, n, void 0, i);
                return e && (s.mapping = e), s
            }, Nn.loadTextureCube = function(t, e, n, i) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                const r = new Kc;
                r.setCrossOrigin(this.crossOrigin);
                const s = r.load(t, n, void 0, i);
                return e && (s.mapping = e), s
            }, Nn.loadCompressedTexture = function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, Nn.loadCompressedTextureCube = function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            }, "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: "121"
                }
            }));
            var $u = function(t) {
                Wc.call(this, t), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                    position: "POSITION",
                    normal: "NORMAL",
                    color: "COLOR",
                    uv: "TEX_COORD"
                }, this.defaultAttributeTypes = {
                    position: "Float32Array",
                    normal: "Float32Array",
                    color: "Float32Array",
                    uv: "Float32Array"
                }
            };
            $u.prototype = Object.assign(Object.create(Wc.prototype), {
                constructor: $u,
                setDecoderPath: function(t) {
                    return this.decoderPath = t, this
                },
                setDecoderConfig: function(t) {
                    return this.decoderConfig = t, this
                },
                setWorkerLimit: function(t) {
                    return this.workerLimit = t, this
                },
                setVerbosity: function() {
                    console.warn("THREE.DRACOLoader: The .setVerbosity() method has been removed.")
                },
                setDrawMode: function() {
                    console.warn("THREE.DRACOLoader: The .setDrawMode() method has been removed.")
                },
                setSkipDequantization: function() {
                    console.warn("THREE.DRACOLoader: The .setSkipDequantization() method has been removed.")
                },
                load: function(t, e, n, i) {
                    var r = new Xc(this.manager);
                    r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(t, t => {
                        var n = {
                            attributeIDs: this.defaultAttributeIDs,
                            attributeTypes: this.defaultAttributeTypes,
                            useUniqueIDs: !1
                        };
                        this.decodeGeometry(t, n).then(e).catch(i)
                    }, n, i)
                },
                decodeDracoFile: function(t, e, n, i) {
                    var r = {
                        attributeIDs: n || this.defaultAttributeIDs,
                        attributeTypes: i || this.defaultAttributeTypes,
                        useUniqueIDs: !!n
                    };
                    this.decodeGeometry(t, r).then(e)
                },
                decodeGeometry: function(t, e) {
                    for (var n in e.attributeTypes) {
                        var i = e.attributeTypes[n];
                        void 0 !== i.BYTES_PER_ELEMENT && (e.attributeTypes[n] = i.name)
                    }
                    var r, s = JSON.stringify(e);
                    if ($u.taskCache.has(t)) {
                        var o = $u.taskCache.get(t);
                        if (o.key === s) return o.promise;
                        if (0 === t.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                    }
                    var a = this.workerNextTaskID++,
                        l = t.byteLength,
                        c = this._getWorker(a, l).then(n => (r = n, new Promise((n, i) => {
                            r._callbacks[a] = {
                                resolve: n,
                                reject: i
                            }, r.postMessage({
                                type: "decode",
                                id: a,
                                taskConfig: e,
                                buffer: t
                            }, [t])
                        }))).then(t => this._createGeometry(t.geometry));
                    return c.catch(() => !0).then(() => {
                        r && a && this._releaseTask(r, a)
                    }), $u.taskCache.set(t, {
                        key: s,
                        promise: c
                    }), c
                },
                _createGeometry: function(t) {
                    var e = new Nr;
                    t.index && e.setIndex(new fr(t.index.array, 1));
                    for (var n = 0; n < t.attributes.length; n++) {
                        var i = t.attributes[n],
                            r = i.name,
                            s = i.array,
                            o = i.itemSize;
                        e.setAttribute(r, new fr(s, o))
                    }
                    return e
                },
                _loadLibrary: function(t, e) {
                    var n = new Xc(this.manager);
                    return n.setPath(this.decoderPath), n.setResponseType(e), n.setWithCredentials(this.withCredentials), new Promise((e, i) => {
                        n.load(t, e, void 0, i)
                    })
                },
                preload: function() {
                    return this._initDecoder(), this
                },
                _initDecoder: function() {
                    if (this.decoderPending) return this.decoderPending;
                    var t = "object" !== typeof WebAssembly || "js" === this.decoderConfig.type,
                        e = [];
                    return t ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(e).then(e => {
                        var n = e[0];
                        t || (this.decoderConfig.wasmBinary = e[1]);
                        var i = $u.DRACOWorker.toString(),
                            r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                        this.workerSourceURL = URL.createObjectURL(new Blob([r]))
                    }), this.decoderPending
                },
                _getWorker: function(t, e) {
                    return this._initDecoder().then(() => {
                        var n;
                        this.workerPool.length < this.workerLimit ? ((n = new Worker(this.workerSourceURL))._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({
                            type: "init",
                            decoderConfig: this.decoderConfig
                        }), n.onmessage = function(t) {
                            var e = t.data;
                            switch (e.type) {
                                case "decode":
                                    n._callbacks[e.id].resolve(e);
                                    break;
                                case "error":
                                    n._callbacks[e.id].reject(e);
                                    break;
                                default:
                                    console.error('THREE.DRACOLoader: Unexpected message, "' + e.type + '"')
                            }
                        }, this.workerPool.push(n)) : this.workerPool.sort((function(t, e) {
                            return t._taskLoad > e._taskLoad ? -1 : 1
                        }));
                        return (n = this.workerPool[this.workerPool.length - 1])._taskCosts[t] = e, n._taskLoad += e, n
                    })
                },
                _releaseTask: function(t, e) {
                    t._taskLoad -= t._taskCosts[e], delete t._callbacks[e], delete t._taskCosts[e]
                },
                debug: function() {
                    console.log("Task load: ", this.workerPool.map(t => t._taskLoad))
                },
                dispose: function() {
                    for (var t = 0; t < this.workerPool.length; ++t) this.workerPool[t].terminate();
                    return this.workerPool.length = 0, this
                }
            }), $u.DRACOWorker = function() {
                var t, e;

                function n(t, e, n, i, r, s) {
                    var o = s.num_components(),
                        a = n.num_points() * o,
                        l = a * r.BYTES_PER_ELEMENT,
                        c = function(t, e) {
                            switch (e) {
                                case Float32Array:
                                    return t.DT_FLOAT32;
                                case Int8Array:
                                    return t.DT_INT8;
                                case Int16Array:
                                    return t.DT_INT16;
                                case Int32Array:
                                    return t.DT_INT32;
                                case Uint8Array:
                                    return t.DT_UINT8;
                                case Uint16Array:
                                    return t.DT_UINT16;
                                case Uint32Array:
                                    return t.DT_UINT32
                            }
                        }(t, r),
                        h = t._malloc(l);
                    e.GetAttributeDataArrayForAllPoints(n, s, c, l, h);
                    var u = new r(t.HEAPF32.buffer, h, a).slice();
                    return t._free(h), {
                        name: i,
                        array: u,
                        itemSize: o
                    }
                }
                onmessage = function(i) {
                    var r = i.data;
                    switch (r.type) {
                        case "init":
                            t = r.decoderConfig, e = new Promise((function(e) {
                                t.onModuleLoaded = function(t) {
                                    e({
                                        draco: t
                                    })
                                }, DracoDecoderModule(t)
                            }));
                            break;
                        case "decode":
                            var s = r.buffer,
                                o = r.taskConfig;
                            e.then(t => {
                                var e = t.draco,
                                    i = new e.Decoder,
                                    a = new e.DecoderBuffer;
                                a.Init(new Int8Array(s), s.byteLength);
                                try {
                                    var l = function(t, e, i, r) {
                                            var s, o, a = r.attributeIDs,
                                                l = r.attributeTypes,
                                                c = e.GetEncodedGeometryType(i);
                                            if (c === t.TRIANGULAR_MESH) s = new t.Mesh, o = e.DecodeBufferToMesh(i, s);
                                            else {
                                                if (c !== t.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                                s = new t.PointCloud, o = e.DecodeBufferToPointCloud(i, s)
                                            }
                                            if (!o.ok() || 0 === s.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + o.error_msg());
                                            var h = {
                                                index: null,
                                                attributes: []
                                            };
                                            for (var u in a) {
                                                var d, p, m = self[l[u]];
                                                if (r.useUniqueIDs) p = a[u], d = e.GetAttributeByUniqueId(s, p);
                                                else {
                                                    if (-1 === (p = e.GetAttributeId(s, t[a[u]]))) continue;
                                                    d = e.GetAttribute(s, p)
                                                }
                                                h.attributes.push(n(t, e, s, u, m, d))
                                            }
                                            c === t.TRIANGULAR_MESH && (h.index = function(t, e, n) {
                                                var i = 3 * n.num_faces(),
                                                    r = 4 * i,
                                                    s = t._malloc(r);
                                                e.GetTrianglesUInt32Array(n, r, s);
                                                var o = new Uint32Array(t.HEAPF32.buffer, s, i).slice();
                                                return t._free(s), {
                                                    array: o,
                                                    itemSize: 1
                                                }
                                            }(t, e, s));
                                            return t.destroy(s), h
                                        }(e, i, a, o),
                                        c = l.attributes.map(t => t.array.buffer);
                                    l.index && c.push(l.index.array.buffer), self.postMessage({
                                        type: "decode",
                                        id: r.id,
                                        geometry: l
                                    }, c)
                                } catch (h) {
                                    console.error(h), self.postMessage({
                                        type: "error",
                                        id: r.id,
                                        error: h.message
                                    })
                                } finally {
                                    e.destroy(a), e.destroy(i)
                                }
                            })
                    }
                }
            }, $u.taskCache = new WeakMap, $u.setDecoderPath = function() {
                console.warn("THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.")
            }, $u.setDecoderConfig = function() {
                console.warn("THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.")
            }, $u.releaseDecoderModule = function() {
                console.warn("THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.")
            }, $u.getDecoderModule = function() {
                console.warn("THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.")
            };
            var Qu, td, ed = function() {
                function t(t) {
                    Wc.call(this, t), this.dracoLoader = null, this.ddsLoader = null, this.ktx2Loader = null, this.pluginCallbacks = [], this.register((function(t) {
                        return new o(t)
                    })), this.register((function(t) {
                        return new l(t)
                    })), this.register((function(t) {
                        return new a(t)
                    })), this.register((function(t) {
                        return new r(t)
                    }))
                }

                function e() {
                    var t = {};
                    return {
                        get: function(e) {
                            return t[e]
                        },
                        add: function(e, n) {
                            t[e] = n
                        },
                        remove: function(e) {
                            delete t[e]
                        },
                        removeAll: function() {
                            t = {}
                        }
                    }
                }
                t.prototype = Object.assign(Object.create(Wc.prototype), {
                    constructor: t,
                    load: function(t, e, n, i) {
                        var r, s = this;
                        r = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : zh.extractUrlBase(t), this.manager.itemStart(t);
                        var o = function(e) {
                                i ? i(e) : console.error(e), s.manager.itemError(t), s.manager.itemEnd(t)
                            },
                            a = new Xc(this.manager);
                        a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, (function(n) {
                            try {
                                s.parse(n, r, (function(n) {
                                    e(n), s.manager.itemEnd(t)
                                }), o)
                            } catch (i) {
                                o(i)
                            }
                        }), n, o)
                    },
                    setDRACOLoader: function(t) {
                        return this.dracoLoader = t, this
                    },
                    setDDSLoader: function(t) {
                        return this.ddsLoader = t, this
                    },
                    setKTX2Loader: function(t) {
                        return this.ktx2Loader = t, this
                    },
                    register: function(t) {
                        return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this
                    },
                    unregister: function(t) {
                        return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this
                    },
                    parse: function(t, e, r, o) {
                        var a, l = {},
                            h = {};
                        if ("string" === typeof t) a = t;
                        else if (zh.decodeText(new Uint8Array(t, 0, 4)) === c) {
                            try {
                                l[n.KHR_BINARY_GLTF] = new d(t)
                            } catch (w) {
                                return void(o && o(w))
                            }
                            a = l[n.KHR_BINARY_GLTF].content
                        } else a = zh.decodeText(new Uint8Array(t));
                        var u = JSON.parse(a);
                        if (void 0 === u.asset || u.asset.version[0] < 2) o && o(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                        else {
                            var f = new W(u, {
                                path: e || this.resourcePath || "",
                                crossOrigin: this.crossOrigin,
                                manager: this.manager,
                                ktx2Loader: this.ktx2Loader
                            });
                            f.fileLoader.setRequestHeader(this.requestHeader);
                            for (var y = 0; y < this.pluginCallbacks.length; y++) {
                                var x = this.pluginCallbacks[y](f);
                                h[x.name] = x, l[x.name] = !0
                            }
                            if (u.extensionsUsed)
                                for (y = 0; y < u.extensionsUsed.length; ++y) {
                                    var b = u.extensionsUsed[y],
                                        _ = u.extensionsRequired || [];
                                    switch (b) {
                                        case n.KHR_MATERIALS_UNLIT:
                                            l[b] = new s;
                                            break;
                                        case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                            l[b] = new g;
                                            break;
                                        case n.KHR_DRACO_MESH_COMPRESSION:
                                            l[b] = new p(u, this.dracoLoader);
                                            break;
                                        case n.MSFT_TEXTURE_DDS:
                                            l[b] = new i(this.ddsLoader);
                                            break;
                                        case n.KHR_TEXTURE_TRANSFORM:
                                            l[b] = new m;
                                            break;
                                        case n.KHR_MESH_QUANTIZATION:
                                            l[b] = new v;
                                            break;
                                        default:
                                            _.indexOf(b) >= 0 && void 0 === h[b] && console.warn('THREE.GLTFLoader: Unknown extension "' + b + '".')
                                    }
                                }
                            f.setExtensions(l), f.setPlugins(h), f.parse(r, o)
                        }
                    }
                });
                var n = {
                    KHR_BINARY_GLTF: "KHR_binary_glTF",
                    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
                    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                    MSFT_TEXTURE_DDS: "MSFT_texture_dds"
                };

                function i(t) {
                    if (!t) throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader");
                    this.name = n.MSFT_TEXTURE_DDS, this.ddsLoader = t
                }

                function r(t) {
                    this.parser = t, this.name = n.KHR_LIGHTS_PUNCTUAL, this.cache = {
                        refs: {},
                        uses: {}
                    }
                }

                function s() {
                    this.name = n.KHR_MATERIALS_UNLIT
                }

                function o(t) {
                    this.parser = t, this.name = n.KHR_MATERIALS_CLEARCOAT
                }

                function a(t) {
                    this.parser = t, this.name = n.KHR_MATERIALS_TRANSMISSION
                }

                function l(t) {
                    this.parser = t, this.name = n.KHR_TEXTURE_BASISU
                }
                r.prototype._markDefs = function() {
                    for (var t = this.parser, e = this.parser.json.nodes || [], n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && t._addNodeRef(this.cache, r.extensions[this.name].light)
                    }
                }, r.prototype._loadLight = function(t) {
                    var e = this.parser,
                        n = "light:" + t,
                        i = e.cache.get(n);
                    if (i) return i;
                    var r, s = e.json,
                        o = ((s.extensions && s.extensions[this.name] || {}).lights || [])[t],
                        a = new lr(16777215);
                    void 0 !== o.color && a.fromArray(o.color);
                    var l = void 0 !== o.range ? o.range : 0;
                    switch (o.type) {
                        case "directional":
                            (r = new Oh(a)).target.position.set(0, 0, -1), r.add(r.target);
                            break;
                        case "point":
                            (r = new Rh(a)).distance = l;
                            break;
                        case "spot":
                            (r = new Ah(a)).distance = l, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, r.angle = o.spot.outerConeAngle, r.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, r.target.position.set(0, 0, -1), r.add(r.target);
                            break;
                        default:
                            throw new Error('THREE.GLTFLoader: Unexpected light type, "' + o.type + '".')
                    }
                    return r.position.set(0, 0, 0), r.decay = 2, void 0 !== o.intensity && (r.intensity = o.intensity), r.name = e.createUniqueName(o.name || "light_" + t), i = Promise.resolve(r), e.cache.add(n, i), i
                }, r.prototype.createNodeAttachment = function(t) {
                    var e = this,
                        n = this.parser,
                        i = n.json.nodes[t],
                        r = (i.extensions && i.extensions[this.name] || {}).light;
                    return void 0 === r ? null : this._loadLight(r).then((function(t) {
                        return n._getNodeRef(e.cache, r, t)
                    }))
                }, s.prototype.getMaterialType = function() {
                    return dr
                }, s.prototype.extendParams = function(t, e, n) {
                    var i = [];
                    t.color = new lr(1, 1, 1), t.opacity = 1;
                    var r = e.pbrMetallicRoughness;
                    if (r) {
                        if (Array.isArray(r.baseColorFactor)) {
                            var s = r.baseColorFactor;
                            t.color.fromArray(s), t.opacity = s[3]
                        }
                        void 0 !== r.baseColorTexture && i.push(n.assignTexture(t, "map", r.baseColorTexture))
                    }
                    return Promise.all(i)
                }, o.prototype.getMaterialType = function(t) {
                    var e = this.parser.json.materials[t];
                    return e.extensions && e.extensions[this.name] ? bc : null
                }, o.prototype.extendMaterialParams = function(t, e) {
                    var n = this.parser,
                        i = n.json.materials[t];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    var r = [],
                        s = i.extensions[this.name];
                    if (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && r.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(e, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) {
                        var o = s.clearcoatNormalTexture.scale;
                        e.clearcoatNormalScale = new Cn(o, o)
                    }
                    return Promise.all(r)
                }, a.prototype.getMaterialType = function(t) {
                    var e = this.parser.json.materials[t];
                    return e.extensions && e.extensions[this.name] ? bc : null
                }, a.prototype.extendMaterialParams = function(t, e) {
                    var n = this.parser,
                        i = n.json.materials[t];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    var r = [],
                        s = i.extensions[this.name];
                    return void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)), Promise.all(r)
                }, l.prototype.loadTexture = function(t) {
                    var e = this.parser,
                        n = e.json,
                        i = n.textures[t];
                    if (!i.extensions || !i.extensions[this.name]) return null;
                    var r = i.extensions[this.name],
                        s = n.images[r.source],
                        o = e.options.ktx2Loader;
                    if (!o) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return e.loadTextureImage(t, s, o)
                };
                var c = "glTF",
                    h = 12,
                    u = {
                        JSON: 1313821514,
                        BIN: 5130562
                    };

                function d(t) {
                    this.name = n.KHR_BINARY_GLTF, this.content = null, this.body = null;
                    var e = new DataView(t, 0, h);
                    if (this.header = {
                            magic: zh.decodeText(new Uint8Array(t.slice(0, 4))),
                            version: e.getUint32(4, !0),
                            length: e.getUint32(8, !0)
                        }, this.header.magic !== c) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                    if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                    for (var i = new DataView(t, h), r = 0; r < i.byteLength;) {
                        var s = i.getUint32(r, !0);
                        r += 4;
                        var o = i.getUint32(r, !0);
                        if (r += 4, o === u.JSON) {
                            var a = new Uint8Array(t, h + r, s);
                            this.content = zh.decodeText(a)
                        } else if (o === u.BIN) {
                            var l = h + r;
                            this.body = t.slice(l, l + s)
                        }
                        r += s
                    }
                    if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
                }

                function p(t, e) {
                    if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                    this.name = n.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload()
                }

                function m() {
                    this.name = n.KHR_TEXTURE_TRANSFORM
                }

                function f(t) {
                    xc.call(this), this.isGLTFSpecularGlossinessMaterial = !0;
                    var e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                        n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                        i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                        r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                        s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                        o = {
                            specular: {
                                value: (new lr).setHex(16777215)
                            },
                            glossiness: {
                                value: 1
                            },
                            specularMap: {
                                value: null
                            },
                            glossinessMap: {
                                value: null
                            }
                        };
                    this._extraUniforms = o, this.onBeforeCompile = function(t) {
                        for (var a in o) t.uniforms[a] = o[a];
                        t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s)
                    }, Object.defineProperties(this, {
                        specular: {
                            get: function() {
                                return o.specular.value
                            },
                            set: function(t) {
                                o.specular.value = t
                            }
                        },
                        specularMap: {
                            get: function() {
                                return o.specularMap.value
                            },
                            set: function(t) {
                                o.specularMap.value = t, t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                            }
                        },
                        glossiness: {
                            get: function() {
                                return o.glossiness.value
                            },
                            set: function(t) {
                                o.glossiness.value = t
                            }
                        },
                        glossinessMap: {
                            get: function() {
                                return o.glossinessMap.value
                            },
                            set: function(t) {
                                o.glossinessMap.value = t, t ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                            }
                        }
                    }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t)
                }

                function g() {
                    return {
                        name: n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
                        specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"],
                        getMaterialType: function() {
                            return f
                        },
                        extendParams: function(t, e, n) {
                            var i = e.extensions[this.name];
                            t.color = new lr(1, 1, 1), t.opacity = 1;
                            var r = [];
                            if (Array.isArray(i.diffuseFactor)) {
                                var s = i.diffuseFactor;
                                t.color.fromArray(s), t.opacity = s[3]
                            }
                            if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(t, "map", i.diffuseTexture)), t.emissive = new lr(0, 0, 0), t.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, t.specular = new lr(1, 1, 1), Array.isArray(i.specularFactor) && t.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
                                var o = i.specularGlossinessTexture;
                                r.push(n.assignTexture(t, "glossinessMap", o)), r.push(n.assignTexture(t, "specularMap", o))
                            }
                            return Promise.all(r)
                        },
                        createMaterial: function(t) {
                            var e = new f(t);
                            return e.fog = !0, e.color = t.color, e.map = void 0 === t.map ? null : t.map, e.lightMap = null, e.lightMapIntensity = 1, e.aoMap = void 0 === t.aoMap ? null : t.aoMap, e.aoMapIntensity = 1, e.emissive = t.emissive, e.emissiveIntensity = 1, e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap, e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap, e.bumpScale = 1, e.normalMap = void 0 === t.normalMap ? null : t.normalMap, e.normalMapType = _n, t.normalScale && (e.normalScale = t.normalScale), e.displacementMap = null, e.displacementScale = 1, e.displacementBias = 0, e.specularMap = void 0 === t.specularMap ? null : t.specularMap, e.specular = t.specular, e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap, e.glossiness = t.glossiness, e.alphaMap = null, e.envMap = void 0 === t.envMap ? null : t.envMap, e.envMapIntensity = 1, e.refractionRatio = .98, e
                        }
                    }
                }

                function v() {
                    this.name = n.KHR_MESH_QUANTIZATION
                }

                function y(t, e, n, i) {
                    Rc.call(this, t, e, n, i)
                }
                p.prototype.decodePrimitive = function(t, e) {
                    var n = this.json,
                        i = this.dracoLoader,
                        r = t.extensions[this.name].bufferView,
                        s = t.extensions[this.name].attributes,
                        o = {},
                        a = {},
                        l = {};
                    for (var c in s) {
                        var h = P[c] || c.toLowerCase();
                        o[h] = s[c]
                    }
                    for (c in t.attributes) {
                        h = P[c] || c.toLowerCase();
                        if (void 0 !== s[c]) {
                            var u = n.accessors[t.attributes[c]],
                                d = E[u.componentType];
                            l[h] = d, a[h] = !0 === u.normalized
                        }
                    }
                    return e.getDependency("bufferView", r).then((function(t) {
                        return new Promise((function(e) {
                            i.decodeDracoFile(t, (function(t) {
                                for (var n in t.attributes) {
                                    var i = t.attributes[n],
                                        r = a[n];
                                    void 0 !== r && (i.normalized = r)
                                }
                                e(t)
                            }), o, l)
                        }))
                    }))
                }, m.prototype.extendTexture = function(t, e) {
                    return t = t.clone(), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.needsUpdate = !0, t
                }, f.prototype = Object.create(xc.prototype), f.prototype.constructor = f, f.prototype.copy = function(t) {
                    return xc.prototype.copy.call(this, t), this.specularMap = t.specularMap, this.specular.copy(t.specular), this.glossinessMap = t.glossinessMap, this.glossiness = t.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
                }, y.prototype = Object.create(Rc.prototype), y.prototype.constructor = y, y.prototype.copySampleValue_ = function(t) {
                    for (var e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i * 3 + i, s = 0; s !== i; s++) e[s] = n[r + s];
                    return e
                }, y.prototype.beforeStart_ = y.prototype.copySampleValue_, y.prototype.afterEnd_ = y.prototype.copySampleValue_, y.prototype.interpolate_ = function(t, e, n, i) {
                    for (var r = this.resultBuffer, s = this.sampleValues, o = this.valueSize, a = 2 * o, l = 3 * o, c = i - e, h = (n - e) / c, u = h * h, d = u * h, p = t * l, m = p - l, f = -2 * d + 3 * u, g = d - u, v = 1 - f, y = g - u + h, x = 0; x !== o; x++) {
                        var b = s[m + x + o],
                            _ = s[m + x + a] * c,
                            w = s[p + x + o],
                            M = s[p + x] * c;
                        r[x] = v * b + y * _ + f * w + g * M
                    }
                    return r
                };
                var x = 0,
                    b = 1,
                    _ = 2,
                    w = 3,
                    M = 4,
                    S = 5,
                    T = 6,
                    E = {
                        5120: Int8Array,
                        5121: Uint8Array,
                        5122: Int16Array,
                        5123: Uint16Array,
                        5125: Uint32Array,
                        5126: Float32Array
                    },
                    A = {
                        9728: Ft,
                        9729: kt,
                        9984: Ut,
                        9985: Bt,
                        9986: zt,
                        9987: Ht
                    },
                    L = {
                        33071: Nt,
                        33648: Dt,
                        10497: It
                    },
                    R = {
                        SCALAR: 1,
                        VEC2: 2,
                        VEC3: 3,
                        VEC4: 4,
                        MAT2: 4,
                        MAT3: 9,
                        MAT4: 16
                    },
                    P = {
                        POSITION: "position",
                        NORMAL: "normal",
                        TANGENT: "tangent",
                        TEXCOORD_0: "uv",
                        TEXCOORD_1: "uv2",
                        COLOR_0: "color",
                        WEIGHTS_0: "skinWeight",
                        JOINTS_0: "skinIndex"
                    },
                    C = {
                        scale: "scale",
                        translation: "position",
                        rotation: "quaternion",
                        weights: "morphTargetInfluences"
                    },
                    O = {
                        CUBICSPLINE: void 0,
                        LINEAR: 2301,
                        STEP: rn
                    },
                    I = "OPAQUE",
                    N = "MASK",
                    D = "BLEND";

                function F(t, e) {
                    return "string" !== typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) ? t : /^data:.*,.*$/i.test(t) ? t : /^blob:.*$/i.test(t) ? t : e + t)
                }

                function U(t) {
                    return void 0 === t.DefaultMaterial && (t.DefaultMaterial = new xc({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: k
                    })), t.DefaultMaterial
                }

                function z(t, e, n) {
                    for (var i in n.extensions) void 0 === t[i] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = n.extensions[i])
                }

                function B(t, e) {
                    void 0 !== e.extras && ("object" === typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
                }

                function G(t, e) {
                    if (t.updateMorphTargets(), void 0 !== e.weights)
                        for (var n = 0, i = e.weights.length; n < i; n++) t.morphTargetInfluences[n] = e.weights[n];
                    if (e.extras && Array.isArray(e.extras.targetNames)) {
                        var r = e.extras.targetNames;
                        if (t.morphTargetInfluences.length === r.length) {
                            t.morphTargetDictionary = {};
                            for (n = 0, i = r.length; n < i; n++) t.morphTargetDictionary[r[n]] = n
                        } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                    }
                }

                function V(t) {
                    var e = t.extensions && t.extensions[n.KHR_DRACO_MESH_COMPRESSION];
                    return e ? "draco:" + e.bufferView + ":" + e.indices + ":" + j(e.attributes) : t.indices + ":" + j(t.attributes) + ":" + t.mode
                }

                function j(t) {
                    for (var e = "", n = Object.keys(t).sort(), i = 0, r = n.length; i < r; i++) e += n[i] + ":" + t[n[i]] + ";";
                    return e
                }

                function W(t, n) {
                    this.json = t || {}, this.extensions = {}, this.plugins = {}, this.options = n || {}, this.cache = new e, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                        refs: {},
                        uses: {}
                    }, this.cameraCache = {
                        refs: {},
                        uses: {}
                    }, this.lightCache = {
                        refs: {},
                        uses: {}
                    }, this.nodeNamesUsed = {}, "undefined" !== typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new Vh(this.options.manager) : this.textureLoader = new Qc(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new Xc(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
                }

                function q(t, e, n) {
                    var i = e.attributes,
                        r = [];

                    function s(e, i) {
                        return n.getDependency("accessor", e).then((function(e) {
                            t.setAttribute(i, e)
                        }))
                    }
                    for (var o in i) {
                        var a = P[o] || o.toLowerCase();
                        a in t.attributes || r.push(s(i[o], a))
                    }
                    if (void 0 !== e.indices && !t.index) {
                        var l = n.getDependency("accessor", e.indices).then((function(e) {
                            t.setIndex(e)
                        }));
                        r.push(l)
                    }
                    return B(t, e),
                        function(t, e, n) {
                            var i = e.attributes,
                                r = new jn;
                            if (void 0 !== i.POSITION) {
                                var s = (p = n.json.accessors[i.POSITION]).min,
                                    o = p.max;
                                if (void 0 !== s && void 0 !== o) {
                                    r.set(new Hn(s[0], s[1], s[2]), new Hn(o[0], o[1], o[2]));
                                    var a = e.targets;
                                    if (void 0 !== a) {
                                        for (var l = new Hn, c = new Hn, h = 0, u = a.length; h < u; h++) {
                                            var d = a[h];
                                            if (void 0 !== d.POSITION) {
                                                var p;
                                                s = (p = n.json.accessors[d.POSITION]).min, o = p.max;
                                                void 0 !== s && void 0 !== o ? (c.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))), c.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))), c.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))), l.max(c)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                                            }
                                        }
                                        r.expandByVector(l)
                                    }
                                    t.boundingBox = r;
                                    var m = new oi;
                                    r.getCenter(m.center), m.radius = r.min.distanceTo(r.max) / 2, t.boundingSphere = m
                                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                            }
                        }(t, e, n), Promise.all(r).then((function() {
                            return void 0 !== e.targets ? function(t, e, n) {
                                for (var i = !1, r = !1, s = 0, o = e.length; s < o; s++) {
                                    if (void 0 !== (c = e[s]).POSITION && (i = !0), void 0 !== c.NORMAL && (r = !0), i && r) break
                                }
                                if (!i && !r) return Promise.resolve(t);
                                var a = [],
                                    l = [];
                                for (s = 0, o = e.length; s < o; s++) {
                                    var c = e[s];
                                    if (i) {
                                        var h = void 0 !== c.POSITION ? n.getDependency("accessor", c.POSITION) : t.attributes.position;
                                        a.push(h)
                                    }
                                    if (r) {
                                        h = void 0 !== c.NORMAL ? n.getDependency("accessor", c.NORMAL) : t.attributes.normal;
                                        l.push(h)
                                    }
                                }
                                return Promise.all([Promise.all(a), Promise.all(l)]).then((function(e) {
                                    var n = e[0],
                                        s = e[1];
                                    return i && (t.morphAttributes.position = n), r && (t.morphAttributes.normal = s), t.morphTargetsRelative = !0, t
                                }))
                            }(t, e.targets, n) : t
                        }))
                }

                function X(t, e) {
                    var n = t.getIndex();
                    if (null === n) {
                        var i = [],
                            r = t.getAttribute("position");
                        if (void 0 === r) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
                        for (var s = 0; s < r.count; s++) i.push(s);
                        t.setIndex(i), n = t.getIndex()
                    }
                    var o = n.count - 2,
                        a = [];
                    if (e === hn)
                        for (s = 1; s <= o; s++) a.push(n.getX(0)), a.push(n.getX(s)), a.push(n.getX(s + 1));
                    else
                        for (s = 0; s < o; s++) s % 2 === 0 ? (a.push(n.getX(s)), a.push(n.getX(s + 1)), a.push(n.getX(s + 2))) : (a.push(n.getX(s + 2)), a.push(n.getX(s + 1)), a.push(n.getX(s)));
                    a.length / 3 !== o && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                    var l = t.clone();
                    return l.setIndex(a), l
                }
                return W.prototype.setExtensions = function(t) {
                    this.extensions = t
                }, W.prototype.setPlugins = function(t) {
                    this.plugins = t
                }, W.prototype.parse = function(t, e) {
                    var n = this,
                        i = this.json,
                        r = this.extensions;
                    this.cache.removeAll(), this._invokeAll((function(t) {
                        return t._markDefs && t._markDefs()
                    })), Promise.all([this.getDependencies("scene"), this.getDependencies("animation"), this.getDependencies("camera")]).then((function(e) {
                        var s = {
                            scene: e[0][i.scene || 0],
                            scenes: e[0],
                            animations: e[1],
                            cameras: e[2],
                            asset: i.asset,
                            parser: n,
                            userData: {}
                        };
                        z(r, s, i), B(s, i), t(s)
                    })).catch(e)
                }, W.prototype._markDefs = function() {
                    for (var t = this.json.nodes || [], e = this.json.skins || [], n = this.json.meshes || [], i = 0, r = e.length; i < r; i++)
                        for (var s = e[i].joints, o = 0, a = s.length; o < a; o++) t[s[o]].isBone = !0;
                    for (var l = 0, c = t.length; l < c; l++) {
                        var h = t[l];
                        void 0 !== h.mesh && (this._addNodeRef(this.meshCache, h.mesh), void 0 !== h.skin && (n[h.mesh].isSkinnedMesh = !0)), void 0 !== h.camera && this._addNodeRef(this.cameraCache, h.camera)
                    }
                }, W.prototype._addNodeRef = function(t, e) {
                    void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
                }, W.prototype._getNodeRef = function(t, e, n) {
                    if (t.refs[e] <= 1) return n;
                    var i = n.clone();
                    return i.name += "_instance_" + t.uses[e]++, i
                }, W.prototype._invokeOne = function(t) {
                    var e = Object.values(this.plugins);
                    e.push(this);
                    for (var n = 0; n < e.length; n++) {
                        var i = t(e[n]);
                        if (i) return i
                    }
                }, W.prototype._invokeAll = function(t) {
                    var e = Object.values(this.plugins);
                    e.unshift(this);
                    for (var n = [], i = 0; i < e.length; i++) {
                        var r = t(e[i]);
                        r && n.push(r)
                    }
                    return n
                }, W.prototype.getDependency = function(t, e) {
                    var n = t + ":" + e,
                        i = this.cache.get(n);
                    if (!i) {
                        switch (t) {
                            case "scene":
                                i = this.loadScene(e);
                                break;
                            case "node":
                                i = this.loadNode(e);
                                break;
                            case "mesh":
                                i = this._invokeOne((function(t) {
                                    return t.loadMesh && t.loadMesh(e)
                                }));
                                break;
                            case "accessor":
                                i = this.loadAccessor(e);
                                break;
                            case "bufferView":
                                i = this._invokeOne((function(t) {
                                    return t.loadBufferView && t.loadBufferView(e)
                                }));
                                break;
                            case "buffer":
                                i = this.loadBuffer(e);
                                break;
                            case "material":
                                i = this._invokeOne((function(t) {
                                    return t.loadMaterial && t.loadMaterial(e)
                                }));
                                break;
                            case "texture":
                                i = this._invokeOne((function(t) {
                                    return t.loadTexture && t.loadTexture(e)
                                }));
                                break;
                            case "skin":
                                i = this.loadSkin(e);
                                break;
                            case "animation":
                                i = this.loadAnimation(e);
                                break;
                            case "camera":
                                i = this.loadCamera(e);
                                break;
                            default:
                                throw new Error("Unknown type: " + t)
                        }
                        this.cache.add(n, i)
                    }
                    return i
                }, W.prototype.getDependencies = function(t) {
                    var e = this.cache.get(t);
                    if (!e) {
                        var n = this,
                            i = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                        e = Promise.all(i.map((function(e, i) {
                            return n.getDependency(t, i)
                        }))), this.cache.add(t, e)
                    }
                    return e
                }, W.prototype.loadBuffer = function(t) {
                    var e = this.json.buffers[t],
                        i = this.fileLoader;
                    if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                    if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body);
                    var r = this.options;
                    return new Promise((function(t, n) {
                        i.load(F(e.uri, r.path), t, void 0, (function() {
                            n(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
                        }))
                    }))
                }, W.prototype.loadBufferView = function(t) {
                    var e = this.json.bufferViews[t];
                    return this.getDependency("buffer", e.buffer).then((function(t) {
                        var n = e.byteLength || 0,
                            i = e.byteOffset || 0;
                        return t.slice(i, i + n)
                    }))
                }, W.prototype.loadAccessor = function(t) {
                    var e = this,
                        n = this.json,
                        i = this.json.accessors[t];
                    if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
                    var r = [];
                    return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function(t) {
                        var r, s = t[0],
                            o = R[i.type],
                            a = E[i.componentType],
                            l = a.BYTES_PER_ELEMENT,
                            c = l * o,
                            h = i.byteOffset || 0,
                            u = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                            d = !0 === i.normalized;
                        if (u && u !== c) {
                            var p = Math.floor(h / u),
                                m = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + p + ":" + i.count,
                                f = e.cache.get(m);
                            f || (f = new Ca(new a(s, p * u, i.count * u / l), u / l), e.cache.add(m, f)), r = new Ia(f, o, h % u / l, d)
                        } else r = new fr(null === s ? new a(i.count * o) : new a(s, h, i.count * o), o, d);
                        if (void 0 !== i.sparse) {
                            var g = R.SCALAR,
                                v = E[i.sparse.indices.componentType],
                                y = i.sparse.indices.byteOffset || 0,
                                x = i.sparse.values.byteOffset || 0,
                                b = new v(t[1], y, i.sparse.count * g),
                                _ = new a(t[2], x, i.sparse.count * o);
                            null !== s && (r = new fr(r.array.slice(), r.itemSize, r.normalized));
                            for (var w = 0, M = b.length; w < M; w++) {
                                var S = b[w];
                                if (r.setX(S, _[w * o]), o >= 2 && r.setY(S, _[w * o + 1]), o >= 3 && r.setZ(S, _[w * o + 2]), o >= 4 && r.setW(S, _[w * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                            }
                        }
                        return r
                    }))
                }, W.prototype.loadTexture = function(t) {
                    var e, i, r = this.json,
                        s = this.options,
                        o = r.textures[t],
                        a = o.extensions || {};
                    return (e = a[n.MSFT_TEXTURE_DDS] ? r.images[a[n.MSFT_TEXTURE_DDS].source] : r.images[o.source]).uri && (i = s.manager.getHandler(e.uri)), i || (i = a[n.MSFT_TEXTURE_DDS] ? this.extensions[n.MSFT_TEXTURE_DDS].ddsLoader : this.textureLoader), this.loadTextureImage(t, e, i)
                }, W.prototype.loadTextureImage = function(t, e, n) {
                    var i = this,
                        r = this.json,
                        s = this.options,
                        o = r.textures[t],
                        a = self.URL || self.webkitURL,
                        l = e.uri,
                        c = !1,
                        h = !0;
                    return "image/jpeg" === e.mimeType && (h = !1), void 0 !== e.bufferView && (l = i.getDependency("bufferView", e.bufferView).then((function(t) {
                        if ("image/png" === e.mimeType) {
                            var n = new DataView(t, 25, 1).getUint8(0, !1);
                            h = 6 === n || 4 === n || 3 === n
                        }
                        c = !0;
                        var i = new Blob([t], {
                            type: e.mimeType
                        });
                        return l = a.createObjectURL(i)
                    }))), Promise.resolve(l).then((function(t) {
                        return new Promise((function(e, i) {
                            var r = e;
                            !0 === n.isImageBitmapLoader && (r = function(t) {
                                e(new Rl(t))
                            }), n.load(F(t, s.path), r, void 0, i)
                        }))
                    })).then((function(e) {
                        !0 === c && a.revokeObjectURL(l), e.flipY = !1, o.name && (e.name = o.name), h || (e.format = ee);
                        var n = (r.samplers || {})[o.sampler] || {};
                        return e.magFilter = A[n.magFilter] || kt, e.minFilter = A[n.minFilter] || Ht, e.wrapS = L[n.wrapS] || It, e.wrapT = L[n.wrapT] || It, i.associations.set(e, {
                            type: "textures",
                            index: t
                        }), e
                    }))
                }, W.prototype.assignTexture = function(t, e, i) {
                    var r = this;
                    return this.getDependency("texture", i.index).then((function(s) {
                        if (void 0 === i.texCoord || 0 == i.texCoord || "aoMap" === e && 1 == i.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + e + " not yet supported."), r.extensions[n.KHR_TEXTURE_TRANSFORM]) {
                            var o = void 0 !== i.extensions ? i.extensions[n.KHR_TEXTURE_TRANSFORM] : void 0;
                            if (o) {
                                var a = r.associations.get(s);
                                s = r.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(s, o), r.associations.set(s, a)
                            }
                        }
                        t[e] = s
                    }))
                }, W.prototype.assignFinalMaterial = function(t) {
                    var e = t.geometry,
                        n = t.material,
                        i = void 0 !== e.attributes.tangent,
                        r = void 0 !== e.attributes.color,
                        s = void 0 === e.attributes.normal,
                        o = !0 === t.isSkinnedMesh,
                        a = Object.keys(e.morphAttributes).length > 0,
                        l = a && void 0 !== e.morphAttributes.normal;
                    if (t.isPoints) {
                        var c = "PointsMaterial:" + n.uuid,
                            h = this.cache.get(c);
                        h || (h = new bl, ur.prototype.copy.call(h, n), h.color.copy(n.color), h.map = n.map, h.sizeAttenuation = !1, this.cache.add(c, h)), n = h
                    } else if (t.isLine) {
                        c = "LineBasicMaterial:" + n.uuid;
                        var u = this.cache.get(c);
                        u || (u = new cl, ur.prototype.copy.call(u, n), u.color.copy(n.color), this.cache.add(c, u)), n = u
                    }
                    if (i || r || s || o || a) {
                        c = "ClonedMaterial:" + n.uuid + ":";
                        n.isGLTFSpecularGlossinessMaterial && (c += "specular-glossiness:"), o && (c += "skinning:"), i && (c += "vertex-tangents:"), r && (c += "vertex-colors:"), s && (c += "flat-shading:"), a && (c += "morph-targets:"), l && (c += "morph-normals:");
                        var d = this.cache.get(c);
                        d || (d = n.clone(), o && (d.skinning = !0), i && (d.vertexTangents = !0), r && (d.vertexColors = !0), s && (d.flatShading = !0), a && (d.morphTargets = !0), l && (d.morphNormals = !0), this.cache.add(c, d), this.associations.set(d, this.associations.get(n))), n = d
                    }
                    n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), n.normalScale && !i && (n.normalScale.y = -n.normalScale.y), n.clearcoatNormalScale && !i && (n.clearcoatNormalScale.y = -n.clearcoatNormalScale.y), t.material = n
                }, W.prototype.getMaterialType = function() {
                    return xc
                }, W.prototype.loadMaterial = function(t) {
                    var e, i = this,
                        r = this.json,
                        s = this.extensions,
                        o = r.materials[t],
                        a = {},
                        l = o.extensions || {},
                        c = [];
                    if (l[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                        var h = s[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                        e = h.getMaterialType(), c.push(h.extendParams(a, o, i))
                    } else if (l[n.KHR_MATERIALS_UNLIT]) {
                        var u = s[n.KHR_MATERIALS_UNLIT];
                        e = u.getMaterialType(), c.push(u.extendParams(a, o, i))
                    } else {
                        var d = o.pbrMetallicRoughness || {};
                        if (a.color = new lr(1, 1, 1), a.opacity = 1, Array.isArray(d.baseColorFactor)) {
                            var p = d.baseColorFactor;
                            a.color.fromArray(p), a.opacity = p[3]
                        }
                        void 0 !== d.baseColorTexture && c.push(i.assignTexture(a, "map", d.baseColorTexture)), a.metalness = void 0 !== d.metallicFactor ? d.metallicFactor : 1, a.roughness = void 0 !== d.roughnessFactor ? d.roughnessFactor : 1, void 0 !== d.metallicRoughnessTexture && (c.push(i.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)), c.push(i.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture))), e = this._invokeOne((function(e) {
                            return e.getMaterialType && e.getMaterialType(t)
                        })), c.push(Promise.all(this._invokeAll((function(e) {
                            return e.extendMaterialParams && e.extendMaterialParams(t, a)
                        }))))
                    }!0 === o.doubleSided && (a.side = H);
                    var m = o.alphaMode || I;
                    return m === D ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, m === N && (a.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : .5)), void 0 !== o.normalTexture && e !== dr && (c.push(i.assignTexture(a, "normalMap", o.normalTexture)), a.normalScale = new Cn(1, 1), void 0 !== o.normalTexture.scale && a.normalScale.set(o.normalTexture.scale, o.normalTexture.scale)), void 0 !== o.occlusionTexture && e !== dr && (c.push(i.assignTexture(a, "aoMap", o.occlusionTexture)), void 0 !== o.occlusionTexture.strength && (a.aoMapIntensity = o.occlusionTexture.strength)), void 0 !== o.emissiveFactor && e !== dr && (a.emissive = (new lr).fromArray(o.emissiveFactor)), void 0 !== o.emissiveTexture && e !== dr && c.push(i.assignTexture(a, "emissiveMap", o.emissiveTexture)), Promise.all(c).then((function() {
                        var r;
                        return r = e === f ? s[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new e(a), o.name && (r.name = o.name), r.map && (r.map.encoding = dn), r.emissiveMap && (r.emissiveMap.encoding = dn), B(r, o), i.associations.set(r, {
                            type: "materials",
                            index: t
                        }), o.extensions && z(s, r, o), r
                    }))
                }, W.prototype.createUniqueName = function(t) {
                    for (var e = uu.sanitizeNodeName(t || ""), n = 1; this.nodeNamesUsed[e]; ++n) e = t + "_" + n;
                    return this.nodeNamesUsed[e] = !0, e
                }, W.prototype.loadGeometries = function(t) {
                    var e = this,
                        i = this.extensions,
                        r = this.primitiveCache;

                    function s(t) {
                        return i[n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function(n) {
                            return q(n, t, e)
                        }))
                    }
                    for (var o = [], a = 0, l = t.length; a < l; a++) {
                        var c, h = t[a],
                            u = V(h),
                            d = r[u];
                        if (d) o.push(d.promise);
                        else c = h.extensions && h.extensions[n.KHR_DRACO_MESH_COMPRESSION] ? s(h) : q(new Nr, h, e), r[u] = {
                            primitive: h,
                            promise: c
                        }, o.push(c)
                    }
                    return Promise.all(o)
                }, W.prototype.loadMesh = function(t) {
                    for (var e = this, n = this.json.meshes[t], i = n.primitives, r = [], s = 0, o = i.length; s < o; s++) {
                        var a = void 0 === i[s].material ? U(this.cache) : this.getDependency("material", i[s].material);
                        r.push(a)
                    }
                    return r.push(e.loadGeometries(i)), Promise.all(r).then((function(r) {
                        for (var s = r.slice(0, r.length - 1), o = r[r.length - 1], a = [], l = 0, c = o.length; l < c; l++) {
                            var h, u = o[l],
                                d = i[l],
                                p = s[l];
                            if (d.mode === M || d.mode === S || d.mode === T || void 0 === d.mode) !0 !== (h = !0 === n.isSkinnedMesh ? new Qa(u, p) : new $r(u, p)).isSkinnedMesh || h.geometry.attributes.skinWeight.normalized || h.normalizeSkinWeights(), d.mode === S ? h.geometry = X(h.geometry, 1) : d.mode === T && (h.geometry = X(h.geometry, hn));
                            else if (d.mode === b) h = new yl(u, p);
                            else if (d.mode === w) h = new fl(u, p);
                            else if (d.mode === _) h = new xl(u, p);
                            else {
                                if (d.mode !== x) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + d.mode);
                                h = new Tl(u, p)
                            }
                            Object.keys(h.geometry.morphAttributes).length > 0 && G(h, n), h.name = e.createUniqueName(n.name || "mesh_" + t), o.length > 1 && (h.name += "_" + l), B(h, n), e.assignFinalMaterial(h), a.push(h)
                        }
                        if (1 === a.length) return a[0];
                        var m = new Sa;
                        for (l = 0, c = a.length; l < c; l++) m.add(a[l]);
                        return m
                    }))
                }, W.prototype.loadCamera = function(t) {
                    var e, n = this.json.cameras[t],
                        i = n[n.type];
                    if (i) return "perspective" === n.type ? e = new cs(Pn.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (e = new Ph(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (e.name = this.createUniqueName(n.name)), B(e, n), Promise.resolve(e);
                    console.warn("THREE.GLTFLoader: Missing camera parameters.")
                }, W.prototype.loadSkin = function(t) {
                    var e = this.json.skins[t],
                        n = {
                            joints: e.joints
                        };
                    return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then((function(t) {
                        return n.inverseBindMatrices = t, n
                    }))
                }, W.prototype.loadAnimation = function(t) {
                    for (var e = this.json.animations[t], n = [], i = [], r = [], s = [], o = [], a = 0, l = e.channels.length; a < l; a++) {
                        var c = e.channels[a],
                            h = e.samplers[c.sampler],
                            u = c.target,
                            d = void 0 !== u.node ? u.node : u.id,
                            p = void 0 !== e.parameters ? e.parameters[h.input] : h.input,
                            m = void 0 !== e.parameters ? e.parameters[h.output] : h.output;
                        n.push(this.getDependency("node", d)), i.push(this.getDependency("accessor", p)), r.push(this.getDependency("accessor", m)), s.push(h), o.push(u)
                    }
                    return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(o)]).then((function(n) {
                        for (var i = n[0], r = n[1], s = n[2], o = n[3], a = n[4], l = [], c = 0, h = i.length; c < h; c++) {
                            var u = i[c],
                                d = r[c],
                                p = s[c],
                                m = o[c],
                                f = a[c];
                            if (void 0 !== u) {
                                var g;
                                switch (u.updateMatrix(), u.matrixAutoUpdate = !0, C[f.path]) {
                                    case C.weights:
                                        g = Fc;
                                        break;
                                    case C.rotation:
                                        g = zc;
                                        break;
                                    case C.position:
                                    case C.scale:
                                    default:
                                        g = Bc
                                }
                                var v = u.name ? u.name : u.uuid,
                                    x = void 0 !== m.interpolation ? O[m.interpolation] : 2301,
                                    b = [];
                                C[f.path] === C.weights ? u.traverse((function(t) {
                                    !0 === t.isMesh && t.morphTargetInfluences && b.push(t.name ? t.name : t.uuid)
                                })) : b.push(v);
                                var _ = p.array;
                                if (p.normalized) {
                                    var w;
                                    if (_.constructor === Int8Array) w = 1 / 127;
                                    else if (_.constructor === Uint8Array) w = 1 / 255;
                                    else if (_.constructor == Int16Array) w = 1 / 32767;
                                    else {
                                        if (_.constructor !== Uint16Array) throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
                                        w = 1 / 65535
                                    }
                                    for (var M = new Float32Array(_.length), S = 0, T = _.length; S < T; S++) M[S] = _[S] * w;
                                    _ = M
                                }
                                for (S = 0, T = b.length; S < T; S++) {
                                    var E = new g(b[S] + "." + C[f.path], d.array, _, x);
                                    "CUBICSPLINE" === m.interpolation && (E.createInterpolant = function(t) {
                                        return new y(this.times, this.values, this.getValueSize() / 3, t)
                                    }, E.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(E)
                                }
                            }
                        }
                        return new Hc(e.name ? e.name : "animation_" + t, void 0, l)
                    }))
                }, W.prototype.loadNode = function(t) {
                    var e = this.json,
                        n = this.extensions,
                        i = this,
                        r = e.nodes[t],
                        s = r.name ? i.createUniqueName(r.name) : "";
                    return function() {
                        var e = [];
                        return void 0 !== r.mesh && e.push(i.getDependency("mesh", r.mesh).then((function(t) {
                            var e = i._getNodeRef(i.meshCache, r.mesh, t);
                            return void 0 !== r.weights && e.traverse((function(t) {
                                if (t.isMesh)
                                    for (var e = 0, n = r.weights.length; e < n; e++) t.morphTargetInfluences[e] = r.weights[e]
                            })), e
                        }))), void 0 !== r.camera && e.push(i.getDependency("camera", r.camera).then((function(t) {
                            return i._getNodeRef(i.cameraCache, r.camera, t)
                        }))), i._invokeAll((function(e) {
                            return e.createNodeAttachment && e.createNodeAttachment(t)
                        })).forEach((function(t) {
                            e.push(t)
                        })), Promise.all(e)
                    }().then((function(e) {
                        var o;
                        if ((o = !0 === r.isBone ? new il : e.length > 1 ? new Sa : 1 === e.length ? e[0] : new Bi) !== e[0])
                            for (var a = 0, l = e.length; a < l; a++) o.add(e[a]);
                        if (r.name && (o.userData.name = r.name, o.name = s), B(o, r), r.extensions && z(n, o, r), void 0 !== r.matrix) {
                            var c = new fi;
                            c.fromArray(r.matrix), o.applyMatrix4(c)
                        } else void 0 !== r.translation && o.position.fromArray(r.translation), void 0 !== r.rotation && o.quaternion.fromArray(r.rotation), void 0 !== r.scale && o.scale.fromArray(r.scale);
                        return i.associations.set(o, {
                            type: "nodes",
                            index: t
                        }), o
                    }))
                }, W.prototype.loadScene = function() {
                    function t(e, n, i, r) {
                        var s = i.nodes[e];
                        return r.getDependency("node", e).then((function(t) {
                            return void 0 === s.skin ? t : r.getDependency("skin", s.skin).then((function(t) {
                                for (var n = [], i = 0, s = (e = t).joints.length; i < s; i++) n.push(r.getDependency("node", e.joints[i]));
                                return Promise.all(n)
                            })).then((function(n) {
                                return t.traverse((function(t) {
                                    if (t.isMesh) {
                                        for (var i = [], r = [], s = 0, o = n.length; s < o; s++) {
                                            var a = n[s];
                                            if (a) {
                                                i.push(a);
                                                var l = new fi;
                                                void 0 !== e.inverseBindMatrices && l.fromArray(e.inverseBindMatrices.array, 16 * s), r.push(l)
                                            } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[s])
                                        }
                                        t.bind(new nl(i, r), t.matrixWorld)
                                    }
                                })), t
                            }));
                            var e
                        })).then((function(e) {
                            n.add(e);
                            var o = [];
                            if (s.children)
                                for (var a = s.children, l = 0, c = a.length; l < c; l++) {
                                    var h = a[l];
                                    o.push(t(h, e, i, r))
                                }
                            return Promise.all(o)
                        }))
                    }
                    return function(e) {
                        var n = this.json,
                            i = this.extensions,
                            r = this.json.scenes[e],
                            s = new Sa;
                        r.name && (s.name = this.createUniqueName(r.name)), B(s, r), r.extensions && z(i, s, r);
                        for (var o = r.nodes || [], a = [], l = 0, c = o.length; l < c; l++) a.push(t(o[l], s, n, this));
                        return Promise.all(a).then((function() {
                            return s
                        }))
                    }
                }(), t
            }();
            const nd = Symbol("retainerCount"),
                id = Symbol("recentlyUsed"),
                rd = Symbol("evict"),
                sd = Symbol("evictionThreshold"),
                od = Symbol("cache");
            var ad, ld;
            const cd = (t, e, n = (() => {})) => {
                    const i = t => {
                        const e = t.loaded / t.total;
                        n(Math.max(0, Math.min(1, isFinite(e) ? e : 1)))
                    };
                    return new Promise((n, r) => {
                        e.load(t, n, i, r)
                    })
                },
                hd = new Map,
                ud = new Map;
            let dd;
            const pd = new $u,
                md = Symbol("loader"),
                fd = Symbol("evictionPolicy"),
                gd = Symbol("GLTFInstance");
            class vd extends An {
                constructor(t) {
                    super(), this[ld] = new ed, this[gd] = t, this[md].setDRACOLoader(pd)
                }
                static setDRACODecoderLocation(t) {
                    dd = t, pd.setDecoderPath(t)
                }
                static getDRACODecoderLocation() {
                    return dd
                }
                static get cache() {
                    return hd
                }
                static clearCache() {
                    hd.forEach((t, e) => {
                        this.delete(e)
                    }), this[fd].reset()
                }
                static has(t) {
                    return hd.has(t)
                }
                static async delete(t) {
                    if (!this.has(t)) return;
                    const e = hd.get(t);
                    ud.delete(t), hd.delete(t), (await e).dispose()
                }
                static hasFinishedLoading(t) {
                    return !!ud.get(t)
                }
                get[(ad = fd, ld = md, fd)]() {
                    return this.constructor[fd]
                }
                async preload(t, e, n = (() => {})) {
                    if (this.dispatchEvent({
                            type: "preload",
                            element: e,
                            src: t
                        }), !hd.has(t)) {
                        const e = cd(t, this[md], t => {
                                n(.8 * t)
                            }),
                            i = this[gd],
                            r = e.then(t => i.prepare(t)).then(t => (n(.9), new i(t)));
                        hd.set(t, r)
                    }
                    await hd.get(t), ud.set(t, !0), n && n(1)
                }
                async load(t, e, n = (() => {})) {
                    await this.preload(t, e, n);
                    const i = await hd.get(t),
                        r = await i.clone();
                    return this[fd].retain(t), r.dispose = (() => {
                        const e = r.dispose;
                        let n = !1;
                        return () => {
                            n || (n = !0, e.apply(r), this[fd].release(t))
                        }
                    })(), r
                }
            }
            var yd;
            vd[ad] = new class {
                constructor(t, e = 5) {
                    this[Qu] = new Map, this[td] = [], this[od] = t, this[sd] = e
                }
                set evictionThreshold(t) {
                    this[sd] = t, this[rd]()
                }
                get evictionThreshold() {
                    return this[sd]
                }
                get cache() {
                    return this[od]
                }
                retainerCount(t) {
                    return this[nd].get(t) || 0
                }
                reset() {
                    this[nd].clear(), this[id] = []
                }
                retain(t) {
                    this[nd].has(t) || this[nd].set(t, 0), this[nd].set(t, this[nd].get(t) + 1);
                    const e = this[id].indexOf(t); - 1 !== e && this[id].splice(e, 1), this[id].unshift(t), this[rd]()
                }
                release(t) {
                    this[nd].has(t) && this[nd].set(t, Math.max(this[nd].get(t) - 1, 0)), this[rd]()
                }[(Qu = nd, td = id, rd)]() {
                    if (!(this[id].length < this[sd]))
                        for (let t = this[id].length - 1; t >= this[sd]; --t) {
                            const e = this[id][t];
                            0 === this[nd].get(e) && (this[od].delete(e), this[id].splice(t, 1))
                        }
                }
            }(vd);
            const xd = 1e4,
                bd = .02,
                _d = 2e-4 * bd,
                wd = Symbol("velocity");
            class Md {
                constructor() {
                    this[yd] = 0
                }
                update(t, e, n, i) {
                    if (null == t || 0 === i) return e;
                    if (t === e && 0 === this[wd]) return e;
                    if (n < 0) return t;
                    const r = t - e,
                        s = this[wd] + bd * r,
                        o = r + n * s,
                        a = Math.exp(-bd * n),
                        l = (s - bd * o) * a,
                        c = -bd * (l + s * a);
                    return Math.abs(l) < _d * Math.abs(i) && c * r >= 0 ? (this[wd] = 0, e) : (this[wd] = l, e + o * a)
                }
            }
            yd = wd;
            var Sd = function(t) {
                Bi.call(this), this.element = t || document.createElement("div"), this.element.style.position = "absolute", this.addEventListener("removed", (function() {
                    this.traverse((function(t) {
                        t.element instanceof Element && null !== t.element.parentNode && t.element.parentNode.removeChild(t.element)
                    }))
                }))
            };
            Sd.prototype = Object.assign(Object.create(Bi.prototype), {
                constructor: Sd,
                copy: function(t, e) {
                    return Bi.prototype.copy.call(this, t, e), this.element = t.element.cloneNode(!0), this
                }
            });
            var Td = function() {
                var t, e, n, i, r = this,
                    s = new Hn,
                    o = new fi,
                    a = new fi,
                    l = {
                        objects: new WeakMap
                    },
                    c = document.createElement("div");
                c.style.overflow = "hidden", this.domElement = c, this.getSize = function() {
                    return {
                        width: t,
                        height: e
                    }
                }, this.setSize = function(r, s) {
                    n = (t = r) / 2, i = (e = s) / 2, c.style.width = r + "px", c.style.height = s + "px"
                };
                var h = function(t, e, o) {
                        if (t instanceof Sd) {
                            t.onBeforeRender(r, e, o), s.setFromMatrixPosition(t.matrixWorld), s.applyMatrix4(a);
                            var d = t.element,
                                p = "translate(-50%,-50%) translate(" + (s.x * n + n) + "px," + (-s.y * i + i) + "px)";
                            d.style.WebkitTransform = p, d.style.MozTransform = p, d.style.oTransform = p, d.style.transform = p, d.style.display = t.visible && s.z >= -1 && s.z <= 1 ? "" : "none";
                            var m = {
                                distanceToCameraSquared: u(o, t)
                            };
                            l.objects.set(t, m), d.parentNode !== c && c.appendChild(d), t.onAfterRender(r, e, o)
                        }
                        for (var f = 0, g = t.children.length; f < g; f++) h(t.children[f], e, o)
                    },
                    u = function() {
                        var t = new Hn,
                            e = new Hn;
                        return function(n, i) {
                            return t.setFromMatrixPosition(n.matrixWorld), e.setFromMatrixPosition(i.matrixWorld), t.distanceToSquared(e)
                        }
                    }(),
                    d = function(t) {
                        for (var e = function(t) {
                                var e = [];
                                return t.traverse((function(t) {
                                    t instanceof Sd && e.push(t)
                                })), e
                            }(t).sort((function(t, e) {
                                return l.objects.get(t).distanceToCameraSquared - l.objects.get(e).distanceToCameraSquared
                            })), n = e.length, i = 0, r = e.length; i < r; i++) e[i].element.style.zIndex = n - i
                    };
                this.render = function(t, e) {
                    !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), o.copy(e.matrixWorldInverse), a.multiplyMatrices(e.projectionMatrix, o), h(t, t, e), d(t)
                }
            };
            const Ed = (t, e) => ({
                    type: "number",
                    number: t,
                    unit: e
                }),
                Ad = (() => {
                    const t = {};
                    return e => {
                        const n = e;
                        if (n in t) return t[n];
                        const i = [];
                        let r = 0;
                        for (; e;) {
                            if (++r > 1e3) {
                                e = "";
                                break
                            }
                            const t = Ld(e),
                                n = t.nodes[0];
                            if (null == n || 0 === n.terms.length) break;
                            i.push(n), e = t.remainingInput
                        }
                        return t[n] = i
                    }
                })(),
                Ld = (() => {
                    const t = /^(\-\-|[a-z\u0240-\uffff])/i,
                        e = /^([\*\+\/]|[\-]\s)/i,
                        n = /^[\),]/;
                    return i => {
                        const r = [];
                        for (; i.length && (i = i.trim(), !n.test(i));)
                            if ("(" === i[0]) {
                                const {
                                    nodes: t,
                                    remainingInput: e
                                } = Od(i);
                                i = e, r.push({
                                    type: "function",
                                    name: {
                                        type: "ident",
                                        value: "calc"
                                    },
                                    arguments: t
                                })
                            } else if (t.test(i)) {
                            const t = Rd(i),
                                e = t.nodes[0];
                            if ("(" === (i = t.remainingInput)[0]) {
                                const {
                                    nodes: t,
                                    remainingInput: n
                                } = Od(i);
                                r.push({
                                    type: "function",
                                    name: e,
                                    arguments: t
                                }), i = n
                            } else r.push(e)
                        } else if (e.test(i)) r.push({
                            type: "operator",
                            value: i[0]
                        }), i = i.slice(1);
                        else {
                            const {
                                nodes: t,
                                remainingInput: e
                            } = "#" === i[0] ? Cd(i) : Pd(i);
                            if (0 === t.length) break;
                            r.push(t[0]), i = e
                        }
                        return {
                            nodes: [{
                                type: "expression",
                                terms: r
                            }],
                            remainingInput: i
                        }
                    }
                })(),
                Rd = (() => {
                    const t = /[^a-z^0-9^_^\-^\u0240-\uffff]/i;
                    return e => {
                        const n = e.match(t);
                        return {
                            nodes: [{
                                type: "ident",
                                value: null == n ? e : e.substr(0, n.index)
                            }],
                            remainingInput: null == n ? "" : e.substr(n.index)
                        }
                    }
                })(),
                Pd = (() => {
                    const t = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/,
                        e = /^[a-z%]+/i,
                        n = /^(m|mm|cm|rad|deg|[%])$/;
                    return i => {
                        const r = i.match(t),
                            s = null == r ? "0" : r[0],
                            o = (i = null == s ? i : i.slice(s.length)).match(e);
                        let a = null != o && "" !== o[0] ? o[0] : null;
                        const l = null == o ? i : i.slice(a.length);
                        return null == a || n.test(a) || (a = null), {
                            nodes: [{
                                type: "number",
                                number: parseFloat(s) || 0,
                                unit: a
                            }],
                            remainingInput: l
                        }
                    }
                })(),
                Cd = (() => {
                    const t = /^[a-f0-9]*/i;
                    return e => {
                        const n = (e = e.slice(1).trim()).match(t);
                        return {
                            nodes: null == n ? [] : [{
                                type: "hex",
                                value: n[0]
                            }],
                            remainingInput: null == n ? e : e.slice(n[0].length)
                        }
                    }
                })(),
                Od = t => {
                    const e = [];
                    for (t = t.slice(1).trim(); t.length;) {
                        const n = Ld(t);
                        if (e.push(n.nodes[0]), "," === (t = n.remainingInput.trim())[0]) t = t.slice(1).trim();
                        else if (")" === t[0]) {
                            t = t.slice(1);
                            break
                        }
                    }
                    return {
                        nodes: e,
                        remainingInput: t
                    }
                },
                Id = Symbol("visitedTypes");
            class Nd {
                constructor(t) {
                    this[Id] = t
                }
                walk(t, e) {
                    const n = t.slice();
                    for (; n.length;) {
                        const t = n.shift();
                        switch (this[Id].indexOf(t.type) > -1 && e(t), t.type) {
                            case "expression":
                                n.unshift(...t.terms);
                                break;
                            case "function":
                                n.unshift(t.name, ...t.arguments)
                        }
                    }
                }
            }
            const Dd = Object.freeze({
                    type: "number",
                    number: 0,
                    unit: null
                }),
                Fd = (t, e = 0) => {
                    let {
                        number: n,
                        unit: i
                    } = t;
                    if (isFinite(n)) {
                        if ("rad" === t.unit || null == t.unit) return t
                    } else n = e, i = "rad";
                    return {
                        type: "number",
                        number: ("deg" === i && null != n ? n : 0) * Math.PI / 180,
                        unit: "rad"
                    }
                },
                Ud = (t, e = 0) => {
                    let n, {
                        number: i,
                        unit: r
                    } = t;
                    if (isFinite(i)) {
                        if ("m" === t.unit) return t
                    } else i = e, r = "m";
                    switch (r) {
                        default: n = 1;
                        break;
                        case "cm":
                                n = .01;
                            break;
                        case "mm":
                                n = .001
                    }
                    return {
                        type: "number",
                        number: n * i,
                        unit: "m"
                    }
                },
                zd = (() => {
                    const t = t => t,
                        e = {
                            rad: t,
                            deg: Fd,
                            m: t,
                            mm: Ud,
                            cm: Ud
                        };
                    return (t, n = Dd) => {
                        let {
                            number: i,
                            unit: r
                        } = t;
                        if (isFinite(i) || (i = n.number, r = n.unit), null == r) return t;
                        const s = e[r];
                        return null == s ? n : s(t)
                    }
                })();
            class kd extends Sd {
                constructor(t) {
                    super(document.createElement("div")), this.normal = new Hn(0, 1, 0), this.initialized = !1, this.referenceCount = 1, this.pivot = document.createElement("div"), this.slot = document.createElement("slot"), this.element.classList.add("annotation-wrapper"), this.slot.name = t.name, this.element.appendChild(this.pivot), this.pivot.appendChild(this.slot), this.updatePosition(t.position), this.updateNormal(t.normal)
                }
                get facingCamera() {
                    return !this.element.classList.contains("hide")
                }
                show() {
                    this.facingCamera && this.initialized || this.updateVisibility(!0)
                }
                hide() {
                    !this.facingCamera && this.initialized || this.updateVisibility(!1)
                }
                increment() {
                    this.referenceCount++
                }
                decrement() {
                    return this.referenceCount > 0 && --this.referenceCount, 0 === this.referenceCount
                }
                updatePosition(t) {
                    if (null == t) return;
                    const e = Ad(t)[0].terms;
                    for (let n = 0; n < 3; ++n) this.position.setComponent(n, zd(e[n]).number)
                }
                updateNormal(t) {
                    if (null == t) return;
                    const e = Ad(t)[0].terms;
                    for (let n = 0; n < 3; ++n) this.normal.setComponent(n, zd(e[n]).number)
                }
                orient(t) {
                    this.pivot.style.transform = `rotate(${t}rad)`
                }
                updateVisibility(t) {
                    t ? this.element.classList.remove("hide") : this.element.classList.add("hide"), this.slot.assignedNodes().forEach(e => {
                        if (e.nodeType !== Node.ELEMENT_NODE) return;
                        const n = e,
                            i = n.dataset.visibilityAttribute;
                        if (null != i) {
                            const e = `data-${i}`;
                            t ? n.setAttribute(e, "") : n.removeAttribute(e)
                        }
                        n.dispatchEvent(new CustomEvent("hotspot-visibility", {
                            detail: {
                                visible: t
                            }
                        }))
                    }), this.initialized = !0
                }
            }
            const Bd = (t, e) => {
                    let n = 0;
                    const i = new Hn;
                    return t.traverse(t => {
                        let r, s;
                        t.updateWorldMatrix(!1, !1);
                        let o = t.geometry;
                        if (void 0 !== o)
                            if (o.isGeometry) {
                                let a = o.vertices;
                                for (r = 0, s = a.length; r < s; r++) i.copy(a[r]), i.applyMatrix4(t.matrixWorld), n = e(n, i)
                            } else if (o.isBufferGeometry) {
                            let a = o.attributes.position;
                            if (void 0 !== a)
                                for (r = 0, s = a.count; r < s; r++) i.fromBufferAttribute(a, r).applyMatrix4(t.matrixWorld), n = e(n, i)
                        }
                    }), n
                },
                Hd = .001,
                Gd = 9,
                Vd = 6,
                jd = 2;
            class Wd extends Oh {
                constructor(t, e) {
                    super(), this.shadowMaterial = new vc, this.boundingBox = new jn, this.size = new Hn, this.isAnimated = !1, this.needsUpdate = !1, this.intensity = 0, this.castShadow = !0, this.frustumCulled = !1, this.floor = new $r(new _s, this.shadowMaterial), this.floor.rotateX(-Math.PI / 2), this.floor.receiveShadow = !0, this.floor.castShadow = !1, this.floor.frustumCulled = !1, this.add(this.floor), this.shadow.camera.up.set(0, 0, 1), t.add(this), this.target = t, this.setModel(t, e)
                }
                setModel(t, e) {
                    this.isAnimated = t.animationNames.length > 0, this.boundingBox.copy(t.boundingBox), this.size.copy(t.size);
                    const {
                        boundingBox: n,
                        size: i
                    } = this;
                    if (this.isAnimated) {
                        const t = Math.max(i.x, i.y, i.z) * jd;
                        i.y = t, n.expandByVector(i.subScalar(t).multiplyScalar(-.5)), n.max.y = n.min.y + t, i.set(t, t, t)
                    }
                    const r = i.y * Hd;
                    this.position.y = n.max.y + r, n.getCenter(this.floor.position), this.setSoftness(e)
                }
                setSoftness(t) {
                    const e = Math.pow(2, Gd - t * (Gd - Vd));
                    this.setMapSize(e)
                }
                setMapSize(t) {
                    const {
                        camera: e,
                        mapSize: n,
                        map: i
                    } = this.shadow, {
                        size: r,
                        boundingBox: s
                    } = this;
                    null != i && (i.dispose(), this.shadow.map = null), this.isAnimated && (t *= jd);
                    const o = Math.floor(r.x > r.z ? t : t * r.x / r.z),
                        a = Math.floor(r.x > r.z ? t * r.z / r.x : t);
                    n.set(o, a);
                    const l = 2.5 * r.x / o,
                        c = 2.5 * r.z / a;
                    e.left = -s.max.x - l, e.right = -s.min.x + l, e.bottom = s.min.z - c, e.top = s.max.z + c, this.setScaleAndOffset(e.zoom, 0), this.shadow.updateMatrices(this), this.floor.scale.set(r.x + 2 * l, r.z + 2 * c, 1), this.needsUpdate = !0
                }
                setIntensity(t) {
                    this.shadowMaterial.opacity = t, t > 0 ? (this.visible = !0, this.floor.visible = !0) : (this.visible = !1, this.floor.visible = !1)
                }
                getIntensity() {
                    return this.shadowMaterial.opacity
                }
                setRotation(t) {
                    this.shadow.camera.up.set(Math.sin(t), 0, Math.cos(t)), this.shadow.updateMatrices(this)
                }
                setScaleAndOffset(t, e) {
                    const n = this.size.y,
                        i = 1 / t,
                        r = n * Hd;
                    this.floor.position.y = 2 * r - n + e * i;
                    const {
                        camera: s
                    } = this.shadow;
                    s.zoom = t, s.near = 0, s.far = n * t - e, s.projectionMatrix.makeOrthographic(s.left * t, s.right * t, s.top * t, s.bottom * t, s.near, s.far), s.projectionMatrixInverse.getInverse(s.projectionMatrix)
                }
            }
            var qd, Xd;
            const Yd = 45,
                Jd = Yd / 2 * Math.PI / 180,
                Zd = Math.sin(Jd),
                Kd = Math.tan(Jd),
                $d = Symbol("shadow"),
                Qd = Symbol("cancelPendingSourceChange"),
                tp = Symbol("currentGLTF"),
                ep = new Hn,
                np = new Hn,
                ip = new Hn;
            class rp extends Bi {
                constructor() {
                    super(), this[qd] = null, this[Xd] = null, this.animationsByName = new Map, this.currentAnimationAction = null, this.animations = [], this.modelContainer = new Bi, this.animationNames = [], this.boundingBox = new jn, this.size = new Hn, this.idealCameraDistance = 0, this.fieldOfViewAspect = 0, this.userData = {
                        url: null
                    }, this.url = null, this.name = "Model", this.modelContainer.name = "ModelContainer", this.add(this.modelContainer), this.mixer = new pu(this.modelContainer)
                }
                get currentGLTF() {
                    return this[tp]
                }
                hasModel() {
                    return !!this.modelContainer.children.length
                }
                setObject(t) {
                    this.clear(), this.modelContainer.add(t), this.updateFraming(), this.dispatchEvent({
                        type: "model-load"
                    })
                }
                async setSource(t, e, n) {
                    if (!e || e === this.url) return void(n && n(1));
                    let i;
                    null != this[Qd] && (this[Qd](), this[Qd] = null), this.url = e;
                    try {
                        i = await new Promise(async (i, r) => {
                            this[Qd] = () => r();
                            try {
                                i(await t[tv].loader.load(e, t, n))
                            } catch (s) {
                                r(s)
                            }
                        })
                    } catch (a) {
                        if (null == a) return;
                        throw a
                    }
                    this.clear(), this[tp] = i, null != i && this.modelContainer.add(i.scene);
                    const {
                        animations: r
                    } = i, s = new Map, o = [];
                    for (const l of r) s.set(l.name, l), o.push(l.name);
                    this.animations = r, this.animationsByName = s, this.animationNames = o, this.userData.url = e, this.updateFraming(), this.dispatchEvent({
                        type: "model-load",
                        url: e
                    })
                }
                set animationTime(t) {
                    this.mixer.setTime(t)
                }
                get animationTime() {
                    return null != this.currentAnimationAction ? this.currentAnimationAction.time : 0
                }
                get hasActiveAnimation() {
                    return null != this.currentAnimationAction
                }
                playAnimation(t = null, e = 0) {
                    const {
                        animations: n
                    } = this;
                    if (null == n || 0 === n.length) return void console.warn("Cannot play animation (model does not have any animations)");
                    let i = null;
                    null != t && (i = this.animationsByName.get(t)), null == i && (i = n[0]);
                    try {
                        const {
                            currentAnimationAction: t
                        } = this;
                        this.currentAnimationAction = this.mixer.clipAction(i, this).play(), this.currentAnimationAction.enabled = !0, null != t && this.currentAnimationAction !== t && this.currentAnimationAction.crossFadeFrom(t, e, !1)
                    } catch (r) {
                        console.error(r)
                    }
                }
                stopAnimation() {
                    null != this.currentAnimationAction && (this.currentAnimationAction.stop(), this.currentAnimationAction.reset(), this.currentAnimationAction = null), this.mixer.stopAllAction()
                }
                updateAnimation(t) {
                    this.mixer.update(t)
                }
                clear() {
                    this.url = null, this.userData = {
                        url: null
                    };
                    const t = this[tp];
                    if (null != t) {
                        for (const t of this.modelContainer.children) this.modelContainer.remove(t);
                        t.dispose(), this[tp] = null
                    }
                    null != this.currentAnimationAction && (this.currentAnimationAction.stop(), this.currentAnimationAction = null), this.mixer.stopAllAction(), this.mixer.uncacheRoot(this)
                }
                updateFraming(t = null) {
                    this.remove(this.modelContainer), null == t && (this.boundingBox.setFromObject(this.modelContainer), this.boundingBox.getSize(this.size), t = this.boundingBox.getCenter(new Hn));
                    const e = Math.sqrt(Bd(this.modelContainer, (e, n) => Math.max(e, t.distanceToSquared(n))));
                    this.idealCameraDistance = e / Zd;
                    this.fieldOfViewAspect = Bd(this.modelContainer, (e, n) => {
                        n.sub(t);
                        const i = Math.sqrt(n.x * n.x + n.z * n.z);
                        return Math.max(e, i / (this.idealCameraDistance - Math.abs(n.y)))
                    }) / Kd, this.add(this.modelContainer)
                }
                setShadowIntensity(t, e) {
                    let n = this[$d];
                    null != n ? (n.setIntensity(t), n.setModel(this, e)) : t > 0 && (n = new Wd(this, e), n.setIntensity(t), this[$d] = n)
                }
                setShadowSoftness(t) {
                    const e = this[$d];
                    null != e && e.setSoftness(t)
                }
                setShadowRotation(t) {
                    const e = this[$d];
                    null != e && e.setRotation(t)
                }
                updateShadow() {
                    const t = this[$d];
                    if (null == t) return !1; {
                        const {
                            needsUpdate: e
                        } = t;
                        return t.needsUpdate = !1, e
                    }
                }
                setShadowScaleAndOffset(t, e) {
                    const n = this[$d];
                    null != n && n.setScaleAndOffset(t, e)
                }
                addHotspot(t) {
                    this.add(t)
                }
                removeHotspot(t) {
                    this.remove(t)
                }
                forHotspots(t) {
                    const {
                        children: e
                    } = this;
                    for (let n = 0, i = e.length; n < i; n++) {
                        const i = e[n];
                        i instanceof kd && t(i)
                    }
                }
                updateHotspots(t) {
                    this.forHotspots(e => {
                        ep.copy(t), np.setFromMatrixPosition(e.matrixWorld), ep.sub(np), ip.copy(e.normal).transformDirection(this.matrixWorld), ep.dot(ip) < 0 ? e.hide() : e.show()
                    })
                }
                orientHotspots(t) {
                    this.forHotspots(e => {
                        e.orient(t)
                    })
                }
                setHotspotsVisibility(t) {
                    this.forHotspots(e => {
                        e.visible = t
                    })
                }
            }
            qd = $d, Xd = tp;
            const sp = Math.tan(Yd / 2 * Math.PI / 180),
                op = new vu,
                ap = new Hn;
            class lp extends Pa {
                constructor({
                    canvas: t,
                    element: e,
                    width: n,
                    height: i
                }) {
                    super(), this.aspect = 1, this.shadowIntensity = 0, this.shadowSoftness = 1, this.width = 1, this.height = 1, this.isDirty = !1, this.context = null, this.exposure = 1, this.canScale = !0, this.framedFieldOfView = Yd, this.camera = new cs(45, 1, .1, 100), this.goalTarget = new Hn, this.targetDamperX = new Md, this.targetDamperY = new Md, this.targetDamperZ = new Md, this.name = "ModelScene", this.element = e, this.canvas = t, this.model = new rp, this.camera = new cs(45, 1, .1, 100), this.camera.name = "MainCamera", this.activeCamera = this.camera, this.add(this.model), this.setSize(n, i), this.model.addEventListener("model-load", t => this.onModelLoad(t))
                }
                createContext() {
                    this.context = this.canvas.getContext("2d")
                }
                async setModelSource(t, e) {
                    try {
                        await this.model.setSource(this.element, t, e)
                    } catch (n) {
                        throw new Error(`Could not set model source to '${t}': ${n.message}`)
                    }
                }
                setSize(t, e) {
                    this.width === t && this.height === e || (this.width = Math.max(t, 1), this.height = Math.max(e, 1), this.aspect = this.width / this.height, this.frameModel(), this.isDirty = !0)
                }
                frameModel() {
                    const t = sp * Math.max(1, this.model.fieldOfViewAspect / this.aspect);
                    this.framedFieldOfView = 2 * Math.atan(t) * 180 / Math.PI
                }
                getSize() {
                    return {
                        width: this.width,
                        height: this.height
                    }
                }
                getCamera() {
                    return this.activeCamera
                }
                setCamera(t) {
                    this.activeCamera = t
                }
                onModelLoad(t) {
                    this.frameModel(), this.setShadowIntensity(this.shadowIntensity), this.isDirty = !0, this.dispatchEvent({
                        type: "model-load",
                        url: t.url
                    })
                }
                setTarget(t, e, n) {
                    this.goalTarget.set(-t, -e, -n)
                }
                getTarget() {
                    return ap.copy(this.goalTarget).multiplyScalar(-1)
                }
                jumpToGoal() {
                    this.updateTarget(xd)
                }
                updateTarget(t) {
                    const e = this.goalTarget,
                        n = this.model.position;
                    if (!e.equals(n)) {
                        const i = this.model.idealCameraDistance;
                        let {
                            x: r,
                            y: s,
                            z: o
                        } = n;
                        r = this.targetDamperX.update(r, e.x, t, i), s = this.targetDamperY.update(s, e.y, t, i), o = this.targetDamperZ.update(o, e.z, t, i), this.model.position.set(r, s, o), this.model.updateMatrixWorld(), this.model.setShadowRotation(this.yaw), this.isDirty = !0
                    }
                }
                pointTowards(t, e) {
                    const {
                        x: n,
                        z: i
                    } = this.position;
                    this.yaw = Math.atan2(t - n, e - i)
                }
                set yaw(t) {
                    this.rotation.y = t, this.model.setShadowRotation(t), this.isDirty = !0
                }
                get yaw() {
                    return this.rotation.y
                }
                setShadowIntensity(t) {
                    t = Math.max(t, 0), this.shadowIntensity = t, this.model.hasModel() && this.model.setShadowIntensity(t, this.shadowSoftness)
                }
                setShadowSoftness(t) {
                    this.shadowSoftness = t, this.model.setShadowSoftness(t)
                }
                positionAndNormalFromPoint(t, e = this) {
                    op.setFromCamera(t, this.getCamera());
                    const n = op.intersectObject(e, !0);
                    if (0 === n.length) return null;
                    const i = n[0];
                    return null == i.face ? null : (i.face.normal.applyNormalMatrix((new On).getNormalMatrix(i.object.matrixWorld)), {
                        position: i.point,
                        normal: i.face.normal
                    })
                }
            }
            var cp = function() {
                    var t = new yc({
                        uniforms: {
                            roughnessMap: {
                                value: null
                            },
                            normalMap: {
                                value: null
                            },
                            texelSize: {
                                value: new Cn(1, 1)
                            }
                        },
                        vertexShader: "\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t\t}\n\t\t",
                        fragmentShader: "\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D roughnessMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tfloat roughnessToVariance( float roughness ) {\n\n\t\t\t\tfloat variance = 0.0;\n\n\t\t\t\tif ( roughness >= r1 ) {\n\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\n\n\t\t\t\t} else if ( roughness >= r4 ) {\n\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\n\n\t\t\t\t} else if ( roughness >= r5 ) {\n\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\n\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\n\n\t\t\t\t}\n\n\t\t\t\treturn variance;\n\n\t\t\t}\n\n\t\t\tfloat varianceToRoughness( float variance ) {\n\n\t\t\t\tfloat roughness = 0.0;\n\n\t\t\t\tif ( variance >= v1 ) {\n\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\n\n\t\t\t\t} else if ( variance >= v4 ) {\n\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\n\n\t\t\t\t} else if ( variance >= v5 ) {\n\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\n\n\t\t\t\t}\n\n\t\t\t\treturn roughness;\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\n\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\n\n\t\t\t\tfloat roughness = gl_FragColor.g;\n\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\n\n\t\t\t\tvec3 avgNormal;\n\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\n\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\n\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\n\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\n\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\n\n\t\t\t}\n\t\t",
                        blending: G,
                        depthTest: !1,
                        depthWrite: !1
                    });
                    return t.type = "RoughnessMipmapper", t
                }(),
                hp = new $r(new _s(2, 2), cp),
                up = new Ph(0, 1, 0, 1, 0, 1),
                dp = null,
                pp = null;

            function mp(t) {
                (pp = t).compile(hp, up)
            }
            mp.prototype = {
                constructor: mp,
                generateMipmaps: function(t) {
                    if ("roughnessMap" in t !== !1) {
                        var {
                            roughnessMap: e,
                            normalMap: n
                        } = t;
                        if (null !== e && null !== n && e.generateMipmaps && !t.userData.roughnessUpdated) {
                            t.userData.roughnessUpdated = !0;
                            var i = Math.max(e.image.width, n.image.width),
                                r = Math.max(e.image.height, n.image.height);
                            if (Pn.isPowerOfTwo(i) && Pn.isPowerOfTwo(r)) {
                                var s = pp.getRenderTarget(),
                                    o = pp.autoClear;
                                if (pp.autoClear = !1, null !== dp && dp.width === i && dp.height === r || (null !== dp && dp.dispose(), (dp = new zn(i, r, {
                                        depthBuffer: !1
                                    })).scissorTest = !0), i !== e.image.width || r !== e.image.height) {
                                    var a = new zn(i, r, {
                                        wrapS: e.wrapS,
                                        wrapT: e.wrapT,
                                        magFilter: e.magFilter,
                                        minFilter: e.minFilter,
                                        depthBuffer: !1
                                    });
                                    a.texture.generateMipmaps = !0, pp.setRenderTarget(a), t.roughnessMap = a.texture, t.metalnessMap == e && (t.metalnessMap = t.roughnessMap), t.aoMap == e && (t.aoMap = t.roughnessMap)
                                }
                                cp.uniforms.roughnessMap.value = e, cp.uniforms.normalMap.value = n;
                                for (var l = new Cn(0, 0), c = cp.uniforms.texelSize.value, h = 0; i >= 1 && r >= 1; ++h, i /= 2, r /= 2) c.set(1 / i, 1 / r), 0 == h && c.set(0, 0), dp.viewport.set(l.x, l.y, i, r), dp.scissor.set(l.x, l.y, i, r), pp.setRenderTarget(dp), pp.render(hp, up), pp.copyFramebufferToTexture(l, t.roughnessMap, h), cp.uniforms.roughnessMap.value = t.roughnessMap;
                                e !== t.roughnessMap && e.dispose(), pp.setRenderTarget(s), pp.autoClear = o
                            }
                        }
                    }
                },
                dispose: function() {
                    cp.dispose(), hp.geometry.dispose(), null != dp && dp.dispose()
                }
            };
            const fp = t => t && "null" !== t ? vp(t) : null,
                gp = () => {
                    if (b) return;
                    const t = [];
                    throw g || t.push("WebXR Device API"), v || t.push("WebXR Hit Test API"), new Error(`The following APIs are required for AR, but are missing in this browser: ${t.join(", ")}`)
                },
                vp = t => {
                    return new URL(t, window.location.toString()).toString()
                },
                yp = (t, e) => {
                    let n = null;
                    const i = (...i) => {
                        null == n && (t(...i), n = self.setTimeout(() => n = null, e))
                    };
                    return i.flush = () => {
                        null != n && (self.clearTimeout(n), n = null)
                    }, i
                },
                xp = (t, e) => {
                    let n = null;
                    return (...i) => {
                        null != n && self.clearTimeout(n), n = self.setTimeout(() => {
                            n = null, t(...i)
                        }, e)
                    }
                },
                bp = (t, e, n) => Math.max(e, Math.min(n, t)),
                _p = (() => {
                    const t = (() => {
                        const t = null != document.head ? Array.from(document.head.querySelectorAll("meta")) : [];
                        for (const e of t)
                            if ("viewport" === e.name) return !0;
                        return !1
                    })();
                    return t || console.warn('No <meta name="viewport"> detected; <model-viewer> will cap pixel density at 1.'), () => t ? window.devicePixelRatio : 1
                })(),
                wp = (() => {
                    const t = new RegExp("[?&]model-viewer-debug-mode(&|$)");
                    return () => self.ModelViewerElement && self.ModelViewerElement.debugMode || self.location && self.location.search && self.location.search.match(t)
                })(),
                Mp = t => {
                    if (null != t.keys) return t.keys().next().value || null;
                    let e = null;
                    try {
                        t.forEach((t, n, i) => {
                            throw e = n, new Error
                        })
                    } catch (n) {}
                    return e
                },
                Sp = (t, e, n = null) => new Promise(i => {
                    t.addEventListener(e, (function r(s) {
                        n && !n(s) || (i(s), t.removeEventListener(e, r))
                    }))
                }),
                Tp = .2,
                Ep = .75,
                Ap = Math.PI / 24,
                Lp = new Cn,
                Rp = (t, e, n) => {
                    let i = e > 0 ? n > 0 ? 0 : -Math.PI / 2 : n > 0 ? Math.PI / 2 : Math.PI;
                    for (let r = 0; r <= 12; ++r) t.push(e + (Tp - .03) * Math.cos(i), n + (Tp - .03) * Math.sin(i), 0, e + Tp * Math.cos(i), n + Tp * Math.sin(i), 0), i += Ap
                };
            class Pp extends $r {
                constructor(t) {
                    const e = new Nr,
                        n = [],
                        i = [],
                        {
                            size: r,
                            boundingBox: s
                        } = t,
                        o = r.x / 2,
                        a = r.z / 2;
                    Rp(i, o, a), Rp(i, -o, a), Rp(i, -o, -a), Rp(i, o, -a);
                    const l = i.length / 3;
                    for (let u = 0; u < l - 2; u += 2) n.push(u, u + 1, u + 3, u, u + 3, u + 2);
                    const c = l - 2;
                    n.push(c, c + 1, 1, c, 1, 0), e.setAttribute("position", new Mr(i, 3)), e.setIndex(n), super(e);
                    const h = this.material;
                    h.side = H, h.transparent = !0, h.opacity = 0, this.goalOpacity = 0, this.opacityDamper = new Md, this.hitPlane = new $r(new _s(r.x + 2 * Tp, r.z + 2 * Tp)), this.hitPlane.visible = !1, this.add(this.hitPlane), this.rotateX(-Math.PI / 2), s.getCenter(this.position), this.shadowHeight = s.min.y, this.position.y = this.shadowHeight, t.add(this)
                }
                getHit(t, e, n) {
                    Lp.set(e, -n), this.hitPlane.visible = !0;
                    const i = t.positionAndNormalFromPoint(Lp, this.hitPlane);
                    return this.hitPlane.visible = !1, null == i ? null : i.position
                }
                set offsetHeight(t) {
                    this.position.y = this.shadowHeight + t
                }
                get offsetHeight() {
                    return this.position.y - this.shadowHeight
                }
                set show(t) {
                    this.goalOpacity = t ? Ep : 0
                }
                updateOpacity(t) {
                    const e = this.material;
                    e.opacity = this.opacityDamper.update(e.opacity, this.goalOpacity, t, 1), this.visible = e.opacity > 0
                }
                dispose() {
                    const {
                        geometry: t,
                        material: e
                    } = this.hitPlane;
                    t.dispose(), e.dispose(), this.geometry.dispose(), this.material.dispose()
                }
            }
            var Cp, Op, Ip, Np, Dp, Fp, Up, zp, kp, Bp, Hp, Gp, Vp, jp, Wp, qp, Xp, Yp, Jp, Zp, Kp, $p, Qp, tm, em, nm, im, rm, sm, om, am, lm, cm, hm, um, dm, pm;
            const mm = .3,
                fm = 1.5,
                gm = 20,
                vm = .4,
                ym = 1.2,
                xm = 1 / ym,
                bm = .25,
                _m = {
                    NOT_PRESENTING: "not-presenting",
                    SESSION_STARTED: "session-started",
                    OBJECT_PLACED: "object-placed",
                    FAILED: "failed"
                },
                wm = Symbol("presentedScene"),
                Mm = Symbol("placementBox"),
                Sm = Symbol("lastTick"),
                Tm = Symbol("turntableRotation"),
                Em = Symbol("oldShadowIntensity"),
                Am = Symbol("oldBackground"),
                Lm = Symbol("rafId"),
                Rm = Symbol("currentSession"),
                Pm = Symbol("tick"),
                Cm = Symbol("refSpace"),
                Om = Symbol("viewerRefSpace"),
                Im = Symbol("frame"),
                Nm = Symbol("initialized"),
                Dm = Symbol("initialModelToWorld"),
                Fm = Symbol("placementComplete"),
                Um = Symbol("hitTestSource"),
                zm = Symbol("transiertHitTestSource"),
                km = Symbol("inputSource"),
                Bm = Symbol("isTranslating"),
                Hm = Symbol("isRotating"),
                Gm = Symbol("isScaling"),
                Vm = Symbol("lastDragPosition"),
                jm = Symbol("lastScalar"),
                Wm = Symbol("goalPosition"),
                qm = Symbol("goalYaw"),
                Xm = Symbol("goalScale"),
                Ym = Symbol("xDamper"),
                Jm = Symbol("yDamper"),
                Zm = Symbol("zDamper"),
                Km = Symbol("yawDamper"),
                $m = Symbol("scaleDamper"),
                Qm = Symbol("damperRate"),
                tf = Symbol("resolveCleanup"),
                ef = Symbol("exitWebXRButtonContainer"),
                nf = Symbol("onWebXRFrame"),
                rf = Symbol("postSessionCleanup"),
                sf = Symbol("updateCamera"),
                of = Symbol("placeInitially"),
                af = Symbol("getHitPoint"),
                lf = Symbol("onSelectStart"),
                cf = Symbol("onSelect"),
                hf = Symbol("onUpdateScene"),
                uf = Symbol("fingerSeparation"),
                df = Symbol("processInput"),
                pf = Symbol("moveScene"),
                mf = Symbol("onExitWebXRButtonContainerClick"),
                ff = new Hn,
                gf = new fi,
                vf = new Hn;
            class yf extends An {
                constructor(t) {
                    super(), this.renderer = t, this.camera = new cs, this[Cp] = null, this[Op] = null, this[Ip] = null, this[Np] = null, this[Dp] = null, this[Fp] = null, this[Up] = null, this[zp] = null, this[kp] = null, this[Bp] = null, this[Hp] = null, this[Gp] = null, this[Vp] = null, this[jp] = null, this[Wp] = null, this[qp] = null, this[Xp] = !1, this[Yp] = new fi, this[Jp] = !1, this[Zp] = !1, this[Kp] = !1, this[$p] = !1, this[Qp] = new Hn, this[tm] = 0, this[em] = new Hn, this[nm] = 0, this[im] = 1, this[rm] = new Md, this[sm] = new Md, this[om] = new Md, this[am] = new Md, this[lm] = new Md, this[cm] = 1, this[hm] = () => this.stopPresenting(), this[um] = () => {
                        null != this[Mm] && this.isPresenting && (this[Mm].dispose(), this[Mm] = new Pp(this[wm].model))
                    }, this[dm] = t => {
                        const e = this[zm];
                        if (null == e) return;
                        const n = this[Im].getHitTestResultsForTransientInput(e),
                            i = this[wm],
                            r = this[Mm];
                        if (1 === n.length) {
                            this[km] = t.inputSource;
                            const {
                                axes: e
                            } = this[km].gamepad, n = r.getHit(this[wm], e[0], e[1]);
                            r.show = !0, null != n ? (this[Bm] = !0, this[Vm].copy(n)) : (this[Hm] = !0, this[jm] = e[0])
                        } else 2 === n.length && i.canScale && (r.show = !0, this[Gm] = !0, this[jm] = this[uf](n) / i.scale.x)
                    }, this[pm] = () => {
                        this[Bm] = !1, this[Hm] = !1, this[Gm] = !1, this[km] = null, this[Wm].y += this[Mm].offsetHeight * this[wm].scale.x, this[Mm].show = !1
                    }, this.threeRenderer = t.threeRenderer, this.camera.matrixAutoUpdate = !1
                }
                async resolveARSession(t) {
                    gp();
                    const e = await navigator.xr.requestSession("immersive-ar", {
                            requiredFeatures: ["hit-test"],
                            optionalFeatures: ["dom-overlay"],
                            domOverlay: {
                                root: t.element.shadowRoot.querySelector("div.default")
                            }
                        }),
                        n = this.threeRenderer.context;
                    await n.makeXRCompatible(), e.updateRenderState({
                        baseLayer: new XRWebGLLayer(e, n, {
                            alpha: !0
                        })
                    });
                    let i = new Promise((t, n) => {
                        e.requestAnimationFrame(() => t())
                    });
                    await i, t.element[Qg](window.screen);
                    const {
                        framebuffer: r,
                        framebufferWidth: s,
                        framebufferHeight: o
                    } = e.renderState.baseLayer;
                    this.threeRenderer.setFramebuffer(r), this.threeRenderer.setPixelRatio(1), this.threeRenderer.setSize(s, o, !1);
                    const a = t.element.shadowRoot.querySelector(".slot.exit-webxr-ar-button");
                    return a.classList.add("enabled"), a.addEventListener("click", this[mf]), this[ef] = a, e
                }
                get presentedScene() {
                    return this[wm]
                }
                async supportsPresentation() {
                    try {
                        return gp(), await navigator.xr.isSessionSupported("immersive-ar")
                    } catch (t) {
                        return !1
                    }
                }
                async present(t) {
                    this.isPresenting && console.warn("Cannot present while a model is already presenting");
                    let e = new Promise((t, e) => {
                        requestAnimationFrame(() => t())
                    });
                    t.model.setHotspotsVisibility(!1), t.isDirty = !0, await e, this[wm] = t;
                    const n = await this.resolveARSession(t);
                    n.addEventListener("end", () => {
                        this[rf]()
                    }, {
                        once: !0
                    }), this[Cm] = await n.requestReferenceSpace("local"), this[Om] = await n.requestReferenceSpace("viewer"), t.setCamera(this.camera), this[Nm] = !1, this[Qm] = vm, this[Tm] = t.yaw, t.yaw = 0, this[qm] = 0, this[Xm] = 1, this[Am] = t.background, t.background = null, this[Em] = t.shadowIntensity, t.setShadowIntensity(0), t.addEventListener("model-load", this[hf]);
                    const i = gm * Math.PI / 180,
                        r = new XRRay(new DOMPoint(0, 0, 0), {
                            x: 0,
                            y: -Math.sin(i),
                            z: -Math.cos(i)
                        });
                    n.requestHitTestSource({
                        space: this[Om],
                        offsetRay: r
                    }).then(t => {
                        this[Um] = t
                    }), this[Rm] = n, this[Mm] = new Pp(t.model), this[Fm] = !1, this[Sm] = performance.now(), this[Pm]()
                }
                async stopPresenting() {
                    if (!this.isPresenting) return;
                    const t = new Promise(t => {
                        this[tf] = t
                    });
                    try {
                        await this[Rm].end(), await t
                    } catch (e) {
                        console.warn("Error while trying to end AR session"), console.warn(e), this[rf]()
                    }
                }[(Cp = Mm, Op = Sm, Ip = Tm, Np = Em, Dp = Am, Fp = Lm, Up = Rm, zp = Cm, kp = Om, Bp = Im, Hp = Um, Gp = zm, Vp = km, jp = wm, Wp = tf, qp = ef, Xp = Nm, Yp = Dm, Jp = Fm, Zp = Bm, Kp = Hm, $p = Gm, Qp = Vm, tm = jm, em = Wm, nm = qm, im = Xm, rm = Ym, sm = Jm, om = Zm, am = Km, lm = $m, cm = Qm, hm = mf, rf)]() {
                    this.threeRenderer.setFramebuffer(null);
                    const t = this[Rm];
                    null != t && (t.removeEventListener("selectstart", this[lf]), t.removeEventListener("selectend", this[cf]), t.cancelAnimationFrame(this[Lm]), this[Rm] = null);
                    const e = this[wm];
                    if (null != e) {
                        const {
                            model: t,
                            element: n
                        } = e;
                        e.setCamera(e.camera), t.remove(this[Mm]), e.position.set(0, 0, 0), e.scale.set(1, 1, 1), t.setShadowScaleAndOffset(1, 0);
                        const i = this[Tm];
                        null != i && (e.yaw = i);
                        const r = this[Em];
                        null != r && e.setShadowIntensity(r);
                        const s = this[Am];
                        null != s && (e.background = s), e.removeEventListener("model-load", this[hf]), t.orientHotspots(0), n.requestUpdate("cameraTarget"), n[Qg](n.getBoundingClientRect())
                    }
                    this.renderer.height = 0;
                    const n = this[ef];
                    null != n && (n.classList.remove("enabled"), n.removeEventListener("click", this[mf]), this[ef] = null);
                    const i = this[zm];
                    null != i && (i.cancel(), this[zm] = null);
                    const r = this[Um];
                    null != r && (r.cancel(), this[Um] = null), null != this[Mm] && (this[Mm].dispose(), this[Mm] = null), this[Sm] = null, this[Tm] = null, this[Em] = null, this[Am] = null, this[Lm] = null, this[Cm] = null, this[wm] = null, this[Om] = null, this[Im] = null, this[km] = null, null != this[tf] && this[tf](), this.dispatchEvent({
                        type: "status",
                        status: _m.NOT_PRESENTING
                    })
                }
                get isPresenting() {
                    return null != this[wm]
                }
                updateTarget() {
                    const t = this[wm];
                    if (null != t) {
                        const e = t.getTarget();
                        t.setTarget(e.x, t.model.boundingBox.min.y, e.z)
                    }
                }[(um = hf, sf)](t) {
                    const {
                        camera: e
                    } = this, {
                        matrix: n
                    } = e;
                    if (n.fromArray(t.transform.matrix), e.updateMatrixWorld(!0), e.position.setFromMatrixPosition(n), null != this[Um]) {
                        const {
                            position: t,
                            model: n
                        } = this[wm], i = n.idealCameraDistance;
                        e.getWorldDirection(t), t.multiplyScalar(i), t.add(e.position)
                    }
                    if (!this[Nm]) {
                        e.projectionMatrix.fromArray(t.projectionMatrix), e.projectionMatrixInverse.getInverse(e.projectionMatrix);
                        const {
                            x: n,
                            z: i
                        } = e.position, r = this[wm];
                        r.pointTowards(n, i), r.model.updateMatrixWorld(!0), this[qm] = r.yaw, this[Dm].copy(r.model.matrixWorld), r.model.setHotspotsVisibility(!0), this[Nm] = !0, this.dispatchEvent({
                            type: "status",
                            status: _m.SESSION_STARTED
                        })
                    }
                    if (t.requestViewportScale && t.recommendedViewportScale) {
                        const e = t.recommendedViewportScale;
                        t.requestViewportScale(Math.max(e, bm))
                    }
                    const i = this[Rm].renderState.baseLayer.getViewport(t);
                    this.threeRenderer.setViewport(i.x, i.y, i.width, i.height), this[wm].model.orientHotspots(Math.atan2(n.elements[1], n.elements[5]))
                }[ of ](t) {
                    const e = this[Um];
                    if (null == e) return;
                    const n = t.getHitTestResults(e);
                    if (0 == n.length) return;
                    const i = n[0],
                        r = this[af](i);
                    if (null == r) return;
                    this.placeModel(r), e.cancel(), this[Um] = null;
                    const {
                        session: s
                    } = t;
                    s.addEventListener("selectstart", this[lf]), s.addEventListener("selectend", this[cf]), s.requestHitTestSourceForTransientInput({
                        profile: "generic-touchscreen"
                    }).then(t => {
                        this[zm] = t
                    })
                }[af](t) {
                    const e = t.getPose(this[Cm]);
                    if (null == e) return null;
                    const n = gf.fromArray(e.transform.matrix);
                    return n.elements[5] > .75 ? vf.setFromMatrixPosition(n) : null
                }
                placeModel(t) {
                    const e = this[wm],
                        {
                            model: n
                        } = e,
                        {
                            min: i,
                            max: r
                        } = n.boundingBox;
                    this[Mm].show = !0;
                    const s = this[Wm];
                    s.copy(t);
                    const o = t.y,
                        a = this.camera.position.clone(),
                        l = t.clone().sub(a).normalize();
                    a.sub(l.multiplyScalar(n.idealCameraDistance));
                    const c = new mi(a, l.normalize()),
                        h = this[Dm],
                        u = (new Hn).setFromMatrixPosition(h).add(t);
                    h.setPosition(u);
                    const d = (new fi).getInverse(h);
                    c.applyMatrix4(d), r.y += 10, c.intersectBox(n.boundingBox, u), r.y -= 10, null != u && (u.applyMatrix4(h), s.add(t).sub(u));
                    const p = e.getTarget();
                    e.setTarget(p.x, i.y, p.z), s.y = o, this.dispatchEvent({
                        type: "status",
                        status: _m.OBJECT_PLACED
                    })
                }[(dm = lf, pm = cf, uf)](t) {
                    const e = t[0].inputSource.gamepad.axes,
                        n = t[1].inputSource.gamepad.axes,
                        i = n[0] - e[0],
                        r = n[1] - e[1];
                    return Math.sqrt(i * i + r * r)
                }[df](t) {
                    const e = this[zm];
                    if (null == e) return;
                    if (!this[Bm] && !this[Gm] && !this[Hm]) return;
                    const n = t.getHitTestResultsForTransientInput(e),
                        i = this[wm],
                        r = i.scale.x;
                    if (this[Gm])
                        if (n.length < 2) this[Gm] = !1;
                        else {
                            const t = this[uf](n) / this[jm];
                            this[Xm] = t < ym && t > xm ? 1 : t
                        }
                    else {
                        if (2 === n.length && i.canScale) return this[Bm] = !1, this[Hm] = !1, this[Gm] = !0, void(this[jm] = this[uf](n) / r);
                        if (this[Hm]) {
                            const t = this[km].gamepad.axes[0];
                            this[qm] += (t - this[jm]) * fm, this[jm] = t
                        } else this[Bm] && n.forEach(t => {
                            if (t.inputSource !== this[km] || t.results.length < 1) return;
                            const e = this[af](t.results[0]);
                            if (null == e) return;
                            this[Wm].sub(this[Vm]);
                            const n = e.y - this[Vm].y;
                            if (n < 0) {
                                this[Mm].offsetHeight = n / r, this[wm].model.setShadowScaleAndOffset(r, n);
                                const t = ff.copy(this.camera.position),
                                    i = -n / (t.y - e.y);
                                t.multiplyScalar(i), e.multiplyScalar(1 - i).add(t)
                            }
                            this[Wm].add(e), this[Vm].copy(e)
                        })
                    }
                }[pf](t) {
                    const e = this[wm],
                        {
                            model: n,
                            position: i,
                            yaw: r
                        } = e,
                        s = n.idealCameraDistance,
                        o = this[Wm],
                        a = e.scale.x,
                        l = this[Mm];
                    if (null == this[Um] && (!o.equals(i) || this[Xm] !== a)) {
                        let {
                            x: r,
                            y: c,
                            z: h
                        } = i;
                        t *= this[Qm], r = this[Ym].update(r, o.x, t, s), c = this[Jm].update(c, o.y, t, s), h = this[Zm].update(h, o.z, t, s), i.set(r, c, h);
                        const u = this[$m].update(a, this[Xm], t, 1);
                        if (e.scale.set(u, u, u), !this[Bm]) {
                            const t = o.y - c;
                            this[Fm] ? (l.offsetHeight = t / u, n.setShadowScaleAndOffset(u, t)) : 0 === t && (this[Fm] = !0, l.show = !1, e.setShadowIntensity(mm), this[Qm] = 1)
                        }
                    }
                    l.updateOpacity(t), e.updateTarget(t), e.updateMatrixWorld(!0), e.yaw = this[Km].update(r, this[qm], t, Math.PI)
                }[Pm]() {
                    this[Lm] = this[Rm].requestAnimationFrame((t, e) => this[nf](t, e))
                }[nf](t, e) {
                    this[Im] = e;
                    const n = e.getViewerPose(this[Cm]);
                    this[Pm]();
                    const i = this[wm];
                    if (null == n || null == i) return;
                    let r = !0;
                    for (const s of n.views) {
                        if (this[sf](s), r) {
                            this[ of ](e), this[df](e);
                            const n = t - this[Sm];
                            this[pf](n), this.renderer.preRender(i, t, n), this[Sm] = t
                        }
                        this.threeRenderer.render(i, this.camera), r = !1
                    }
                }
            }
            class xf {
                constructor(t) {
                    t.threeRenderer.debug = {
                        checkShaderErrors: !0
                    }, Promise.resolve().then(() => {
                        self.dispatchEvent(new CustomEvent("model-viewer-renderer-debug", {
                            detail: {
                                renderer: t,
                                THREE: {
                                    ShaderMaterial: as,
                                    Texture: Fn,
                                    Mesh: $r,
                                    Scene: Pa,
                                    PlaneBufferGeometry: _s,
                                    OrthographicCamera: Ph,
                                    WebGLRenderTarget: zn
                                }
                            }
                        }))
                    })
                }
                addScene(t) {
                    self.dispatchEvent(new CustomEvent("model-viewer-scene-added-debug", {
                        detail: {
                            scene: t
                        }
                    }))
                }
                removeScene(t) {
                    self.dispatchEvent(new CustomEvent("model-viewer-scene-removed-debug", {
                        detail: {
                            scene: t
                        }
                    }))
                }
            }
            const bf = Symbol("threeGLTF"),
                _f = Symbol("gltf"),
                wf = Symbol("gltfElementMap"),
                Mf = Symbol("threeObjectMap"),
                Sf = Symbol("parallelTraverseThreeScene"),
                Tf = Symbol("correlateOriginalThreeGLTF"),
                Ef = Symbol("correlateCloneThreeGLTF");
            class Af {
                constructor(t, e, n, i) {
                    this[bf] = t, this[_f] = e, this[wf] = i, this[Mf] = n
                }
                static from(t, e) {
                    return null != e ? this[Ef](t, e) : this[Tf](t)
                }
                static[Tf](t) {
                    const e = t.parser.json,
                        {
                            associations: n
                        } = t.parser,
                        i = new Map;
                    return n.forEach((t, n) => {
                        if (null == t) return;
                        const {
                            type: r,
                            index: s
                        } = t, o = (e[r] || [])[s];
                        if (null == o) return;
                        let a = i.get(o);
                        null == a && (a = new Set, i.set(o, a)), a.add(n)
                    }), new Af(t, e, n, i)
                }
                static[Ef](t, e) {
                    const n = e.threeGLTF,
                        i = e.gltf,
                        r = JSON.parse(JSON.stringify(i)),
                        s = new Map,
                        o = new Map;
                    for (let a = 0; a < n.scenes.length; a++) this[Sf](n.scenes[a], t.scenes[a], (t, n) => {
                        const i = e.threeObjectMap.get(t);
                        if (null != i) {
                            const {
                                type: t,
                                index: e
                            } = i, a = r[t][e];
                            s.set(n, {
                                type: t,
                                index: e
                            });
                            const l = o.get(a) || new Set;
                            l.add(n), o.set(a, l)
                        }
                    });
                    return new Af(t, r, s, o)
                }
                static[Sf](t, e, n) {
                    const i = (t, e) => {
                        if (n(t, e), t.isObject3D) {
                            if ((t => t.isMesh)(t))
                                if (Array.isArray(t.material))
                                    for (let n = 0; n < t.material.length; ++n) i(t.material[n], e.material[n]);
                                else i(t.material, e.material);
                            for (let n = 0; n < t.children.length; ++n) i(t.children[n], e.children[n])
                        }
                    };
                    i(t, e)
                }
                get threeGLTF() {
                    return this[bf]
                }
                get gltf() {
                    return this[_f]
                }
                get gltfElementMap() {
                    return this[wf]
                }
                get threeObjectMap() {
                    return this[Mf]
                }
            }
            var Lf = {
                retarget: function() {
                    var t = new Hn,
                        e = new Bn,
                        n = new Hn,
                        i = new fi,
                        r = new fi,
                        s = new fi;
                    return function(o, a, l) {
                        (l = l || {}).preserveMatrix = void 0 === l.preserveMatrix || l.preserveMatrix, l.preservePosition = void 0 === l.preservePosition || l.preservePosition, l.preserveHipPosition = void 0 !== l.preserveHipPosition && l.preserveHipPosition, l.useTargetMatrix = void 0 !== l.useTargetMatrix && l.useTargetMatrix, l.hip = void 0 !== l.hip ? l.hip : "hip", l.names = l.names || {};
                        var c, h, u, d, p, m, f = a.isObject3D ? a.skeleton.bones : this.getBones(a),
                            g = o.isObject3D ? o.skeleton.bones : this.getBones(o);
                        if (o.isObject3D ? o.skeleton.pose() : (l.useTargetMatrix = !0, l.preserveMatrix = !1), l.preservePosition)
                            for (p = [], m = 0; m < g.length; m++) p.push(g[m].position.clone());
                        if (l.preserveMatrix)
                            for (o.updateMatrixWorld(), o.matrixWorld.identity(), m = 0; m < o.children.length; ++m) o.children[m].updateMatrixWorld(!0);
                        if (l.offsets)
                            for (c = [], m = 0; m < g.length; ++m) h = g[m], u = l.names[h.name] || h.name, l.offsets && l.offsets[u] && (h.matrix.multiply(l.offsets[u]), h.matrix.decompose(h.position, h.quaternion, h.scale), h.updateMatrixWorld()), c.push(h.matrixWorld.clone());
                        for (m = 0; m < g.length; ++m) {
                            if (h = g[m], u = l.names[h.name] || h.name, d = this.getBoneByName(u, f), s.copy(h.matrixWorld), d) {
                                if (d.updateMatrixWorld(), l.useTargetMatrix ? r.copy(d.matrixWorld) : (r.getInverse(o.matrixWorld), r.multiply(d.matrixWorld)), n.setFromMatrixScale(r), r.scale(n.set(1 / n.x, 1 / n.y, 1 / n.z)), s.makeRotationFromQuaternion(e.setFromRotationMatrix(r)), o.isObject3D) {
                                    var v = g.indexOf(h),
                                        y = c ? c[v] : i.getInverse(o.skeleton.boneInverses[v]);
                                    s.multiply(y)
                                }
                                s.copyPosition(r)
                            }
                            h.parent && h.parent.isBone ? (h.matrix.getInverse(h.parent.matrixWorld), h.matrix.multiply(s)) : h.matrix.copy(s), l.preserveHipPosition && u === l.hip && h.matrix.setPosition(t.set(0, h.position.y, 0)), h.matrix.decompose(h.position, h.quaternion, h.scale), h.updateMatrixWorld()
                        }
                        if (l.preservePosition)
                            for (m = 0; m < g.length; ++m) h = g[m], (u = l.names[h.name] || h.name) !== l.hip && h.position.copy(p[m]);
                        l.preserveMatrix && o.updateMatrixWorld(!0)
                    }
                }(),
                retargetClip: function(t, e, n, i) {
                    (i = i || {}).useFirstFramePosition = void 0 !== i.useFirstFramePosition && i.useFirstFramePosition, i.fps = void 0 !== i.fps ? i.fps : 30, i.names = i.names || [], e.isObject3D || (e = this.getHelperFromSkeleton(e));
                    var r, s, o, a, l, c, h = Math.round(n.duration * (i.fps / 1e3) * 1e3),
                        u = 1 / i.fps,
                        d = [],
                        p = new pu(e),
                        m = this.getBones(t.skeleton),
                        f = [];
                    for (p.clipAction(n).play(), p.update(0), e.updateMatrixWorld(), l = 0; l < h; ++l) {
                        var g = l * u;
                        for (this.retarget(t, e, i), c = 0; c < m.length; ++c) a = i.names[m[c].name] || m[c].name, this.getBoneByName(a, e.skeleton) && (s = m[c], o = f[c] = f[c] || {
                            bone: s
                        }, i.hip === a && (o.pos || (o.pos = {
                            times: new Float32Array(h),
                            values: new Float32Array(3 * h)
                        }), i.useFirstFramePosition && (0 === l && (r = s.position.clone()), s.position.sub(r)), o.pos.times[l] = g, s.position.toArray(o.pos.values, 3 * l)), o.quat || (o.quat = {
                            times: new Float32Array(h),
                            values: new Float32Array(4 * h)
                        }), o.quat.times[l] = g, s.quaternion.toArray(o.quat.values, 4 * l));
                        p.update(u), e.updateMatrixWorld()
                    }
                    for (l = 0; l < f.length; ++l)(o = f[l]) && (o.pos && d.push(new Bc(".bones[" + o.bone.name + "].position", o.pos.times, o.pos.values)), d.push(new zc(".bones[" + o.bone.name + "].quaternion", o.quat.times, o.quat.values)));
                    return p.uncacheAction(n), new Hc(n.name, -1, d)
                },
                getHelperFromSkeleton: function(t) {
                    var e = new Eu(t.bones[0]);
                    return e.skeleton = t, e
                },
                getSkeletonOffsets: function() {
                    var t = new Hn,
                        e = new Hn,
                        n = new Hn,
                        i = new Hn,
                        r = new Cn,
                        s = new Cn;
                    return function(o, a, l) {
                        (l = l || {}).hip = void 0 !== l.hip ? l.hip : "hip", l.names = l.names || {}, a.isObject3D || (a = this.getHelperFromSkeleton(a));
                        var c, h, u, d, p = Object.keys(l.names),
                            m = Object.values(l.names),
                            f = a.isObject3D ? a.skeleton.bones : this.getBones(a),
                            g = o.isObject3D ? o.skeleton.bones : this.getBones(o),
                            v = [];
                        for (o.skeleton.pose(), d = 0; d < g.length; ++d)
                            if (c = g[d], u = l.names[c.name] || c.name, (h = this.getBoneByName(u, f)) && u !== l.hip) {
                                var y = this.getNearestBone(c.parent, p),
                                    x = this.getNearestBone(h.parent, m);
                                y.updateMatrixWorld(), x.updateMatrixWorld(), t.setFromMatrixPosition(y.matrixWorld), e.setFromMatrixPosition(c.matrixWorld), n.setFromMatrixPosition(x.matrixWorld), i.setFromMatrixPosition(h.matrixWorld), r.subVectors(new Cn(e.x, e.y), new Cn(t.x, t.y)).normalize(), s.subVectors(new Cn(i.x, i.y), new Cn(n.x, n.y)).normalize();
                                var b = r.angle() - s.angle(),
                                    _ = (new fi).makeRotationFromEuler(new Mi(0, 0, b));
                                c.matrix.multiply(_), c.matrix.decompose(c.position, c.quaternion, c.scale), c.updateMatrixWorld(), v[u] = _
                            }
                        return v
                    }
                }(),
                renameBones: function(t, e) {
                    for (var n = this.getBones(t), i = 0; i < n.length; ++i) {
                        var r = n[i];
                        e[r.name] && (r.name = e[r.name])
                    }
                    return this
                },
                getBones: function(t) {
                    return Array.isArray(t) ? t : t.bones
                },
                getBoneByName: function(t, e) {
                    for (var n = 0, i = this.getBones(e); n < i.length; n++)
                        if (t === i[n].name) return i[n]
                },
                getNearestBone: function(t, e) {
                    for (; t.isBone;) {
                        if (-1 !== e.indexOf(t.name)) return t;
                        t = t.parent
                    }
                },
                findBoneTrackData: function(t, e) {
                    for (var n = /\[(.*)\]\.(.*)/, i = {
                            name: t
                        }, r = 0; r < e.length; ++r) {
                        var s = n.exec(e[r].name);
                        s && t === s[1] && (i[s[2]] = r)
                    }
                    return i
                },
                getEqualsBonesNames: function(t, e) {
                    var n = this.getBones(t),
                        i = this.getBones(e),
                        r = [];
                    t: for (var s = 0; s < n.length; s++)
                        for (var o = n[s].name, a = 0; a < i.length; a++)
                            if (o === i[a].name) {
                                r.push(o);
                                continue t
                            }
                    return r
                },
                clone: function(t) {
                    var e = new Map,
                        n = new Map,
                        i = t.clone();
                    return function t(e, n, i) {
                        i(e, n);
                        for (var r = 0; r < e.children.length; r++) t(e.children[r], n.children[r], i)
                    }(t, i, (function(t, i) {
                        e.set(i, t), n.set(t, i)
                    })), i.traverse((function(t) {
                        if (t.isSkinnedMesh) {
                            var i = t,
                                r = e.get(t),
                                s = r.skeleton.bones;
                            i.skeleton = r.skeleton.clone(), i.bindMatrix.copy(r.bindMatrix), i.skeleton.bones = s.map((function(t) {
                                return n.get(t)
                            })), i.bind(i.skeleton, i.bindMatrix)
                        }
                    })), i
                }
            };
            const Rf = Symbol("prepared"),
                Pf = Symbol("prepare"),
                Cf = Symbol("preparedGLTF"),
                Of = Symbol("clone");
            class If {
                constructor(t) {
                    this[Cf] = t
                }
                static prepare(t) {
                    if (null == t.scene) throw new Error("Model does not have a scene");
                    if (t[Rf]) return t;
                    const e = this[Pf](t);
                    return e[Rf] = !0, e
                }
                static[Pf](t) {
                    const {
                        scene: e
                    } = t, n = [e];
                    return Object.assign(Object.assign({}, t), {
                        scene: e,
                        scenes: n
                    })
                }
                get parser() {
                    return this[Cf].parser
                }
                get animations() {
                    return this[Cf].animations
                }
                get scene() {
                    return this[Cf].scene
                }
                get scenes() {
                    return this[Cf].scenes
                }
                get cameras() {
                    return this[Cf].cameras
                }
                get asset() {
                    return this[Cf].asset
                }
                get userData() {
                    return this[Cf].userData
                }
                clone() {
                    return new(0, this.constructor)(this[Of]())
                }
                dispose() {
                    this.scenes.forEach(t => {
                        t.traverse(t => {
                            if (!t.isMesh) return;
                            const e = t;
                            (Array.isArray(e.material) ? e.material : [e.material]).forEach(t => {
                                t.dispose()
                            }), e.geometry.dispose()
                        })
                    })
                }[Of]() {
                    const t = this[Cf],
                        e = Lf.clone(this.scene),
                        n = [e],
                        i = t.userData ? Object.assign({}, t.userData) : {};
                    return Object.assign(Object.assign({}, t), {
                        scene: e,
                        scenes: n,
                        userData: i
                    })
                }
            }
            const Nf = "\n#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n    diffuseColor.a = 1.0;\n\n#endif\n",
                Df = Symbol("cloneAndPatchMaterial"),
                Ff = Symbol("correlatedSceneGraph");
            class Uf extends If {
                static[Pf](t) {
                    const e = super[Pf](t);
                    null == e[Ff] && (e[Ff] = Af.from(e));
                    const {
                        scene: n
                    } = e, i = [];
                    n.traverse(t => {
                        if (t.renderOrder = 1e3, t.frustumCulled = !1, t.name || (t.name = t.uuid), !t.isMesh) return;
                        t.castShadow = !0;
                        const e = t;
                        let n = !1;
                        (Array.isArray(e.material) ? e.material : [e.material]).forEach(t => {
                            t.isMeshStandardMaterial && (t.transparent && t.side === H && (n = !0, t.side = k), ig.singleton.roughnessMipmapper.generateMipmaps(t))
                        }), n && i.push(e)
                    });
                    for (const r of i) {
                        const t = (Array.isArray(r.material) ? r.material : [r.material]).map(t => {
                                const e = t.clone();
                                return e.side = B, e
                            }),
                            e = Array.isArray(r.material) ? t : t[0],
                            n = new $r(r.geometry, e);
                        n.renderOrder = -1, r.add(n)
                    }
                    return e
                }
                get correlatedSceneGraph() {
                    return this[Cf][Ff]
                }[Of]() {
                    const t = super[Of](),
                        e = new Map;
                    return t.scene.traverse(t => {
                        if (t.isMesh) {
                            const n = t;
                            Array.isArray(n.material) ? n.material = n.material.map(t => this[Df](t, e)) : null != n.material && (n.material = this[Df](n.material, e))
                        }
                    }), t[Ff] = Af.from(t, this.correlatedSceneGraph), t
                }[Df](t, e) {
                    if (e.has(t.uuid)) return e.get(t.uuid);
                    const n = t.clone(),
                        i = t.onBeforeCompile;
                    return n.onBeforeCompile = t.isGLTFSpecularGlossinessMaterial ? t => {
                        i(t, void 0), t.fragmentShader = t.fragmentShader.replace("#include <alphatest_fragment>", Nf)
                    } : t => {
                        t.fragmentShader = t.fragmentShader.replace("#include <alphatest_fragment>", Nf), i(t, void 0)
                    }, n.shadowSide = k, n.transparent && (n.depthWrite = !1), n.alphaTest || n.transparent || (n.alphaTest = -.5), e.set(t.uuid, n), n
                }
            }
            var zf = function(t) {
                $c.call(this, t), this.type = Gt
            };
            zf.prototype = Object.assign(Object.create($c.prototype), {
                constructor: zf,
                parse: function(t) {
                    var e = function(t, e) {
                            switch (t) {
                                case 1:
                                    console.error("RGBELoader Read Error: " + (e || ""));
                                    break;
                                case 2:
                                    console.error("RGBELoader Write Error: " + (e || ""));
                                    break;
                                case 3:
                                    console.error("RGBELoader Bad File Format: " + (e || ""));
                                    break;
                                default:
                                case 4:
                                    console.error("RGBELoader: Error: " + (e || ""))
                            }
                            return -1
                        },
                        n = function(t, e, n) {
                            e = e || 1024;
                            for (var i = t.pos, r = -1, s = 0, o = "", a = String.fromCharCode.apply(null, new Uint16Array(t.subarray(i, i + 128))); 0 > (r = a.indexOf("\n")) && s < e && i < t.byteLength;) o += a, s += a.length, i += 128, a += String.fromCharCode.apply(null, new Uint16Array(t.subarray(i, i + 128)));
                            return -1 < r && (!1 !== n && (t.pos += s + r + 1), o + a.slice(0, r))
                        },
                        i = function(t, e, n, i) {
                            var r = t[e + 3],
                                s = Math.pow(2, r - 128) / 255;
                            n[i + 0] = t[e + 0] * s, n[i + 1] = t[e + 1] * s, n[i + 2] = t[e + 2] * s
                        },
                        r = function() {
                            var t = new Float32Array(1),
                                e = new Int32Array(t.buffer);

                            function n(n) {
                                t[0] = n;
                                var i = e[0],
                                    r = i >> 16 & 32768,
                                    s = i >> 12 & 2047,
                                    o = i >> 23 & 255;
                                return o < 103 ? r : o > 142 ? (r |= 31744, r |= (255 == o ? 0 : 1) && 8388607 & i) : o < 113 ? r |= ((s |= 2048) >> 114 - o) + (s >> 113 - o & 1) : (r |= o - 112 << 10 | s >> 1, r += 1 & s)
                            }
                            return function(t, e, i, r) {
                                var s = t[e + 3],
                                    o = Math.pow(2, s - 128) / 255;
                                i[r + 0] = n(t[e + 0] * o), i[r + 1] = n(t[e + 1] * o), i[r + 2] = n(t[e + 2] * o)
                            }
                        }(),
                        s = new Uint8Array(t);
                    s.pos = 0;
                    var o = function(t) {
                        var i, r, s = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                            o = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                            a = /^\s*FORMAT=(\S+)\s*$/,
                            l = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                            c = {
                                valid: 0,
                                string: "",
                                comments: "",
                                programtype: "RGBE",
                                format: "",
                                gamma: 1,
                                exposure: 1,
                                width: 0,
                                height: 0
                            };
                        if (t.pos >= t.byteLength || !(i = n(t))) return e(1, "no header found");
                        if (!(r = i.match(/^#\?(\S+)$/))) return e(3, "bad initial token");
                        for (c.valid |= 1, c.programtype = r[1], c.string += i + "\n"; !1 !== (i = n(t));)
                            if (c.string += i + "\n", "#" !== i.charAt(0)) {
                                if ((r = i.match(s)) && (c.gamma = parseFloat(r[1], 10)), (r = i.match(o)) && (c.exposure = parseFloat(r[1], 10)), (r = i.match(a)) && (c.valid |= 2, c.format = r[1]), (r = i.match(l)) && (c.valid |= 4, c.height = parseInt(r[1], 10), c.width = parseInt(r[2], 10)), 2 & c.valid && 4 & c.valid) break
                            } else c.comments += i + "\n";
                        return 2 & c.valid ? 4 & c.valid ? c : e(3, "missing image size specifier") : e(3, "missing format specifier")
                    }(s);
                    if (-1 !== o) {
                        var a = o.width,
                            l = o.height,
                            c = function(t, n, i) {
                                var r, s, o, a, l, c, h, u, d, p, m, f, g, v = n,
                                    y = i;
                                if (v < 8 || v > 32767 || 2 !== t[0] || 2 !== t[1] || 128 & t[2]) return new Uint8Array(t);
                                if (v !== (t[2] << 8 | t[3])) return e(3, "wrong scanline width");
                                if (!(r = new Uint8Array(4 * n * i)).length) return e(4, "unable to allocate buffer space");
                                for (s = 0, o = 0, u = 4 * v, g = new Uint8Array(4), c = new Uint8Array(u); y > 0 && o < t.byteLength;) {
                                    if (o + 4 > t.byteLength) return e(1);
                                    if (g[0] = t[o++], g[1] = t[o++], g[2] = t[o++], g[3] = t[o++], 2 != g[0] || 2 != g[1] || (g[2] << 8 | g[3]) != v) return e(3, "bad rgbe scanline format");
                                    for (h = 0; h < u && o < t.byteLength;) {
                                        if ((f = (a = t[o++]) > 128) && (a -= 128), 0 === a || h + a > u) return e(3, "bad scanline data");
                                        if (f)
                                            for (l = t[o++], d = 0; d < a; d++) c[h++] = l;
                                        else c.set(t.subarray(o, o + a), h), h += a, o += a
                                    }
                                    for (p = v, d = 0; d < p; d++) m = 0, r[s] = c[d + m], m += v, r[s + 1] = c[d + m], m += v, r[s + 2] = c[d + m], m += v, r[s + 3] = c[d + m], s += 4;
                                    y--
                                }
                                return r
                            }(s.subarray(s.pos), a, l);
                        if (-1 !== c) {
                            switch (this.type) {
                                case Gt:
                                    var h = c,
                                        u = se,
                                        d = Gt;
                                    break;
                                case Yt:
                                    for (var p = c.length / 4 * 3, m = new Float32Array(p), f = 0; f < p; f++) i(c, 4 * f, m, 3 * f);
                                    h = m, u = ee, d = Yt;
                                    break;
                                case Jt:
                                    p = c.length / 4 * 3;
                                    var g = new Uint16Array(p);
                                    for (f = 0; f < p; f++) r(c, 4 * f, g, 3 * f);
                                    h = g, u = ee, d = Jt;
                                    break;
                                default:
                                    console.error("THREE.RGBELoader: unsupported type: ", this.type)
                            }
                            return {
                                width: a,
                                height: l,
                                data: h,
                                header: o.string,
                                gamma: o.gamma,
                                exposure: o.exposure,
                                format: u,
                                type: d
                            }
                        }
                    }
                    return null
                },
                setDataType: function(t) {
                    return this.type = t, this
                },
                load: function(t, e, n, i) {
                    return $c.prototype.load.call(this, t, (function(t, n) {
                        switch (t.type) {
                            case Gt:
                                t.encoding = mn, t.minFilter = Ft, t.magFilter = Ft, t.generateMipmaps = !1, t.flipY = !0;
                                break;
                            case Yt:
                            case Jt:
                                t.encoding = un, t.minFilter = kt, t.magFilter = kt, t.generateMipmaps = !1, t.flipY = !0
                        }
                        e && e(t, n)
                    }), n, i)
                }
            });
            class kf extends Pa {
                constructor() {
                    super(), this.position.y = -3.5;
                    const t = new es;
                    t.deleteAttribute("uv");
                    const e = new xc({
                            metalness: 0,
                            side: B
                        }),
                        n = new xc({
                            metalness: 0
                        }),
                        i = new Rh(16777215, 500, 28, 2);
                    i.position.set(.418, 16.199, .3), this.add(i);
                    const r = new $r(t, e);
                    r.position.set(-.757, 13.219, .717), r.scale.set(31.713, 28.305, 28.591), this.add(r);
                    const s = new $r(t, n);
                    s.position.set(-10.906, 2.009, 1.846), s.rotation.set(0, -.195, 0), s.scale.set(2.328, 7.905, 4.651), this.add(s);
                    const o = new $r(t, n);
                    o.position.set(-5.607, -.754, -.758), o.rotation.set(0, .994, 0), o.scale.set(1.97, 1.534, 3.955), this.add(o);
                    const a = new $r(t, n);
                    a.position.set(6.167, .857, 7.803), a.rotation.set(0, .561, 0), a.scale.set(3.927, 6.285, 3.687), this.add(a);
                    const l = new $r(t, n);
                    l.position.set(-2.017, .018, 6.124), l.rotation.set(0, .333, 0), l.scale.set(2.002, 4.566, 2.064), this.add(l);
                    const c = new $r(t, n);
                    c.position.set(2.291, -.756, -2.621), c.rotation.set(0, -.286, 0), c.scale.set(1.546, 1.552, 1.496), this.add(c);
                    const h = new $r(t, n);
                    h.position.set(-2.193, -.369, -5.547), h.rotation.set(0, .516, 0), h.scale.set(3.875, 3.487, 2.986), this.add(h);
                    const u = new $r(t, this.createAreaLightMaterial(50));
                    u.position.set(-16.116, 14.37, 8.208), u.scale.set(.1, 2.428, 2.739), this.add(u);
                    const d = new $r(t, this.createAreaLightMaterial(50));
                    d.position.set(-16.109, 18.021, -8.207), d.scale.set(.1, 2.425, 2.751), this.add(d);
                    const p = new $r(t, this.createAreaLightMaterial(17));
                    p.position.set(14.904, 12.198, -1.832), p.scale.set(.15, 4.265, 6.331), this.add(p);
                    const m = new $r(t, this.createAreaLightMaterial(43));
                    m.position.set(-.462, 8.89, 14.52), m.scale.set(4.38, 5.441, .088), this.add(m);
                    const f = new $r(t, this.createAreaLightMaterial(20));
                    f.position.set(3.235, 11.486, -12.541), f.scale.set(2.5, 2, .1), this.add(f);
                    const g = new $r(t, this.createAreaLightMaterial(100));
                    g.position.set(0, 20, 0), g.scale.set(1, .1, 1), this.add(g)
                }
                createAreaLightMaterial(t) {
                    const e = new dr;
                    return e.color.setScalar(t), e
                }
            }
            const Bf = .04;
            Vc.enabled = !0;
            const Hf = /\.hdr(\.js)?$/,
                Gf = new Qc,
                Vf = new zf,
                jf = {
                    url: null
                };
            class Wf extends An {
                constructor(t) {
                    super(), this.generatedEnvironmentMap = null, this.skyboxCache = new Map, this.environmentMapCache = new Map, this.PMREMGenerator = new Gu(t)
                }
                async load(t, e = (() => {})) {
                    try {
                        const n = Hf.test(t),
                            i = n ? Vf : Gf,
                            r = await new Promise((n, r) => i.load(t, n, t => {
                                e(t.loaded / t.total * .9)
                            }, r));
                        return e(1), this.addMetadata(r, t), r.mapping = Rt, n ? (r.encoding = mn, r.minFilter = Ft, r.magFilter = Ft, r.flipY = !0) : r.encoding = pn, r
                    } finally {
                        e && e(1)
                    }
                }
                async generateEnvironmentMapAndSkybox(t = null, e = null, n = {}) {
                    const {
                        progressTracker: i
                    } = n, r = null != i ? i.beginActivity() : () => {};
                    try {
                        let n, s = Promise.resolve(null);
                        t && (s = this.loadSkyboxFromUrl(t, i)), n = e ? this.loadEnvironmentMapFromUrl(e, i) : t ? this.loadEnvironmentMapFromUrl(t, i) : this.loadGeneratedEnvironmentMap();
                        let [o, a] = await Promise.all([n, s]);
                        if (null == o) throw new Error("Failed to load environment map.");
                        return {
                            environmentMap: o,
                            skybox: a
                        }
                    } finally {
                        r(1)
                    }
                }
                addMetadata(t, e) {
                    null != t && (t.userData = Object.assign(Object.assign({}, jf), {
                        url: e
                    }))
                }
                loadSkyboxFromUrl(t, e) {
                    if (!this.skyboxCache.has(t)) {
                        const n = e ? e.beginActivity() : () => {},
                            i = this.load(t, n);
                        this.skyboxCache.set(t, i)
                    }
                    return this.skyboxCache.get(t)
                }
                loadEnvironmentMapFromUrl(t, e) {
                    if (!this.environmentMapCache.has(t)) {
                        const n = this.loadSkyboxFromUrl(t, e).then(e => {
                            const n = this.PMREMGenerator.fromEquirectangular(e);
                            return this.addMetadata(n.texture, t), n
                        });
                        this.PMREMGenerator.compileEquirectangularShader(), this.environmentMapCache.set(t, n)
                    }
                    return this.environmentMapCache.get(t)
                }
                loadGeneratedEnvironmentMap() {
                    if (null == this.generatedEnvironmentMap) {
                        const t = new kf;
                        this.generatedEnvironmentMap = this.PMREMGenerator.fromScene(t, Bf), this.addMetadata(this.generatedEnvironmentMap.texture, null)
                    }
                    return Promise.resolve(this.generatedEnvironmentMap)
                }
                async dispose() {
                    const t = [];
                    this.environmentMapCache.forEach(e => {
                        t.push(e)
                    }), this.environmentMapCache.clear();
                    for (const n of t) try {
                        (await n).dispose()
                    } catch (e) {}
                    null != this.generatedEnvironmentMap && (this.generatedEnvironmentMap.dispose(), this.generatedEnvironmentMap = null)
                }
            }
            var qf, Xf;
            const Yf = .2,
                Jf = 18,
                Zf = 26,
                Kf = 2,
                $f = .79,
                Qf = .5,
                tg = Symbol("onWebGLContextLost"),
                eg = Symbol("webGLContextLostHandler"),
                ng = Symbol("singleton");
            class ig extends An {
                constructor(t) {
                    super(), this.loader = new vd(Uf), this.width = 0, this.height = 0, this.dpr = 1, this.minScale = Qf, this.debugger = null, this.scenes = new Set, this.multipleScenesVisible = !1, this.scale = 1, this.avgFrameDuration = (Zf + Jf) / 2, this[Xf] = t => this[tg](t), this.dpr = _p(), this.canvasElement = document.createElement("canvas"), this.canvasElement.id = "webgl-canvas", this.canvas3D = this.canvasElement, this.canvas3D.addEventListener("webglcontextlost", this[eg]);
                    try {
                        this.threeRenderer = new Ra({
                            canvas: this.canvas3D,
                            alpha: !0,
                            antialias: !0,
                            powerPreference: "high-performance",
                            preserveDrawingBuffer: !0
                        }), this.threeRenderer.autoClear = !0, this.threeRenderer.outputEncoding = pn, this.threeRenderer.gammaFactor = 2.2, this.threeRenderer.physicallyCorrectLights = !0, this.threeRenderer.setPixelRatio(1), this.threeRenderer.shadowMap.enabled = !0, this.threeRenderer.shadowMap.type = U, this.threeRenderer.shadowMap.autoUpdate = !1, this.debugger = null != t && t.debug ? new xf(this) : null, this.threeRenderer.debug = {
                            checkShaderErrors: !!this.debugger
                        }, this.threeRenderer.toneMapping = Tt
                    } catch (e) {
                        console.warn(e)
                    }
                    this.arRenderer = new yf(this), this.textureUtils = this.canRender ? new Wf(this.threeRenderer) : null, this.roughnessMipmapper = new mp(this.threeRenderer), this.updateRendererSize(), this.lastTick = performance.now(), this.avgFrameDuration = 0
                }
                static get singleton() {
                    return this[ng]
                }
                static resetSingleton() {
                    this[ng].dispose(), this[ng] = new ig({
                        debug: wp()
                    })
                }
                get canRender() {
                    return null != this.threeRenderer
                }
                get scaleFactor() {
                    return this.scale
                }
                updateRendererSize() {
                    const t = _p();
                    if (t !== this.dpr)
                        for (const s of this.scenes) {
                            const {
                                element: t
                            } = s;
                            t[kg](t.getBoundingClientRect())
                        }
                    let e = 0,
                        n = 0;
                    for (const s of this.scenes) e = Math.max(e, s.width), n = Math.max(n, s.height);
                    if (e === this.width && n === this.height && t === this.dpr) return;
                    this.width = e, this.height = n, this.dpr = t, this.canRender && this.threeRenderer.setSize(e * t, n * t, !1);
                    const i = e / this.scale,
                        r = n / this.scale;
                    this.canvasElement.style.width = `${i}px`, this.canvasElement.style.height = `${r}px`;
                    for (const s of this.scenes) {
                        const {
                            canvas: o
                        } = s;
                        o.width = Math.round(e * t), o.height = Math.round(n * t), o.style.width = `${i}px`, o.style.height = `${r}px`, s.isDirty = !0
                    }
                }
                updateRendererScale() {
                    let {
                        scale: t
                    } = this;
                    if (this.avgFrameDuration > Zf && t > this.minScale ? t *= $f : this.avgFrameDuration < Jf && t < 1 && (t /= $f, t = Math.min(t, 1)), t = Math.max(t, this.minScale), t == this.scale) return;
                    this.scale = t, this.avgFrameDuration = (Zf + Jf) / 2;
                    const e = this.width / t,
                        n = this.height / t;
                    this.canvasElement.style.width = `${e}px`, this.canvasElement.style.height = `${n}px`;
                    for (const i of this.scenes) {
                        const {
                            style: t
                        } = i.canvas;
                        t.width = `${e}px`, t.height = `${n}px`, i.isDirty = !0
                    }
                }
                registerScene(t) {
                    this.scenes.add(t);
                    const {
                        canvas: e
                    } = t;
                    e.width = Math.round(this.width * this.dpr), e.height = Math.round(this.height * this.dpr), e.style.width = `${this.width/this.scale}px`, e.style.height = `${this.height/this.scale}px`, this.multipleScenesVisible && e.classList.add("show"), t.isDirty = !0, this.canRender && this.scenes.size > 0 && this.threeRenderer.setAnimationLoop(t => this.render(t)), null != this.debugger && this.debugger.addScene(t)
                }
                unregisterScene(t) {
                    this.scenes.delete(t), this.canRender && 0 === this.scenes.size && this.threeRenderer.setAnimationLoop(null), null != this.debugger && this.debugger.removeScene(t)
                }
                displayCanvas(t) {
                    return this.multipleScenesVisible ? t.element[Yg] : this.canvasElement
                }
                selectCanvas() {
                    let t = 0,
                        e = null;
                    for (const r of this.scenes) {
                        const {
                            element: n
                        } = r;
                        n.modelIsVisible && (++t, e = n[Xg])
                    }
                    const n = t > 1 || _,
                        {
                            canvasElement: i
                        } = this;
                    if (n !== this.multipleScenesVisible || !n && i.parentElement !== e) {
                        this.multipleScenesVisible = n, n && i.classList.remove("show");
                        for (const t of this.scenes) {
                            const r = t.element[Xg],
                                s = t.element[Yg];
                            n ? (s.classList.add("show"), t.isDirty = !0) : r === e && (r.appendChild(i), i.classList.add("show"), s.classList.remove("show"), t.isDirty = !0)
                        }
                    }
                }
                orderedScenes() {
                    const t = [];
                    for (const e of [!1, !0])
                        for (const n of this.scenes) n.element.modelIsVisible === e && t.push(n);
                    return t
                }
                get isPresenting() {
                    return this.arRenderer.isPresenting
                }
                preRender(t, e, n) {
                    const {
                        element: i,
                        exposure: r,
                        model: s
                    } = t;
                    i[Kg](e, n);
                    const o = "number" === typeof r && !self.isNaN(r);
                    this.threeRenderer.toneMappingExposure = o ? r : 1, s.updateShadow() && (this.threeRenderer.shadowMap.needsUpdate = !0)
                }
                render(t) {
                    const e = t - this.lastTick;
                    if (this.lastTick = t, !this.canRender || this.isPresenting) return;
                    this.avgFrameDuration += bp(Yf * (e - this.avgFrameDuration), -Kf, Kf), this.selectCanvas(), this.updateRendererSize(), this.updateRendererScale();
                    const {
                        dpr: n,
                        scale: i
                    } = this;
                    for (const r of this.orderedScenes()) {
                        if (!r.element[sv]()) continue;
                        if (this.preRender(r, t, e), !r.isDirty) continue;
                        if (r.isDirty = !1, !r.element.modelIsVisible && !this.multipleScenesVisible)
                            for (const t of this.scenes) t.element.modelIsVisible && (t.isDirty = !0);
                        const s = Math.min(Math.ceil(r.width * i * n), this.canvas3D.width),
                            o = Math.min(Math.ceil(r.height * i * n), this.canvas3D.height);
                        if (this.threeRenderer.setRenderTarget(null), this.threeRenderer.setViewport(0, Math.floor(this.height * n) - o, s, o), this.threeRenderer.render(r, r.getCamera()), this.multipleScenesVisible) {
                            null == r.context && r.createContext(); {
                                const t = r.context;
                                t.clearRect(0, 0, s, o), t.drawImage(this.canvas3D, 0, 0, s, o, 0, 0, s, o)
                            }
                        }
                    }
                }
                dispose() {
                    null != this.textureUtils && this.textureUtils.dispose(), null != this.threeRenderer && this.threeRenderer.dispose(), this.textureUtils = null, this.threeRenderer = null, this.scenes.clear(), this.canvas3D.removeEventListener("webglcontextlost", this[eg])
                }[(qf = ng, Xf = eg, tg)](t) {
                    this.dispatchEvent({
                        type: "contextlost",
                        sourceEvent: t
                    })
                }
            }
            ig[qf] = new ig({
                debug: wp()
            });
            const rg = async t => new Promise((e, n) => {
                const i = t.match(/data:(.*);/);
                if (!i) return n(new Error(`${t} is not a valid data Url`));
                const r = i[1],
                    s = t.replace(/data:image\/\w+;base64,/, ""),
                    o = atob(s),
                    a = [];
                for (let t = 0; t < o.length; t += 512) {
                    const e = o.slice(t, t + 512),
                        n = new Array(e.length);
                    for (let t = 0; t < e.length; t++) n[t] = e.charCodeAt(t);
                    const i = new Uint8Array(n);
                    a.push(i)
                }
                e(new Blob(a, {
                    type: r
                }))
            });
            var sg, og;
            const ag = Symbol("ongoingActivities"),
                lg = Symbol("announceTotalProgress"),
                cg = Symbol("eventDelegate"),
                hg = .5;
            class ug {
                constructor() {
                    this[sg] = document.createDocumentFragment(), this.addEventListener = (...t) => this[cg].addEventListener(...t), this.removeEventListener = (...t) => this[cg].removeEventListener(...t), this.dispatchEvent = (...t) => this[cg].dispatchEvent(...t), this[og] = new Set
                }
                get ongoingActivityCount() {
                    return this[ag].size
                }
                beginActivity() {
                    const t = {
                        progress: 0
                    };
                    return this[ag].add(t), 1 === this.ongoingActivityCount && this[lg](), e => {
                        let n;
                        return n = Math.max(bp(e, 0, 1), t.progress), n !== t.progress && (t.progress = n, this[lg]()), t.progress
                    }
                }[(sg = cg, og = ag, lg)]() {
                    let t = 0,
                        e = 0,
                        n = 0;
                    for (const i of this[ag]) {
                        const {
                            progress: r
                        } = i;
                        t += r * (hg / Math.pow(2, e++)), 1 === r && n++
                    }
                    n === this.ongoingActivityCount && (t = 1, this[ag].clear()), this.dispatchEvent(new CustomEvent("progress", {
                        detail: {
                            totalProgress: t
                        }
                    }))
                }
            }
            var dg, pg, mg, fg, gg, vg, yg, xg, bg, _g, wg = function(t, e, n, i) {
                for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)(r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
                return s > 3 && o && Object.defineProperty(e, n, o), o
            };
            const Mg = 1e3,
                Sg = 50,
                Tg = 0,
                Eg = 300,
                Ag = 150,
                Lg = document.createElement("canvas");
            let Rg = null;
            const Pg = Symbol("template"),
                Cg = Symbol("fallbackResizeHandler"),
                Og = Symbol("defaultAriaLabel"),
                Ig = Symbol("resizeObserver"),
                Ng = Symbol("intersectionObserver"),
                Dg = Symbol("clearModelTimeout"),
                Fg = Symbol("onContextLost"),
                Ug = Symbol("contextLostHandler"),
                zg = Symbol("loaded"),
                kg = Symbol("updateSize"),
                Bg = Symbol("isElementInViewport"),
                Hg = Symbol("announceModelVisibility"),
                Gg = Symbol("ariaLabel"),
                Vg = Symbol("loadedTime"),
                jg = Symbol("updateSource"),
                Wg = Symbol("markLoaded"),
                qg = Symbol("container"),
                Xg = Symbol("input"),
                Yg = Symbol("canvas"),
                Jg = Symbol("scene"),
                Zg = Symbol("needsRender"),
                Kg = Symbol("tick"),
                $g = Symbol("onModelLoad"),
                Qg = Symbol("onResize"),
                tv = Symbol("renderer"),
                ev = Symbol("progressTracker"),
                nv = Symbol("getLoaded"),
                iv = Symbol("getModelIsVisible"),
                rv = Symbol("shouldAttemptPreload"),
                sv = Symbol("sceneIsReady"),
                ov = Symbol("hasTransitioned"),
                av = t => ({
                    x: t.x,
                    y: t.y,
                    z: t.z,
                    toString() {
                        return `${this.x}m ${this.y}m ${this.z}m`
                    }
                });
            class lv extends d {
                constructor() {
                    super(), this.alt = null, this.src = null, this[dg] = !1, this[pg] = !1, this[mg] = 0, this[fg] = null, this[gg] = xp(() => {
                        const t = this.getBoundingClientRect();
                        this[kg](t)
                    }, Sg), this[vg] = xp(t => {
                        const e = this.modelIsVisible;
                        e !== t && this.dispatchEvent(new CustomEvent("model-visibility", {
                            detail: {
                                visible: e
                            }
                        }))
                    }, Tg), this[yg] = null, this[xg] = null, this[bg] = new ug, this[_g] = t => this[Fg](t);
                    const t = this.constructor.template;
                    window.ShadyCSS && window.ShadyCSS.styleElement(this, {}), this.attachShadow({
                        mode: "open"
                    });
                    const e = this.shadowRoot;
                    let n, i;
                    if (e.appendChild(t.content.cloneNode(!0)), this[qg] = e.querySelector(".container"), this[Xg] = e.querySelector(".userInput"), this[Yg] = e.querySelector("canvas"), this[Og] = this[Xg].getAttribute("aria-label"), this.isConnected) {
                        const t = this.getBoundingClientRect();
                        n = t.width, i = t.height
                    } else n = Eg, i = Ag;
                    this[Jg] = new lp({
                        canvas: this[Yg],
                        element: this,
                        width: n,
                        height: i
                    }), this[Jg].addEventListener("model-load", t => {
                        this[Wg](), this[$g](), this.dispatchEvent(new CustomEvent("load", {
                            detail: {
                                url: t.url
                            }
                        }))
                    }), Promise.resolve().then(() => {
                        this[kg](this.getBoundingClientRect())
                    }), y && (this[Ig] = new ResizeObserver(t => {
                        if (!this[tv].isPresenting)
                            for (let e of t) e.target === this && this[kg](e.contentRect)
                    })), x ? this[Ng] = new IntersectionObserver(t => {
                        for (let e of t)
                            if (e.target === this) {
                                const t = this.modelIsVisible;
                                this[Bg] = e.isIntersecting, this[Hg](t), this[Bg] && !this[sv]() && this[jg]()
                            }
                    }, {
                        root: null,
                        rootMargin: "0px",
                        threshold: 0
                    }) : this[Bg] = !0
                }
                static get is() {
                    return "model-viewer"
                }
                static get template() {
                    return this.hasOwnProperty(Pg) || (this[Pg] = O(this.is)), this[Pg]
                }
                static set modelCacheSize(t) {
                    vd[fd].evictionThreshold = t
                }
                static get modelCacheSize() {
                    return vd[fd].evictionThreshold
                }
                static set minimumRenderScale(t) {
                    t > 1 && console.warn("<model-viewer> minimumRenderScale has been clamped to a maximum value of 1."), t <= 0 && console.warn("<model-viewer> minimumRenderScale has been clamped to a minimum value of 0. This could result in single-pixel renders on some devices; consider increasing."), ig.singleton.minScale = Math.max(0, Math.min(1, t))
                }
                static get minimumRenderScale() {
                    return ig.singleton.minScale
                }
                get loaded() {
                    return this[nv]()
                }
                get[(dg = Bg, pg = zg, mg = Vg, fg = Dg, gg = Cg, vg = Hg, yg = Ig, xg = Ng, bg = ev, _g = Ug, tv)]() {
                    return ig.singleton
                }
                get modelIsVisible() {
                    return this[iv]()
                }
                connectedCallback() {
                    super.connectedCallback && super.connectedCallback(), y ? this[Ig].observe(this) : self.addEventListener("resize", this[Cg]), x && this[Ng].observe(this);
                    const t = this[tv];
                    t.addEventListener("contextlost", this[Ug]), t.registerScene(this[Jg]), null != this[Dg] && (self.clearTimeout(this[Dg]), this[Dg] = null, this.requestUpdate("src", null))
                }
                disconnectedCallback() {
                    super.disconnectedCallback && super.disconnectedCallback(), y ? this[Ig].unobserve(this) : self.removeEventListener("resize", this[Cg]), x && this[Ng].unobserve(this);
                    const t = this[tv];
                    t.removeEventListener("contextlost", this[Ug]), t.unregisterScene(this[Jg]), this[Dg] = self.setTimeout(() => {
                        this[Jg].model.clear()
                    }, Mg)
                }
                updated(t) {
                    if (super.updated(t), !t.has("src") || null != this.src && this.src === this[Jg].model.url || (this[zg] = !1, this[Vg] = 0, this[jg]()), t.has("alt")) {
                        const t = null == this.alt ? this[Og] : this.alt;
                        this[Xg].setAttribute("aria-label", t)
                    }
                }
                toDataURL(t, e) {
                    return this[tv].displayCanvas(this[Jg]).toDataURL(t, e)
                }
                async toBlob(t) {
                    const e = t ? t.mimeType : void 0,
                        n = t ? t.qualityArgument : void 0,
                        i = t ? t.idealAspect : void 0,
                        {
                            width: r,
                            height: s,
                            model: o,
                            aspect: a
                        } = this[Jg],
                        {
                            dpr: l,
                            scaleFactor: c
                        } = this[tv];
                    let h = r * c * l,
                        u = s * c * l,
                        d = 0,
                        p = 0;
                    if (!0 === i)
                        if (o.fieldOfViewAspect > a) {
                            const t = u;
                            u = Math.round(h / o.fieldOfViewAspect), p = (t - u) / 2
                        } else {
                            const t = h;
                            h = Math.round(u * o.fieldOfViewAspect), d = (t - h) / 2
                        }
                    Lg.width = h, Lg.height = u;
                    try {
                        return new Promise(async (t, i) => (null == Rg && (Rg = Lg.getContext("2d")), Rg.drawImage(this[tv].displayCanvas(this[Jg]), d, p, h, u, 0, 0, h, u), !Lg.msToBlob || e && "image/png" !== e ? Lg.toBlob ? void Lg.toBlob(e => {
                            if (!e) return i(new Error("Unable to retrieve canvas blob"));
                            t(e)
                        }, e, n) : t(await rg(Lg.toDataURL(e, n))) : t(Lg.msToBlob())))
                    } finally {
                        this[kg]({
                            width: r,
                            height: s
                        })
                    }
                }
                get[Gg]() {
                    return null == this.alt || "null" === this.alt ? this[Og] : this.alt
                }[nv]() {
                    return this[zg]
                }[iv]() {
                    return this.loaded && this[Bg]
                }[ov]() {
                    return this.modelIsVisible
                }[rv]() {
                    return !!this.src && this[Bg]
                }[sv]() {
                    return this[zg]
                }[kg]({
                    width: t,
                    height: e
                }) {
                    this[qg].style.width = `${t}px`, this[qg].style.height = `${e}px`, this[Qg]({
                        width: parseFloat(t),
                        height: parseFloat(e)
                    })
                }[Kg](t, e) {}[Wg]() {
                    this[zg] || (this[zg] = !0, this[Vg] = performance.now())
                }[Zg]() {
                    this[Jg].isDirty = !0
                }[$g]() {}[Qg](t) {
                    this[Jg].setSize(t.width, t.height)
                }[Fg](t) {
                    this.dispatchEvent(new CustomEvent("error", {
                        detail: {
                            type: "webglcontextlost",
                            sourceError: t.sourceEvent
                        }
                    }))
                }
                async [jg]() {
                    if (this.loaded || !this[rv]()) return;
                    const t = this[ev].beginActivity(),
                        e = this.src;
                    try {
                        await this[Jg].setModelSource(e, e => t(.8 * e));
                        const n = {
                            url: e
                        };
                        this.dispatchEvent(new CustomEvent("preload", {
                            detail: n
                        }))
                    } catch (n) {
                        this.dispatchEvent(new CustomEvent("error", {
                            detail: n
                        }))
                    } finally {
                        t(.9), requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                t(1)
                            })
                        })
                    }
                }
            }
            wg([f({
                type: String
            })], lv.prototype, "alt", void 0), wg([f({
                type: String
            })], lv.prototype, "src", void 0);
            var cv = function(t, e, n, i) {
                for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)(r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
                return s > 3 && o && Object.defineProperty(e, n, o), o
            };
            const hv = 1e3,
                uv = Symbol("changeAnimation"),
                dv = Symbol("paused"),
                pv = Symbol("annotationRenderer"),
                mv = Symbol("hotspotMap"),
                fv = Symbol("mutationCallback"),
                gv = Symbol("observer"),
                vv = Symbol("addHotspot"),
                yv = Symbol("removeHotspot"),
                xv = new Cn,
                bv = new fi,
                _v = new On,
                wv = t => e => {
                    try {
                        const n = Ad(e),
                            i = (n.length ? n[0].terms : []).filter(t => t && "ident" === t.type).map(t => t.value).filter(e => t.indexOf(e) > -1),
                            r = new Set;
                        for (const t of i) r.add(t);
                        return r
                    } catch (n) {}
                    return new Set
                };
            var Mv = function(t, e, n, i) {
                for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)(r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
                return s > 3 && o && Object.defineProperty(e, n, o), o
            };
            let Sv = !1,
                Tv = !1;
            const Ev = "#model-viewer-no-ar-fallback",
                Av = wv(["safari", "chrome"]),
                Lv = wv(["quick-look", "scene-viewer", "webxr", "none"]),
                Rv = "webxr scene-viewer quick-look",
                Pv = {
                    QUICK_LOOK: "quick-look",
                    SCENE_VIEWER: "scene-viewer",
                    WEBXR: "webxr",
                    NONE: "none"
                },
                Cv = Symbol("arButtonContainer"),
                Ov = Symbol("enterARWithWebXR"),
                Iv = Symbol("openSceneViewer"),
                Nv = Symbol("openIOSARQuickLook"),
                Dv = Symbol("canActivateAR"),
                Fv = Symbol("arMode"),
                Uv = Symbol("arModes"),
                zv = Symbol("canLaunchQuickLook"),
                kv = Symbol("quickLookBrowsers"),
                Bv = Symbol("arAnchor"),
                Hv = Symbol("preload"),
                Gv = Symbol("onARButtonContainerClick"),
                Vv = Symbol("onARStatus"),
                jv = Symbol("onARTap"),
                Wv = Symbol("selectARMode");
            var qv, Xv, Yv;
            const Jv = Symbol("evaluate"),
                Zv = Symbol("lastValue");
            class Kv {
                constructor() {
                    this[qv] = null
                }
                static evaluatableFor(t, e = Dd) {
                    if (t instanceof Kv) return t;
                    if ("number" === t.type) return "%" === t.unit ? new ty(t, e) : t;
                    switch (t.name.value) {
                        case "calc":
                            return new sy(t, e);
                        case "env":
                            return new ny(t)
                    }
                    return Dd
                }
                static evaluate(t) {
                    return t instanceof Kv ? t.evaluate() : t
                }
                static isConstant(t) {
                    return !(t instanceof Kv) || t.isConstant
                }
                static applyIntrinsics(t, e) {
                    const {
                        basis: n,
                        keywords: i
                    } = e, {
                        auto: r
                    } = i;
                    return n.map((e, n) => {
                        const s = null == r[n] ? e : r[n];
                        let o = t[n] ? t[n] : s;
                        if ("ident" === o.type) {
                            const t = o.value;
                            t in i && (o = i[t][n])
                        }
                        return null != o && "ident" !== o.type || (o = s), "%" === o.unit ? Ed(o.number / 100 * e.number, e.unit) : (o = zd(o, e), o.unit !== e.unit ? e : o)
                    })
                }
                get isConstant() {
                    return !1
                }
                evaluate() {
                    return this.isConstant && null != this[Zv] || (this[Zv] = this[Jv]()), this[Zv]
                }
            }
            qv = Zv;
            const $v = Symbol("percentage"),
                Qv = Symbol("basis");
            class ty extends Kv {
                constructor(t, e) {
                    super(), this[$v] = t, this[Qv] = e
                }
                get isConstant() {
                    return !0
                }[Jv]() {
                    return Ed(this[$v].number / 100 * this[Qv].number, this[Qv].unit)
                }
            }
            const ey = Symbol("identNode");
            class ny extends Kv {
                constructor(t) {
                    super(), this[Xv] = null;
                    const e = t.arguments.length ? t.arguments[0].terms[0] : null;
                    null != e && "ident" === e.type && (this[ey] = e)
                }
                get isConstant() {
                    return !1
                }[(Xv = ey, Jv)]() {
                    if (null != this[ey]) switch (this[ey].value) {
                        case "window-scroll-y":
                            return {
                                type: "number",
                                number: window.pageYOffset / (Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) - window.innerHeight) || 0,
                                unit: null
                            }
                    }
                    return Dd
                }
            }
            const iy = /[\*\/]/,
                ry = Symbol("evalutor");
            class sy extends Kv {
                constructor(t, e = Dd) {
                    if (super(), this[Yv] = null, 1 !== t.arguments.length) return;
                    const n = t.arguments[0].terms.slice(),
                        i = [];
                    for (; n.length;) {
                        const t = n.shift();
                        if (i.length > 0) {
                            const n = i[i.length - 1];
                            if ("operator" === n.type && iy.test(n.value)) {
                                const n = i.pop(),
                                    r = i.pop();
                                if (null == r) return;
                                i.push(new cy(n, Kv.evaluatableFor(r, e), Kv.evaluatableFor(t, e)));
                                continue
                            }
                        }
                        i.push("operator" === t.type ? t : Kv.evaluatableFor(t, e))
                    }
                    for (; i.length > 2;) {
                        const [t, n, r] = i.splice(0, 3);
                        if ("operator" !== n.type) return;
                        i.unshift(new cy(n, Kv.evaluatableFor(t, e), Kv.evaluatableFor(r, e)))
                    }
                    1 === i.length && (this[ry] = i[0])
                }
                get isConstant() {
                    return null == this[ry] || Kv.isConstant(this[ry])
                }[(Yv = ry, Jv)]() {
                    return null != this[ry] ? Kv.evaluate(this[ry]) : Dd
                }
            }
            const oy = Symbol("operator"),
                ay = Symbol("left"),
                ly = Symbol("right");
            class cy extends Kv {
                constructor(t, e, n) {
                    super(), this[oy] = t, this[ay] = e, this[ly] = n
                }
                get isConstant() {
                    return Kv.isConstant(this[ay]) && Kv.isConstant(this[ly])
                }[Jv]() {
                    const t = zd(Kv.evaluate(this[ay])),
                        e = zd(Kv.evaluate(this[ly])),
                        {
                            number: n,
                            unit: i
                        } = t,
                        {
                            number: r,
                            unit: s
                        } = e;
                    if (null != s && null != i && s != i) return Dd;
                    const o = i || s;
                    let a;
                    switch (this[oy].value) {
                        case "+":
                            a = n + r;
                            break;
                        case "-":
                            a = n - r;
                            break;
                        case "/":
                            a = n / r;
                            break;
                        case "*":
                            a = n * r;
                            break;
                        default:
                            return Dd
                    }
                    return {
                        type: "number",
                        number: a,
                        unit: o
                    }
                }
            }
            const hy = Symbol("evaluatables"),
                uy = Symbol("intrinsics");
            class dy extends Kv {
                constructor(t, e) {
                    super(), this[uy] = e;
                    const n = t[0],
                        i = null != n ? n.terms : [];
                    this[hy] = e.basis.map((t, e) => {
                        const n = i[e];
                        return null == n ? {
                            type: "ident",
                            value: "auto"
                        } : "ident" === n.type ? n : Kv.evaluatableFor(n, t)
                    })
                }
                get isConstant() {
                    for (const t of this[hy])
                        if (!Kv.isConstant(t)) return !1;
                    return !0
                }[Jv]() {
                    const t = this[hy].map(t => Kv.evaluate(t));
                    return Kv.applyIntrinsics(t, this[uy]).map(t => t.number)
                }
            }
            var py, my, fy, gy;
            const vy = Symbol("instances"),
                yy = Symbol("activateListener"),
                xy = Symbol("deactivateListener"),
                by = Symbol("notifyInstances"),
                _y = Symbol("notify"),
                wy = Symbol("callback");
            class My {
                constructor(t) {
                    this[wy] = t
                }
                static[by]() {
                    for (const t of My[vy]) t[_y]()
                }
                static[(py = vy, yy)]() {
                    window.addEventListener("scroll", this[by], {
                        passive: !0
                    })
                }
                static[xy]() {
                    window.removeEventListener("scroll", this[by])
                }
                observe() {
                    0 === My[vy].size && My[yy](), My[vy].add(this)
                }
                disconnect() {
                    My[vy].delete(this), 0 === My[vy].size && My[xy]()
                }[_y]() {
                    this[wy]()
                }
            }
            My[py] = new Set;
            const Sy = Symbol("computeStyleCallback"),
                Ty = Symbol("astWalker"),
                Ey = Symbol("dependencies"),
                Ay = Symbol("scrollHandler"),
                Ly = Symbol("onScroll");
            class Ry {
                constructor(t) {
                    this[my] = {}, this[fy] = new Nd(["function"]), this[gy] = () => this[Ly](), this[Sy] = t
                }
                observeEffectsFor(t) {
                    const e = {},
                        n = this[Ey];
                    this[Ty].walk(t, t => {
                        const {
                            name: i
                        } = t, r = t.arguments[0].terms[0];
                        if ("env" === i.value && null != r && "ident" === r.type) switch (r.value) {
                            case "window-scroll-y":
                                if (null == e["window-scroll"]) {
                                    const t = "window-scroll" in n ? n["window-scroll"] : new My(this[Ay]);
                                    t.observe(), delete n["window-scroll"], e["window-scroll"] = t
                                }
                        }
                    });
                    for (const i in n) {
                        n[i].disconnect()
                    }
                    this[Ey] = e
                }
                dispose() {
                    for (const t in this[Ey]) {
                        this[Ey][t].disconnect()
                    }
                }[(my = Ey, fy = Ty, gy = Ay, Ly)]() {
                    this[Sy]({
                        relatedState: "window-scroll"
                    })
                }
            }
            const Py = t => {
                    const e = t.observeEffects || !1,
                        n = t.intrinsics instanceof Function ? t.intrinsics : () => t.intrinsics;
                    return (i, r) => {
                        const s = i.updated,
                            o = i.connectedCallback,
                            a = i.disconnectedCallback,
                            l = Symbol(`${r}StyleEffector`),
                            c = Symbol(`${r}StyleEvaluator`),
                            h = Symbol(`${r}UpdateEvaluator`),
                            u = Symbol(`${r}EvaluateAndSync`);
                        Object.defineProperties(i, {
                            [l]: {
                                value: null,
                                writable: !0
                            },
                            [c]: {
                                value: null,
                                writable: !0
                            },
                            [h]: {
                                value: function() {
                                    const t = Ad(this[r]);
                                    this[c] = new dy(t, n(this)), null == this[l] && e && (this[l] = new Ry(() => this[u]())), null != this[l] && this[l].observeEffectsFor(t)
                                }
                            },
                            [u]: {
                                value: function() {
                                    if (null == this[c]) return;
                                    const e = this[c].evaluate();
                                    this[t.updateHandler](e)
                                }
                            },
                            updated: {
                                value: function(t) {
                                    t.has(r) && (this[h](), this[u]()), s.call(this, t)
                                }
                            },
                            connectedCallback: {
                                value: function() {
                                    o.call(this), this.requestUpdate(r, this[r])
                                }
                            },
                            disconnectedCallback: {
                                value: function() {
                                    a.call(this), null != this[l] && (this[l].dispose(), this[l] = null)
                                }
                            }
                        })
                    }
                },
                Cy = Object.freeze({
                    minimumRadius: 0,
                    maximumRadius: 1 / 0,
                    minimumPolarAngle: Math.PI / 8,
                    maximumPolarAngle: Math.PI - Math.PI / 8,
                    minimumAzimuthalAngle: -1 / 0,
                    maximumAzimuthalAngle: 1 / 0,
                    minimumFieldOfView: 10,
                    maximumFieldOfView: 45,
                    interactionPolicy: "always-allow",
                    touchAction: "pan-y"
                }),
                Oy = /^touch(start|end|move)$/,
                Iy = Math.PI / 8,
                Ny = .04,
                Dy = {
                    PAGE_UP: 33,
                    PAGE_DOWN: 34,
                    LEFT: 37,
                    UP: 38,
                    RIGHT: 39,
                    DOWN: 40
                },
                Fy = {
                    USER_INTERACTION: "user-interaction",
                    NONE: "none"
                };
            class Uy extends An {
                constructor(t, e) {
                    super(), this.camera = t, this.element = e, this.sensitivity = 1, this._interactionEnabled = !1, this.isUserChange = !1, this.isUserPointing = !1, this.spherical = new bu, this.goalSpherical = new bu, this.thetaDamper = new Md, this.phiDamper = new Md, this.radiusDamper = new Md, this.logFov = Math.log(Cy.maximumFieldOfView), this.goalLogFov = this.logFov, this.fovDamper = new Md, this.pointerIsDown = !1, this.lastPointerPosition = {
                        clientX: 0,
                        clientY: 0
                    }, this.touchMode = "rotate", this.touchDecided = !1, this.onPointerMove = t => {
                        if (this.pointerIsDown && this.canInteract) {
                            if (Oy.test(t.type)) {
                                const {
                                    touches: e
                                } = t;
                                switch (this.touchMode) {
                                    case "zoom":
                                        if (this.lastTouches.length > 1 && e.length > 1) {
                                            const t = this.twoTouchDistance(this.lastTouches[0], this.lastTouches[1]),
                                                n = this.twoTouchDistance(e[0], e[1]),
                                                i = Ny * (t - n) / 10;
                                            this.userAdjustOrbit(0, 0, i)
                                        }
                                        break;
                                    case "rotate":
                                        const {
                                            touchAction: t
                                        } = this._options;
                                        if (!this.touchDecided && "none" !== t) {
                                            this.touchDecided = !0;
                                            const {
                                                clientX: n,
                                                clientY: i
                                            } = e[0], r = Math.abs(n - this.lastPointerPosition.clientX), s = Math.abs(i - this.lastPointerPosition.clientY);
                                            if ("pan-y" === t && s > r && document.body.scrollHeight > window.innerHeight || "pan-x" === t && r > s) return void(this.touchMode = "scroll")
                                        }
                                        this.handleSinglePointerMove(e[0]);
                                        break;
                                    case "scroll":
                                        return
                                }
                                this.lastTouches = e
                            } else this.handleSinglePointerMove(t);
                            t.cancelable && t.preventDefault()
                        }
                    }, this.onPointerDown = t => {
                        if (this.pointerIsDown = !0, this.isUserPointing = !1, Oy.test(t.type)) {
                            const {
                                touches: e
                            } = t;
                            switch (this.touchDecided = !1, e.length) {
                                default:
                                    case 1:
                                    this.touchMode = "rotate",
                                this.handleSinglePointerDown(e[0]);
                                break;
                                case 2:
                                        this.touchMode = "zoom"
                            }
                            this.lastTouches = e
                        } else this.handleSinglePointerDown(t)
                    }, this.onPointerUp = t => {
                        this.element.style.cursor = "grab", this.pointerIsDown = !1, this.isUserPointing && this.dispatchEvent({
                            type: "pointer-change-end",
                            pointer: Object.assign({}, this.lastPointerPosition)
                        })
                    }, this.onWheel = t => {
                        if (!this.canInteract) return;
                        const e = t.deltaY * (1 == t.deltaMode ? 18 : 1) * Ny / 30;
                        this.userAdjustOrbit(0, 0, e), t.cancelable && t.preventDefault()
                    }, this.onKeyDown = t => {
                        let e = !1;
                        switch (t.keyCode) {
                            case Dy.PAGE_UP:
                                e = !0, this.userAdjustOrbit(0, 0, Ny);
                                break;
                            case Dy.PAGE_DOWN:
                                e = !0, this.userAdjustOrbit(0, 0, -1 * Ny);
                                break;
                            case Dy.UP:
                                e = !0, this.userAdjustOrbit(0, -Iy, 0);
                                break;
                            case Dy.DOWN:
                                e = !0, this.userAdjustOrbit(0, Iy, 0);
                                break;
                            case Dy.LEFT:
                                e = !0, this.userAdjustOrbit(-Iy, 0, 0);
                                break;
                            case Dy.RIGHT:
                                e = !0, this.userAdjustOrbit(Iy, 0, 0)
                        }
                        e && t.cancelable && t.preventDefault()
                    }, this._options = Object.assign({}, Cy), this.setOrbit(0, Math.PI / 2, 1), this.setFieldOfView(100), this.jumpToGoal()
                }
                get interactionEnabled() {
                    return this._interactionEnabled
                }
                enableInteraction() {
                    if (!1 === this._interactionEnabled) {
                        const {
                            element: t
                        } = this;
                        t.addEventListener("mousemove", this.onPointerMove), t.addEventListener("mousedown", this.onPointerDown), t.addEventListener("wheel", this.onWheel), t.addEventListener("keydown", this.onKeyDown), t.addEventListener("touchstart", this.onPointerDown, {
                            passive: !0
                        }), t.addEventListener("touchmove", this.onPointerMove), self.addEventListener("mouseup", this.onPointerUp), self.addEventListener("touchend", this.onPointerUp), this.element.style.cursor = "grab", this._interactionEnabled = !0
                    }
                }
                disableInteraction() {
                    if (!0 === this._interactionEnabled) {
                        const {
                            element: t
                        } = this;
                        t.removeEventListener("mousemove", this.onPointerMove), t.removeEventListener("mousedown", this.onPointerDown), t.removeEventListener("wheel", this.onWheel), t.removeEventListener("keydown", this.onKeyDown), t.removeEventListener("touchstart", this.onPointerDown), t.removeEventListener("touchmove", this.onPointerMove), self.removeEventListener("mouseup", this.onPointerUp), self.removeEventListener("touchend", this.onPointerUp), t.style.cursor = "", this._interactionEnabled = !1
                    }
                }
                get options() {
                    return this._options
                }
                getCameraSpherical(t = new bu) {
                    return t.copy(this.spherical)
                }
                getFieldOfView() {
                    return this.camera.fov
                }
                applyOptions(t) {
                    Object.assign(this._options, t), this.setOrbit(), this.setFieldOfView(Math.exp(this.goalLogFov))
                }
                updateNearFar(t, e) {
                    this.camera.near = Math.max(t, e / 1e3), this.camera.far = e, this.camera.updateProjectionMatrix()
                }
                updateAspect(t) {
                    this.camera.aspect = t, this.camera.updateProjectionMatrix()
                }
                setOrbit(t = this.goalSpherical.theta, e = this.goalSpherical.phi, n = this.goalSpherical.radius) {
                    const {
                        minimumAzimuthalAngle: i,
                        maximumAzimuthalAngle: r,
                        minimumPolarAngle: s,
                        maximumPolarAngle: o,
                        minimumRadius: a,
                        maximumRadius: l
                    } = this._options, {
                        theta: c,
                        phi: h,
                        radius: u
                    } = this.goalSpherical, d = bp(t, i, r);
                    isFinite(i) || isFinite(r) || (this.spherical.theta = this.wrapAngle(this.spherical.theta - d) + d);
                    const p = bp(e, s, o),
                        m = bp(n, a, l);
                    return (d !== c || p !== h || m !== u) && (this.goalSpherical.theta = d, this.goalSpherical.phi = p, this.goalSpherical.radius = m, this.goalSpherical.makeSafe(), this.isUserChange = !1, !0)
                }
                setRadius(t) {
                    this.goalSpherical.radius = t, this.setOrbit()
                }
                setFieldOfView(t) {
                    const {
                        minimumFieldOfView: e,
                        maximumFieldOfView: n
                    } = this._options;
                    t = bp(t, e, n), this.goalLogFov = Math.log(t)
                }
                adjustOrbit(t, e, n) {
                    const {
                        theta: i,
                        phi: r,
                        radius: s
                    } = this.goalSpherical, {
                        minimumRadius: o,
                        maximumRadius: a,
                        minimumFieldOfView: l,
                        maximumFieldOfView: c
                    } = this._options, h = this.spherical.theta - i, u = Math.PI - .001, d = i - bp(t, -u - h, u - h), p = r - e, m = 0 === n ? 0 : n > 0 ? (a - s) / (Math.log(c) - this.goalLogFov) : (s - o) / (this.goalLogFov - Math.log(l)), f = s + n * Math.min(isFinite(m) ? m : 1 / 0, a - o);
                    if (this.setOrbit(d, p, f), 0 !== n) {
                        const t = this.goalLogFov + n;
                        this.setFieldOfView(Math.exp(t))
                    }
                }
                jumpToGoal() {
                    this.update(0, xd)
                }
                update(t, e) {
                    if (this.isStationary()) return;
                    const {
                        maximumPolarAngle: n,
                        maximumRadius: i
                    } = this._options, r = this.spherical.theta - this.goalSpherical.theta;
                    Math.abs(r) > Math.PI && !isFinite(this._options.minimumAzimuthalAngle) && !isFinite(this._options.maximumAzimuthalAngle) && (this.spherical.theta -= 2 * Math.sign(r) * Math.PI), this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, e, Math.PI), this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, e, n), this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, e, i), this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, e, 1), this.moveCamera()
                }
                isStationary() {
                    return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov
                }
                moveCamera() {
                    this.spherical.makeSafe(), this.camera.position.setFromSpherical(this.spherical), this.camera.setRotationFromEuler(new Mi(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, "YXZ")), this.camera.fov !== Math.exp(this.logFov) && (this.camera.fov = Math.exp(this.logFov), this.camera.updateProjectionMatrix());
                    const t = this.isUserChange ? Fy.USER_INTERACTION : Fy.NONE;
                    this.dispatchEvent({
                        type: "change",
                        source: t
                    })
                }
                get canInteract() {
                    if ("allow-when-focused" == this._options.interactionPolicy) {
                        return this.element.getRootNode().activeElement === this.element
                    }
                    return "always-allow" === this._options.interactionPolicy
                }
                userAdjustOrbit(t, e, n) {
                    this.adjustOrbit(t * this.sensitivity, e * this.sensitivity, n), this.isUserChange = !0, this.dispatchEvent({
                        type: "change",
                        source: Fy.USER_INTERACTION
                    })
                }
                wrapAngle(t) {
                    const e = (t + Math.PI) / (2 * Math.PI);
                    return 2 * (e - Math.floor(e)) * Math.PI - Math.PI
                }
                pixelLengthToSphericalAngle(t) {
                    return 2 * Math.PI * t / this.element.clientHeight
                }
                twoTouchDistance(t, e) {
                    const {
                        clientX: n,
                        clientY: i
                    } = t, {
                        clientX: r,
                        clientY: s
                    } = e, o = r - n, a = s - i;
                    return Math.sqrt(o * o + a * a)
                }
                handleSinglePointerMove(t) {
                    const {
                        clientX: e,
                        clientY: n
                    } = t, i = this.pixelLengthToSphericalAngle(e - this.lastPointerPosition.clientX), r = this.pixelLengthToSphericalAngle(n - this.lastPointerPosition.clientY);
                    this.lastPointerPosition.clientX = e, this.lastPointerPosition.clientY = n, !1 === this.isUserPointing && (this.isUserPointing = !0, this.dispatchEvent({
                        type: "pointer-change-start",
                        pointer: Object.assign({}, t)
                    })), this.userAdjustOrbit(i, r, 0)
                }
                handleSinglePointerDown(t) {
                    this.lastPointerPosition.clientX = t.clientX, this.lastPointerPosition.clientY = t.clientY, this.element.style.cursor = "grabbing"
                }
            }
            const zy = t => t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1,
                ky = (t, e, n = zy) => i => t + (e - t) * n(i),
                By = (t, e) => {
                    const n = [],
                        i = [];
                    let r = t;
                    for (let s = 0; s < e.length; ++s) {
                        const t = e[s],
                            {
                                value: o,
                                frames: a
                            } = t,
                            l = t.ease || zy,
                            c = ky(r, o, l);
                        n.push(c), i.push(a), r = o
                    }
                    return ((t, e) => {
                        const n = e.reduce((t, e) => t + e, 0),
                            i = e.map(t => t / n);
                        return e => {
                            let n = 0,
                                r = 1 / 0,
                                s = () => 0;
                            for (let o = 0; o < i.length && (r = i[o], s = t[o], !(e <= n + r)); ++o) n += r;
                            return s((e - n) / r)
                        }
                    })(n, i)
                };
            var Hy = function(t, e, n, i) {
                for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)(r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
                return s > 3 && o && Object.defineProperty(e, n, o), o
            };
            const Gy = 5e3,
                Vy = By(0, [{
                    frames: 5,
                    value: -1
                }, {
                    frames: 1,
                    value: -1
                }, {
                    frames: 8,
                    value: 1
                }, {
                    frames: 1,
                    value: 1
                }, {
                    frames: 5,
                    value: 0
                }, {
                    frames: 18,
                    value: 0
                }]),
                jy = By(0, [{
                    frames: 1,
                    value: 1
                }, {
                    frames: 5,
                    value: 1
                }, {
                    frames: 1,
                    value: 0
                }, {
                    frames: 6,
                    value: 0
                }]),
                Wy = "0deg 75deg 105%",
                qy = "auto auto auto",
                Xy = "auto",
                Yy = 1.1 * Zd,
                Jy = ["front", "right", "back", "left"],
                Zy = ["upper-", "", "lower-"],
                Ky = 3e3,
                $y = "Use mouse, touch or arrow keys to control the camera!",
                Qy = {
                    AUTO: "auto",
                    WHEN_FOCUSED: "when-focused",
                    NONE: "none"
                },
                tx = {
                    BASIC: "basic",
                    WIGGLE: "wiggle"
                },
                ex = {
                    ALWAYS_ALLOW: "always-allow",
                    WHEN_FOCUSED: "allow-when-focused"
                },
                nx = {
                    PAN_Y: "pan-y",
                    PAN_X: "pan-x",
                    NONE: "none"
                },
                ix = t => ({
                    basis: [Ed(t[Ix] * Math.PI / 180, "rad")],
                    keywords: {
                        auto: [null]
                    }
                }),
                rx = {
                    basis: [Fd(Ed(25, "deg"))],
                    keywords: {
                        auto: [null]
                    }
                },
                sx = t => {
                    const e = t[Jg];
                    return {
                        basis: [Fd(Ed(45, "deg"))],
                        keywords: {
                            auto: [Ed(e.framedFieldOfView, "deg")]
                        }
                    }
                },
                ox = (() => {
                    const t = Ad(Wy)[0].terms,
                        e = zd(t[0]),
                        n = zd(t[1]);
                    return t => {
                        const i = t[Jg].model.idealCameraDistance;
                        return {
                            basis: [e, n, Ed(i, "m")],
                            keywords: {
                                auto: [null, null, Ed(105, "%")]
                            }
                        }
                    }
                })(),
                ax = t => {
                    const e = Yy * t[Jg].model.idealCameraDistance;
                    return {
                        basis: [Ed(-1 / 0, "rad"), Ed(Math.PI / 8, "rad"), Ed(e, "m")],
                        keywords: {
                            auto: [null, null, null]
                        }
                    }
                },
                lx = t => {
                    const e = ox(t),
                        n = new dy([], e).evaluate()[2];
                    return {
                        basis: [Ed(1 / 0, "rad"), Ed(Math.PI - Math.PI / 8, "rad"), Ed(n, "m")],
                        keywords: {
                            auto: [null, null, null]
                        }
                    }
                },
                cx = t => {
                    const e = t[Jg].model.boundingBox.getCenter(new Hn);
                    return {
                        basis: [Ed(e.x, "m"), Ed(e.y, "m"), Ed(e.z, "m")],
                        keywords: {
                            auto: [null, null, null]
                        }
                    }
                },
                hx = Math.PI / 2,
                ux = Math.PI / 3,
                dx = hx / 2,
                px = 2 * Math.PI,
                mx = Symbol("controls"),
                fx = Symbol("promptElement"),
                gx = Symbol("promptAnimatedContainer"),
                vx = Symbol("deferInteractionPrompt"),
                yx = Symbol("updateAria"),
                xx = Symbol("updateCameraForRadius"),
                bx = Symbol("blurHandler"),
                _x = Symbol("focusHandler"),
                wx = Symbol("changeHandler"),
                Mx = Symbol("pointerChangeHandler"),
                Sx = Symbol("onBlur"),
                Tx = Symbol("onFocus"),
                Ex = Symbol("onChange"),
                Ax = Symbol("onPointerChange"),
                Lx = Symbol("waitingToPromptUser"),
                Rx = Symbol("userHasInteracted"),
                Px = Symbol("promptElementVisibleTime"),
                Cx = Symbol("lastPromptOffset"),
                Ox = Symbol("focusedTime"),
                Ix = Symbol("zoomAdjustedFieldOfView"),
                Nx = Symbol("lastSpherical"),
                Dx = Symbol("jumpCamera"),
                Fx = Symbol("initialized"),
                Ux = Symbol("maintainThetaPhi"),
                zx = Symbol("syncCameraOrbit"),
                kx = Symbol("syncFieldOfView"),
                Bx = Symbol("syncCameraTarget"),
                Hx = Symbol("syncMinCameraOrbit"),
                Gx = Symbol("syncMaxCameraOrbit"),
                Vx = Symbol("syncMinFieldOfView"),
                jx = Symbol("syncMaxFieldOfView");
            var Wx = function(t, e, n, i) {
                for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)(r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
                return s > 3 && o && Object.defineProperty(e, n, o), o
            };
            const qx = .1,
                Xx = 0,
                Yx = 1,
                Jx = 1,
                Zx = Symbol("currentEnvironmentMap"),
                Kx = Symbol("applyEnvironmentMap"),
                $x = Symbol("updateEnvironment"),
                Qx = Symbol("cancelEnvironmentUpdate"),
                tb = Symbol("onPreload");
            var eb, nb;
            const ib = "This page includes one or more 3D models that are loading",
                rb = "All 3D models in the page have loaded",
                sb = 100,
                ob = Symbol("modelViewerStatusInstance"),
                ab = Symbol("updateStatus");
            eb = ob, nb = ab;
            var lb = function(t, e, n, i) {
                for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)(r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
                return s > 3 && o && Object.defineProperty(e, n, o), o
            };
            const cb = 100,
                hb = .2,
                ub = "https://www.gstatic.com/draco/versioned/decoders/1.3.6/",
                db = 32,
                pb = 13,
                mb = {
                    AUTO: "auto",
                    INTERACTION: "interaction",
                    MANUAL: "manual"
                },
                fb = {
                    AUTO: "auto",
                    LAZY: "lazy",
                    EAGER: "eager"
                },
                gb = {
                    INTERACTION: "interaction"
                },
                vb = new class extends An {
                    constructor() {
                        super(), this[eb] = null, this.registeredInstanceStatuses = new Map, this.loadingPromises = [], this.statusElement = document.createElement("p"), this.statusUpdateInProgress = !1, this[nb] = xp(() => this.updateStatus(), sb);
                        const {
                            statusElement: t
                        } = this, {
                            style: e
                        } = t;
                        t.setAttribute("role", "status"), t.classList.add("screen-reader-only"), e.top = e.left = "0", e.pointerEvents = "none"
                    }
                    registerInstance(t) {
                        if (this.registeredInstanceStatuses.has(t)) return;
                        let e = () => {};
                        const n = !1 === t.loaded && !!t.src,
                            i = new Promise(i => {
                                if (!n) return void i();
                                const r = () => {
                                    i(), t.removeEventListener("load", r), t.removeEventListener("error", r)
                                };
                                t.addEventListener("load", r), t.addEventListener("error", r), e = r
                            });
                        this.registeredInstanceStatuses.set(t, {
                            onUnregistered: e
                        }), this.loadingPromises.push(i), null == this.modelViewerStatusInstance && (this.modelViewerStatusInstance = t)
                    }
                    unregisterInstance(t) {
                        if (!this.registeredInstanceStatuses.has(t)) return;
                        const e = this.registeredInstanceStatuses,
                            n = e.get(t);
                        e.delete(t), n.onUnregistered(), this.modelViewerStatusInstance === t && (this.modelViewerStatusInstance = e.size > 0 ? Mp(e) : null)
                    }
                    get modelViewerStatusInstance() {
                        return this[ob]
                    }
                    set modelViewerStatusInstance(t) {
                        if (this[ob] === t) return;
                        const {
                            statusElement: e
                        } = this;
                        null != t && null != t.shadowRoot ? t.shadowRoot.appendChild(e) : null != e.parentNode && e.parentNode.removeChild(e), this[ob] = t, this[ab]()
                    }
                    async updateStatus() {
                        if (!this.statusUpdateInProgress && 0 !== this.loadingPromises.length) {
                            for (this.statusElement.textContent = ib, this.statusUpdateInProgress = !0, this.dispatchEvent({
                                    type: "initial-status-announced"
                                }); this.loadingPromises.length;) {
                                const {
                                    loadingPromises: t
                                } = this;
                                this.loadingPromises = [], await Promise.all(t)
                            }
                            this.statusElement.textContent = rb, this.statusUpdateInProgress = !1, this.dispatchEvent({
                                type: "finished-loading-announced"
                            })
                        }
                    }
                },
                yb = Symbol("defaultProgressBarElement"),
                xb = Symbol("defaultProgressMaskElement"),
                bb = Symbol("posterContainerElement"),
                _b = Symbol("defaultPosterElement"),
                wb = Symbol("posterDismissalSource"),
                Mb = Symbol("showPoster"),
                Sb = Symbol("hidePoster"),
                Tb = Symbol("modelIsRevealed"),
                Eb = Symbol("updateProgressBar"),
                Ab = Symbol("lastReportedProgress"),
                Lb = Symbol("transitioned"),
                Rb = Symbol("ariaLabelCallToAction"),
                Pb = Symbol("clickHandler"),
                Cb = Symbol("keydownHandler"),
                Ob = Symbol("processHandler"),
                Ib = Symbol("onClick"),
                Nb = Symbol("onKeydown"),
                Db = Symbol("onProgress"),
                Fb = {
                    HANDSHAKE: 1,
                    IMPORT_SCRIPT: 2,
                    MODEL_CHANGE: 3,
                    MUTATION_RESULT: 4,
                    CONTEXT_INITIALIZED: 5,
                    MUTATE: 6
                },
                Ub = Symbol("ownerModel");
            class zb {
                constructor(t) {
                    if (null == t) throw new Error("Illegal constructor");
                    this[Ub] = t.model
                }
                get ownerModel() {
                    return this[Ub]
                }
            }
            const kb = Symbol("kernel"),
                Bb = Symbol("uri"),
                Hb = Symbol("name");
            var Gb, Vb, jb;
            const Wb = Symbol("pbrMetallicRoughness"),
                qb = Symbol("normalTexture"),
                Xb = Symbol("occlusionTexture"),
                Yb = Symbol("emissiveTexture"),
                Jb = Symbol("kernel"),
                Zb = Symbol("name");
            var Kb;
            Gb = qb, Vb = Xb, jb = Yb;
            const $b = Symbol("material"),
                Qb = Symbol("kernel");
            var t_, e_;
            Kb = $b;
            const n_ = Symbol("kernel"),
                i_ = Symbol("baseColorFactor"),
                r_ = Symbol("baseColorTexture"),
                s_ = Symbol("metallicRoughnessTexture"),
                o_ = Symbol("metallicFactor"),
                a_ = Symbol("roughnessFactor");
            var l_, c_;
            t_ = r_, e_ = s_;
            const h_ = Symbol("kernel"),
                u_ = Symbol("minFilter"),
                d_ = Symbol("magFilter"),
                p_ = Symbol("wrapS"),
                m_ = Symbol("wrapT"),
                f_ = Symbol("name");
            var g_;
            l_ = u_, c_ = d_;
            const v_ = Symbol("kernel"),
                y_ = Symbol("texture");
            var x_, b_;
            g_ = y_;
            const __ = Symbol("kernel"),
                w_ = Symbol("source"),
                M_ = Symbol("sampler"),
                S_ = Symbol("name");
            var T_, E_, A_, L_, R_, P_;
            x_ = w_, b_ = M_;
            const C_ = {
                    model: class extends zb {
                        constructor(t, e) {
                            super(t), this[Kb] = Object.freeze([]), this[Qb] = t;
                            for (const n of e.materials) this[Qb].deserialize("material", n)
                        }
                        get materials() {
                            return this[Qb].getElementsByType("material")
                        }
                        get ownerModel() {
                            return this
                        }
                    },
                    material: class extends zb {
                        constructor(t, e) {
                            super(t), this[Gb] = null, this[Vb] = null, this[jb] = null, this[Jb] = t, null != e.name && (this[Zb] = e.name);
                            const {
                                pbrMetallicRoughness: n,
                                normalTexture: i,
                                occlusionTexture: r,
                                emissiveTexture: s
                            } = e;
                            this[Wb] = t.deserialize("pbr-metallic-roughness", n), null != i && (this[qb] = t.deserialize("texture-info", i)), null != r && (this[Xb] = t.deserialize("texture-info", r)), null != s && (this[Yb] = t.deserialize("texture-info", s))
                        }
                        get pbrMetallicRoughness() {
                            return this[Wb]
                        }
                        get normalTexture() {
                            return this[qb]
                        }
                        get occlusionTexture() {
                            return this[Xb]
                        }
                        get emissiveTexture() {
                            return this[Yb]
                        }
                        get name() {
                            return this[Zb]
                        }
                    },
                    "pbr-metallic-roughness": class extends zb {
                        constructor(t, e) {
                            super(t), this[t_] = null, this[e_] = null, this[n_] = t, this[i_] = Object.freeze(e.baseColorFactor), this[o_] = e.metallicFactor, this[a_] = e.roughnessFactor;
                            const {
                                baseColorTexture: n,
                                metallicRoughnessTexture: i
                            } = e;
                            null != n && (this[r_] = t.deserialize("texture-info", n)), null != i && (this[s_] = t.deserialize("texture-info", i))
                        }
                        get baseColorFactor() {
                            return this[i_]
                        }
                        get metallicFactor() {
                            return this[o_]
                        }
                        get roughnessFactor() {
                            return this[a_]
                        }
                        get baseColorTexture() {
                            return this[r_]
                        }
                        get metallicRoughnessTexture() {
                            return this[s_]
                        }
                        async setBaseColorFactor(t) {
                            await this[n_].mutate(this, "baseColorFactor", t), this[i_] = Object.freeze(t)
                        }
                        async setMetallicFactor(t) {
                            await this[n_].mutate(this, "metallicFactor", t), this[o_] = t
                        }
                        async setRoughnessFactor(t) {
                            await this[n_].mutate(this, "roughnessFactor", t), this[a_] = t
                        }
                    },
                    image: class extends zb {
                        constructor(t, e) {
                            super(t), this[kb] = t, this[Bb] = e.uri || null, null != e.name && (this[Hb] = e.name)
                        }
                        get name() {
                            return this[Hb]
                        }
                        get type() {
                            return null != this.uri ? "external" : "embedded"
                        }
                        get uri() {
                            return this[Bb]
                        }
                        async setURI(t) {
                            await this[kb].mutate(this, "uri", t), this[Bb] = t
                        }
                    },
                    sampler: class extends zb {
                        constructor(t, e) {
                            super(t), this[l_] = null, this[c_] = null, this[h_] = t, null != e.name && (this[f_] = e.name), this[u_] = e.minFilter || null, this[d_] = e.magFilter || null, this[p_] = e.wrapS || 10497, this[m_] = e.wrapT || 10497
                        }
                        get name() {
                            return this[f_]
                        }
                        get minFilter() {
                            return this[u_]
                        }
                        get magFilter() {
                            return this[d_]
                        }
                        get wrapS() {
                            return this[p_]
                        }
                        get wrapT() {
                            return this[m_]
                        }
                        async setMinFilter(t) {
                            await this[h_].mutate(this, "minFilter", t), this[u_] = t
                        }
                        async setMagFilter(t) {
                            await this[h_].mutate(this, "magFilter", t), this[d_] = t
                        }
                        async setWrapS(t) {
                            await this[h_].mutate(this, "wrapS", t), this[p_] = t
                        }
                        async setWrapT(t) {
                            await this[h_].mutate(this, "wrapT", t), this[m_] = t
                        }
                    },
                    texture: class extends zb {
                        constructor(t, e) {
                            super(t), this[x_] = null, this[b_] = null, this[__] = t;
                            const {
                                sampler: n,
                                source: i,
                                name: r
                            } = e;
                            null != r && (this[S_] = r), null != n && (this[M_] = t.deserialize("sampler", n)), null != i && (this[w_] = t.deserialize("image", i))
                        }
                        get name() {
                            return this[S_]
                        }
                        get sampler() {
                            return this[M_]
                        }
                        get source() {
                            return this[w_]
                        }
                        async setSampler(t) {
                            await this[__].mutate(this, "sampler", t), this[M_] = t
                        }
                        async setSource(t) {
                            await this[__].mutate(this, "source", t), this[w_] = t
                        }
                    },
                    "texture-info": class extends zb {
                        constructor(t, e) {
                            super(t), this[g_] = null, this[v_] = t;
                            const {
                                texture: n
                            } = e;
                            null != n && (this[y_] = t.deserialize("texture", n))
                        }
                        get texture() {
                            return this[y_]
                        }
                        async setTexture(t) {
                            await this[v_].mutate(this, "texture", t), this[y_] = t
                        }
                    }
                },
                O_ = Symbol("onMessageEvent"),
                I_ = Symbol("port"),
                N_ = Symbol("model"),
                D_ = Symbol("elementsByLocalId"),
                F_ = Symbol("localIdsByElement"),
                U_ = Symbol("elementsByType"),
                z_ = Symbol("pendingMutations"),
                k_ = Symbol("nextMutationId");
            class B_ {
                constructor(t, e) {
                    this[T_] = new Map, this[E_] = new Map, this[A_] = new Map, this[L_] = new Map, this[R_] = 0, this[P_] = t => {
                        const {
                            data: e
                        } = t;
                        switch (e && e.type) {
                            case Fb.MUTATION_RESULT:
                                {
                                    const t = e,
                                        {
                                            applied: n,
                                            mutationId: i
                                        } = t,
                                        r = this[z_].get(i);this[z_].delete(i),
                                    null != r && (n ? r.resolve() : r.reject());
                                    break
                                }
                        }
                    };
                    const n = new Array("model", "material", "pbr-metallic-roughness", "sampler", "image", "texture", "texture-info");
                    for (const i of n) this[U_].set(i, new Set);
                    this[I_] = t, this[I_].addEventListener("message", this[O_]), this[I_].start(), this[N_] = this.deserialize("model", e)
                }
                get model() {
                    return this[N_]
                }
                async mutate(t, e, n) {
                    if (!this[F_].has(t)) throw new Error("Cannot mutate unknown element");
                    const i = this[F_].get(t);
                    return n instanceof zb && (n = this[F_].get(n)), new Promise((t, r) => {
                        const s = this[k_]++;
                        this[I_].postMessage({
                            type: Fb.MUTATE,
                            id: i,
                            property: e,
                            value: n,
                            mutationId: s
                        }), this[z_].set(s, {
                            resolve: t,
                            reject: r
                        })
                    })
                }
                deserialize(t, e) {
                    const {
                        id: n
                    } = e;
                    if (this[D_].has(n)) return this[D_].get(n);
                    const i = C_[t];
                    if (null == i) throw new Error(`Cannot deserialize unknown type: ${t}`);
                    const r = new i(this, e);
                    return this[D_].set(n, r), this[F_].set(r, n), this[U_].get(t).add(r), r
                }
                getElementsByType(t) {
                    return this[U_].has(t) ? Array.from(this[U_].get(t)) : []
                }
                deactivate() {
                    this[I_].close(), this[I_].removeEventListener("message", this[O_])
                }
            }
            var H_;
            T_ = D_, E_ = F_, A_ = U_, L_ = z_, R_ = k_, P_ = O_;
            const G_ = Symbol("modelGraft"),
                V_ = Symbol("port"),
                j_ = Symbol("onMessageEvent");
            class W_ {
                constructor(t, e) {
                    this[H_] = async t => {
                        const {
                            data: e
                        } = t;
                        if (e && e.type && e.type === Fb.MUTATE) {
                            let t = !1;
                            const {
                                mutationId: n
                            } = e;
                            try {
                                await this[G_].mutate(e.id, e.property, e.value), t = !0
                            } finally {
                                this[V_].postMessage({
                                    type: Fb.MUTATION_RESULT,
                                    applied: t,
                                    mutationId: n
                                })
                            }
                        }
                    }, this[G_] = t, this[V_] = e, this[V_].addEventListener("message", this[j_]), this[V_].start()
                }
                dispose() {
                    this[V_].removeEventListener("message", this[j_]), this[V_].close()
                }
            }
            H_ = j_;
            const q_ = (() => {
                    let t = 0;
                    return () => t++
                })(),
                X_ = Symbol("callbacks"),
                Y_ = Symbol("visitMesh"),
                J_ = Symbol("visitElement"),
                Z_ = Symbol("visitNode"),
                K_ = Symbol("visitScene"),
                $_ = Symbol("visitMaterial");
            class Q_ {
                constructor(t) {
                    this[X_] = t
                }
                visit(t, e = {}) {
                    const n = !!e.allScenes,
                        i = !!e.sparse,
                        r = n ? t.scenes || [] : t.scenes && null != t.scene ? [t.scenes[t.scene]] : [],
                        s = {
                            hierarchy: [],
                            visited: new Set,
                            sparse: i,
                            gltf: t
                        };
                    for (const o of r) this[K_](t.scenes.indexOf(o), s)
                }[J_](t, e, n, i, r) {
                    if (null == e) return;
                    const s = e[t],
                        {
                            sparse: o,
                            hierarchy: a,
                            visited: l
                        } = n;
                    null != s && (o && l.has(s) || (l.add(s), a.push(s), null != i && i(s, t, a), null != r && r(s), a.pop()))
                }[K_](t, e) {
                    const {
                        gltf: n
                    } = e, {
                        scene: i
                    } = this[X_];
                    this[J_](t, n.scenes, e, i, t => {
                        if (null != t.nodes)
                            for (const n of t.nodes) this[Z_](n, e)
                    })
                }[Z_](t, e) {
                    const {
                        gltf: n
                    } = e, {
                        node: i
                    } = this[X_];
                    this[J_](t, n.nodes, e, i, t => {
                        if (null != t.mesh && this[Y_](t.mesh, e), null != t.children)
                            for (const n of t.children) this[Z_](n, e)
                    })
                }[Y_](t, e) {
                    const {
                        gltf: n
                    } = e, {
                        mesh: i
                    } = this[X_];
                    this[J_](t, n.meshes, e, i, t => {
                        for (const n of t.primitives) null != n.material && this[$_](n.material, e)
                    })
                }[$_](t, e) {
                    const {
                        gltf: n
                    } = e, {
                        material: i
                    } = this[X_];
                    this[J_](t, n.materials, e, i)
                }
            }
            var tw;
            const ew = Symbol("correlatedObjects"),
                nw = Symbol("sourceObject"),
                iw = Symbol("graft"),
                rw = Symbol("id");
            class sw {
                constructor(t, e, n = null) {
                    this[tw] = q_(), this[iw] = t, this[nw] = e, this[ew] = n, t.adopt(this)
                }
                get ownerModel() {
                    return this[iw].model
                }
                get internalID() {
                    return this[rw]
                }
                get name() {
                    return this[nw].name || null
                }
                get correlatedObjects() {
                    return this[ew]
                }
                get sourceObject() {
                    return this[nw]
                }
                mutate(t, e) {
                    throw new Error("Mutation not implemented for this element")
                }
                toJSON() {
                    const t = {
                            id: this[rw]
                        },
                        {
                            name: e
                        } = this;
                    return null != e && (t.name = e), t
                }
            }
            var ow;
            tw = rw;
            const aw = new Zc,
                lw = Symbol("threeTextures"),
                cw = Symbol("bufferViewImages");
            class hw extends sw {
                constructor(t, e, n) {
                    if (super(t, e, n), this[ow] = new WeakMap, null != e.bufferView)
                        for (const i of n) this[cw].set(i, i.image)
                }
                get[lw]() {
                    return this[ew]
                }
                async mutate(t, e) {
                    let n = null;
                    if ("uri" !== t) throw new Error(`Cannot configure property "${t}" on Image`);
                    null != e && (n = await new Promise((t, n) => {
                        aw.load(e, t, void 0, n)
                    }));
                    for (const i of this[lw]) null == n && null != this.sourceObject.bufferView ? i.image = this[cw].get(i) : i.image = n, i.needsUpdate = !0
                }
                toJSON() {
                    const t = super.toJSON(),
                        {
                            uri: e
                        } = this.sourceObject;
                    return null != e && (t.uri = e), t
                }
            }
            ow = cw;
            const uw = (() => {
                    const t = [9728, 9729, 9984, 9985, 9986, 9987];
                    return e => t.indexOf(e) > -1
                })(),
                dw = (() => {
                    const t = [9728, 9729];
                    return e => t.indexOf(e) > -1
                })(),
                pw = (() => {
                    const t = [33071, 33648, 10497];
                    return e => t.indexOf(e) > -1
                })(),
                mw = (t, e) => {
                    switch (t) {
                        case "minFilter":
                            return uw(e);
                        case "magFilter":
                            return dw(e);
                        case "wrapS":
                        case "wrapT":
                            return pw(e);
                        default:
                            throw new Error(`Cannot configure property "${t}" on Sampler`)
                    }
                },
                fw = {
                    minFilter: 9987,
                    magFilter: 9729,
                    wrapS: 10497,
                    wrapT: 10497
                },
                gw = Symbol("threeTextures");
            class vw extends sw {
                get[gw]() {
                    return this[ew]
                }
                constructor(t, e, n) {
                    super(t, e, n)
                }
                async mutate(t, e) {
                    const n = this.sourceObject;
                    if (null != e) {
                        if (mw(t, e)) {
                            n[t] = e;
                            for (const n of this[gw]) n[t] = e, n.needsUpdate = !0
                        }
                    } else if (t in n) {
                        delete n[t];
                        for (const e of this[gw]) e[t] = fw[t], e.needsUpdate = !0
                    }
                }
                toJSON() {
                    const t = super.toJSON(),
                        {
                            minFilter: e,
                            magFilter: n,
                            wrapS: i,
                            wrapT: r
                        } = this.sourceObject;
                    return null != e && (t.minFilter = e), null != n && (t.magFilter = n), 10497 !== i && (t.wrapS = i), 10497 !== r && (t.wrapT = r), t
                }
            }
            var yw, xw;
            const bw = Symbol("source"),
                _w = Symbol("sampler");
            class ww extends sw {
                constructor(t, e, n) {
                    super(t, e, n), this[yw] = null, this[xw] = null;
                    const i = t.correlatedSceneGraph.gltf,
                        {
                            sampler: r,
                            source: s
                        } = e;
                    if (null != r) {
                        const e = i.samplers && i.samplers[r];
                        null != e && (this[_w] = new vw(t, e, n))
                    }
                    if (null != s) {
                        const e = i.images && i.images[s];
                        null != e && (this[bw] = new hw(t, e, n))
                    }
                }
                get sampler() {
                    return this[_w]
                }
                get source() {
                    return this[bw]
                }
                toJSON() {
                    const t = super.toJSON(),
                        {
                            sampler: e,
                            source: n
                        } = this;
                    return null != e && (t.sampler = e.toJSON()), null != n && (t.source = n.toJSON()), t
                }
            }
            var Mw;
            yw = bw, xw = _w;
            const Sw = Symbol("texture");
            class Tw extends sw {
                constructor(t, e, n) {
                    super(t, e, n), this[Mw] = null;
                    const i = t.correlatedSceneGraph.gltf,
                        {
                            index: r
                        } = e,
                        s = null != r && null != i.textures ? i.textures[r] : null;
                    null != s && (this[Sw] = new ww(t, s, n))
                }
                get texture() {
                    return this[Sw]
                }
                toJSON() {
                    const t = super.toJSON(),
                        {
                            texture: e
                        } = this;
                    return null != e && (t.texture = e.toJSON()), t
                }
            }
            var Ew, Aw;
            Mw = Sw;
            const Lw = Symbol("threeMaterials"),
                Rw = Symbol("baseColorTexture"),
                Pw = Symbol("metallicRoughnessTexture");
            class Cw extends sw {
                constructor(t, e, n) {
                    super(t, e, n), this[Ew] = null, this[Aw] = null;
                    const {
                        baseColorTexture: i,
                        metallicRoughnessTexture: r
                    } = e, s = new Set, o = new Set;
                    for (const a of n) null != i && null != a.map && s.add(a.map), null != r && null != a.metalnessMap && o.add(a.metalnessMap);
                    s.size > 0 && (this[Rw] = new Tw(t, i, s)), o.size > 0 && (this[Pw] = new Tw(t, r, o))
                }
                get[(Ew = Rw, Aw = Pw, Lw)]() {
                    return this[ew]
                }
                get baseColorFactor() {
                    return this.sourceObject.baseColorFactor || [1, 1, 1, 1]
                }
                get metallicFactor() {
                    return this.sourceObject.metallicFactor || 0
                }
                get roughnessFactor() {
                    return this.sourceObject.roughnessFactor || 0
                }
                get baseColorTexture() {
                    return this[Rw]
                }
                get metallicRoughnessTexture() {
                    return this[Pw]
                }
                async mutate(t, e) {
                    if (!["baseColorFactor", "metallicFactor", "roughnessFactor"].includes(t)) throw new Error(`Cannot mutate ${t} on PBRMetallicRoughness`);
                    switch (t) {
                        case "baseColorFactor":
                            for (const t of this[Lw]) {
                                t.color.fromArray(e), t.opacity = e[3];
                                const n = this[nw];
                                1 === e && 1 === e && 1 === e && 1 === e ? delete n.baseColorFactor : n.baseColorFactor = e
                            }
                            break;
                        case "metallicFactor":
                            for (const t of this[Lw]) {
                                t.metalness = e, this[nw].metallicFactor = e
                            }
                            break;
                        case "roughnessFactor":
                            for (const t of this[Lw]) {
                                t.roughness = e, this[nw].roughnessFactor = e
                            }
                    }
                }
                toJSON() {
                    const t = super.toJSON(),
                        {
                            baseColorTexture: e,
                            metallicRoughnessTexture: n,
                            baseColorFactor: i,
                            roughnessFactor: r,
                            metallicFactor: s
                        } = this;
                    return null != e && (t.baseColorTexture = e.toJSON()), null != i && (t.baseColorFactor = i), null != s && (t.metallicFactor = s), null != r && (t.roughnessFactor = r), null != n && (t.metallicRoughnessTexture = n.toJSON()), t
                }
            }
            var Ow, Iw, Nw, Dw;
            const Fw = Symbol("pbrMetallicRoughness"),
                Uw = Symbol("normalTexture"),
                zw = Symbol("occlusionTexture"),
                kw = Symbol("emissiveTexture");
            class Bw extends sw {
                constructor(t, e, n) {
                    super(t, e, n), this[Ow] = null, this[Iw] = null, this[Nw] = null, this[Dw] = null;
                    const {
                        pbrMetallicRoughness: i,
                        normalTexture: r,
                        occlusionTexture: s,
                        emissiveTexture: o
                    } = e;
                    null != i && (this[Fw] = new Cw(t, i, n));
                    const a = new Set,
                        l = new Set,
                        c = new Set;
                    for (const h of n) {
                        const {
                            normalMap: t,
                            aoMap: e,
                            emissiveMap: n
                        } = h;
                        null != r && null != t && a.add(t), null != s && null != e && l.add(e), null != o && null != n && c.add(n)
                    }
                    a.size > 0 && (this[Uw] = new Tw(t, r, a)), l.size > 0 && (this[zw] = new Tw(t, s, l)), c.size > 0 && (this[kw] = new Tw(t, o, c))
                }
                get pbrMetallicRoughness() {
                    return this[Fw]
                }
                get normalTexture() {
                    return this[Uw]
                }
                get occlusionTexture() {
                    return this[zw]
                }
                get emissiveTexture() {
                    return this[kw]
                }
                toJSON() {
                    const t = super.toJSON(),
                        {
                            pbrMetallicRoughness: e,
                            normalTexture: n,
                            occlusionTexture: i,
                            emissiveTexture: r
                        } = this;
                    return null != e && (t.pbrMetallicRoughness = e.toJSON()), null != n && (t.normalTexture = n.toJSON()), null != i && (t.occlusionTexture = i.toJSON()), null != r && (t.emissiveTexture = r.toJSON()), t
                }
            }
            var Hw, Gw;
            Ow = Fw, Iw = Uw, Nw = zw, Dw = kw;
            const Vw = Symbol("modelUri"),
                jw = Symbol("materials");
            class Ww extends sw {
                constructor(t, e, n) {
                    super(t, n.gltf), this[Hw] = "", this[Gw] = [], this[Vw] = e, new Q_({
                        material: e => {
                            this[jw].push(new Bw(t, e, n.gltfElementMap.get(e)))
                        }
                    }).visit(n.gltf, {
                        sparse: !0
                    })
                }
                get materials() {
                    return this[jw]
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.modelUri = this[Vw], t.materials = this[jw].map(t => t.toJSON()), t
                }
            }
            var qw, Xw;
            Hw = Vw, Gw = jw;
            const Yw = Symbol("model"),
                Jw = Symbol("correlatedSceneGraph"),
                Zw = Symbol("elementsByInternalId"),
                Kw = Symbol("eventDelegate");
            class $w {
                constructor(t, e) {
                    this[qw] = document.createDocumentFragment(), this.addEventListener = (...t) => this[Kw].addEventListener(...t), this.removeEventListener = (...t) => this[Kw].removeEventListener(...t), this.dispatchEvent = (...t) => this[Kw].dispatchEvent(...t), this[Xw] = new Map, this[Jw] = e, this[Yw] = new Ww(this, t, e)
                }
                get correlatedSceneGraph() {
                    return this[Jw]
                }
                get model() {
                    return this[Yw]
                }
                getElementByInternalId(t) {
                    const e = this[Zw].get(t);
                    return null == e ? null : e
                }
                adopt(t) {
                    this[Zw].set(t.internalID, t)
                }
                async mutate(t, e, n) {
                    const i = this.getElementByInternalId(t);
                    await i.mutate(e, n), this.dispatchEvent(new CustomEvent("mutation", {
                        detail: {
                            element: i
                        }
                    }))
                }
            }
            qw = Kw, Xw = Zw;
            var Qw = {
                    POINTS: 0,
                    LINES: 1,
                    LINE_LOOP: 2,
                    LINE_STRIP: 3,
                    TRIANGLES: 4,
                    TRIANGLE_STRIP: 5,
                    TRIANGLE_FAN: 6,
                    UNSIGNED_BYTE: 5121,
                    UNSIGNED_SHORT: 5123,
                    FLOAT: 5126,
                    UNSIGNED_INT: 5125,
                    ARRAY_BUFFER: 34962,
                    ELEMENT_ARRAY_BUFFER: 34963,
                    NEAREST: 9728,
                    LINEAR: 9729,
                    NEAREST_MIPMAP_NEAREST: 9984,
                    LINEAR_MIPMAP_NEAREST: 9985,
                    NEAREST_MIPMAP_LINEAR: 9986,
                    LINEAR_MIPMAP_LINEAR: 9987,
                    CLAMP_TO_EDGE: 33071,
                    MIRRORED_REPEAT: 33648,
                    REPEAT: 10497
                },
                tM = {};
            tM[Ft] = Qw.NEAREST, tM[Ut] = Qw.NEAREST_MIPMAP_NEAREST, tM[zt] = Qw.NEAREST_MIPMAP_LINEAR, tM[kt] = Qw.LINEAR, tM[Bt] = Qw.LINEAR_MIPMAP_NEAREST, tM[Ht] = Qw.LINEAR_MIPMAP_LINEAR, tM[Nt] = Qw.CLAMP_TO_EDGE, tM[It] = Qw.REPEAT, tM[Dt] = Qw.MIRRORED_REPEAT;
            var eM = {
                    scale: "scale",
                    position: "translation",
                    quaternion: "rotation",
                    morphTargetInfluences: "weights"
                },
                nM = function() {};
            nM.prototype = {
                constructor: nM,
                parse: function(t, e, n) {
                    var i = {
                        binary: !1,
                        trs: !1,
                        onlyVisible: !0,
                        truncateDrawRange: !0,
                        embedImages: !0,
                        maxTextureSize: 1 / 0,
                        animations: [],
                        forcePowerOfTwoTextures: !1,
                        includeCustomExtensions: !1
                    };
                    (n = Object.assign({}, i, n)).animations.length > 0 && (n.trs = !0);
                    var r, s = {
                            asset: {
                                version: "2.0",
                                generator: "GLTFExporter"
                            }
                        },
                        o = 0,
                        a = [],
                        l = [],
                        c = new Map,
                        h = [],
                        u = {},
                        d = {
                            meshes: new Map,
                            attributes: new Map,
                            attributesNormalized: new Map,
                            materials: new Map,
                            textures: new Map,
                            images: new Map
                        },
                        p = new Map,
                        m = 0;

                    function f(t) {
                        return p.has(t) || p.set(t, m++), p.get(t)
                    }

                    function g(t, e) {
                        return t.length === e.length && t.every((function(t, n) {
                            return t === e[n]
                        }))
                    }

                    function v(t) {
                        return 4 * Math.ceil(t / 4)
                    }

                    function y(t, e) {
                        e = e || 0;
                        var n = v(t.byteLength);
                        if (n !== t.byteLength) {
                            var i = new Uint8Array(n);
                            if (i.set(new Uint8Array(t)), 0 !== e)
                                for (var r = t.byteLength; r < n; r++) i[r] = e;
                            return i.buffer
                        }
                        return t
                    }

                    function x(t, e) {
                        if (0 !== Object.keys(t.userData).length) try {
                            var i = JSON.parse(JSON.stringify(t.userData));
                            if (n.includeCustomExtensions && i.gltfExtensions) {
                                for (var r in void 0 === e.extensions && (e.extensions = {}), i.gltfExtensions) e.extensions[r] = i.gltfExtensions[r], u[r] = !0;
                                delete i.gltfExtensions
                            }
                            Object.keys(i).length > 0 && (e.extras = i)
                        } catch (s) {
                            console.warn("THREE.GLTFExporter: userData of '" + t.name + "' won't be serialized because of JSON.stringify error - " + s.message)
                        }
                    }

                    function b(t, e) {
                        var n = !1,
                            i = {};
                        0 === e.offset.x && 0 === e.offset.y || (i.offset = e.offset.toArray(), n = !0), 0 !== e.rotation && (i.rotation = e.rotation, n = !0), 1 === e.repeat.x && 1 === e.repeat.y || (i.scale = e.repeat.toArray(), n = !0), n && (t.extensions = t.extensions || {}, t.extensions.KHR_texture_transform = i, u.KHR_texture_transform = !0)
                    }

                    function _(t) {
                        return s.buffers || (s.buffers = [{
                            byteLength: 0
                        }]), a.push(t), 0
                    }

                    function w(t, e, i, r) {
                        var a;
                        if (t.array.constructor === Float32Array) a = Qw.FLOAT;
                        else if (t.array.constructor === Uint32Array) a = Qw.UNSIGNED_INT;
                        else if (t.array.constructor === Uint16Array) a = Qw.UNSIGNED_SHORT;
                        else {
                            if (t.array.constructor !== Uint8Array) throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
                            a = Qw.UNSIGNED_BYTE
                        }
                        if (void 0 === i && (i = 0), void 0 === r && (r = t.count), n.truncateDrawRange && void 0 !== e && null === e.index) {
                            var l = i + r,
                                c = e.drawRange.count === 1 / 0 ? t.count : e.drawRange.start + e.drawRange.count;
                            i = Math.max(i, e.drawRange.start), (r = Math.min(l, c) - i) < 0 && (r = 0)
                        }
                        if (0 === r) return null;
                        var h, u = function(t, e, n) {
                            for (var i = {
                                    min: new Array(t.itemSize).fill(Number.POSITIVE_INFINITY),
                                    max: new Array(t.itemSize).fill(Number.NEGATIVE_INFINITY)
                                }, r = e; r < e + n; r++)
                                for (var s = 0; s < t.itemSize; s++) {
                                    var o = t.array[r * t.itemSize + s];
                                    i.min[s] = Math.min(i.min[s], o), i.max[s] = Math.max(i.max[s], o)
                                }
                            return i
                        }(t, i, r);
                        void 0 !== e && (h = t === e.index ? Qw.ELEMENT_ARRAY_BUFFER : Qw.ARRAY_BUFFER);
                        var d = function(t, e, n, i, r) {
                                var a;
                                s.bufferViews || (s.bufferViews = []), a = e === Qw.UNSIGNED_BYTE ? 1 : e === Qw.UNSIGNED_SHORT ? 2 : 4;
                                for (var l = v(i * t.itemSize * a), c = new DataView(new ArrayBuffer(l)), h = 0, u = n; u < n + i; u++)
                                    for (var d = 0; d < t.itemSize; d++) {
                                        var p;
                                        t.itemSize > 4 ? p = t.array[u * t.itemSize + d] : 0 === d ? p = t.getX(u) : 1 === d ? p = t.getY(u) : 2 === d ? p = t.getZ(u) : 3 === d && (p = t.getW(u)), e === Qw.FLOAT ? c.setFloat32(h, p, !0) : e === Qw.UNSIGNED_INT ? c.setUint32(h, p, !0) : e === Qw.UNSIGNED_SHORT ? c.setUint16(h, p, !0) : e === Qw.UNSIGNED_BYTE && c.setUint8(h, p), h += a
                                    }
                                var m = {
                                    buffer: _(c.buffer),
                                    byteOffset: o,
                                    byteLength: l
                                };
                                return void 0 !== r && (m.target = r), r === Qw.ARRAY_BUFFER && (m.byteStride = t.itemSize * a), o += l, s.bufferViews.push(m), {
                                    id: s.bufferViews.length - 1,
                                    byteLength: 0
                                }
                            }(t, a, i, r, h),
                            p = {
                                bufferView: d.id,
                                byteOffset: d.byteOffset,
                                componentType: a,
                                count: r,
                                max: u.max,
                                min: u.min,
                                type: {
                                    1: "SCALAR",
                                    2: "VEC2",
                                    3: "VEC3",
                                    4: "VEC4",
                                    16: "MAT4"
                                }[t.itemSize]
                            };
                        return !0 === t.normalized && (p.normalized = !0), s.accessors || (s.accessors = []), s.accessors.push(p), s.accessors.length - 1
                    }

                    function M(t, e, i) {
                        d.images.has(t) || d.images.set(t, {});
                        var a = d.images.get(t),
                            c = e === ne ? "image/png" : "image/jpeg",
                            h = c + ":flipY/" + i.toString();
                        if (void 0 !== a[h]) return a[h];
                        s.images || (s.images = []);
                        var u = {
                            mimeType: c
                        };
                        if (n.embedImages) {
                            var p = r = r || document.createElement("canvas");
                            p.width = Math.min(t.width, n.maxTextureSize), p.height = Math.min(t.height, n.maxTextureSize), n.forcePowerOfTwoTextures && ! function(t) {
                                return Pn.isPowerOfTwo(t.width) && Pn.isPowerOfTwo(t.height)
                            }(p) && (console.warn("GLTFExporter: Resized non-power-of-two image.", t), p.width = Pn.floorPowerOfTwo(p.width), p.height = Pn.floorPowerOfTwo(p.height));
                            var m = p.getContext("2d");
                            !0 === i && (m.translate(0, p.height), m.scale(1, -1)), m.drawImage(t, 0, 0, p.width, p.height), !0 === n.binary ? l.push(new Promise((function(t) {
                                p.toBlob((function(e) {
                                    (function(t) {
                                        return s.bufferViews || (s.bufferViews = []), new Promise((function(e) {
                                            var n = new window.FileReader;
                                            n.readAsArrayBuffer(t), n.onloadend = function() {
                                                var t = y(n.result),
                                                    i = {
                                                        buffer: _(t),
                                                        byteOffset: o,
                                                        byteLength: t.byteLength
                                                    };
                                                o += t.byteLength, s.bufferViews.push(i), e(s.bufferViews.length - 1)
                                            }
                                        }))
                                    })(e).then((function(e) {
                                        u.bufferView = e, t()
                                    }))
                                }), c)
                            }))) : u.uri = p.toDataURL(c)
                        } else u.uri = t.src;
                        s.images.push(u);
                        var f = s.images.length - 1;
                        return a[h] = f, f
                    }

                    function S(t) {
                        s.samplers || (s.samplers = []);
                        var e = {
                            magFilter: tM[t.magFilter],
                            minFilter: tM[t.minFilter],
                            wrapS: tM[t.wrapS],
                            wrapT: tM[t.wrapT]
                        };
                        return s.samplers.push(e), s.samplers.length - 1
                    }

                    function T(t) {
                        if (d.textures.has(t)) return d.textures.get(t);
                        s.textures || (s.textures = []);
                        var e = {
                            sampler: S(t),
                            source: M(t.image, t.format, t.flipY)
                        };
                        t.name && (e.name = t.name), s.textures.push(e);
                        var n = s.textures.length - 1;
                        return d.textures.set(t, n), n
                    }

                    function E(t) {
                        if (d.materials.has(t)) return d.materials.get(t);
                        if (t.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
                        s.materials || (s.materials = []);
                        var e = {
                            pbrMetallicRoughness: {}
                        };
                        t.isMeshBasicMaterial ? (e.extensions = {
                            KHR_materials_unlit: {}
                        }, u.KHR_materials_unlit = !0) : t.isGLTFSpecularGlossinessMaterial ? (e.extensions = {
                            KHR_materials_pbrSpecularGlossiness: {}
                        }, u.KHR_materials_pbrSpecularGlossiness = !0) : t.isMeshStandardMaterial || console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
                        var n = t.color.toArray().concat([t.opacity]);
                        if (g(n, [1, 1, 1, 1]) || (e.pbrMetallicRoughness.baseColorFactor = n), t.isMeshStandardMaterial ? (e.pbrMetallicRoughness.metallicFactor = t.metalness, e.pbrMetallicRoughness.roughnessFactor = t.roughness) : t.isMeshBasicMaterial ? (e.pbrMetallicRoughness.metallicFactor = 0, e.pbrMetallicRoughness.roughnessFactor = .9) : (e.pbrMetallicRoughness.metallicFactor = .5, e.pbrMetallicRoughness.roughnessFactor = .5), t.isGLTFSpecularGlossinessMaterial) {
                            e.pbrMetallicRoughness.baseColorFactor && (e.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor = e.pbrMetallicRoughness.baseColorFactor);
                            var i = [1, 1, 1];
                            t.specular.toArray(i, 0), e.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor = i, e.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor = t.glossiness
                        }
                        if (t.metalnessMap || t.roughnessMap)
                            if (t.metalnessMap === t.roughnessMap) {
                                var r = {
                                    index: T(t.metalnessMap)
                                };
                                b(r, t.metalnessMap), e.pbrMetallicRoughness.metallicRoughnessTexture = r
                            } else console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");
                        if (t.map) {
                            var o = {
                                index: T(t.map)
                            };
                            b(o, t.map), t.isGLTFSpecularGlossinessMaterial && (e.extensions.KHR_materials_pbrSpecularGlossiness.diffuseTexture = o), e.pbrMetallicRoughness.baseColorTexture = o
                        }
                        if (t.isGLTFSpecularGlossinessMaterial && t.specularMap) {
                            var a = {
                                index: T(t.specularMap)
                            };
                            b(a, t.specularMap), e.extensions.KHR_materials_pbrSpecularGlossiness.specularGlossinessTexture = a
                        }
                        if (t.emissive) {
                            var l = t.emissive.clone().multiplyScalar(t.emissiveIntensity).toArray();
                            if (g(l, [0, 0, 0]) || (e.emissiveFactor = l), t.emissiveMap) {
                                var c = {
                                    index: T(t.emissiveMap)
                                };
                                b(c, t.emissiveMap), e.emissiveTexture = c
                            }
                        }
                        if (t.normalMap) {
                            var h = {
                                index: T(t.normalMap)
                            };
                            t.normalScale && -1 !== t.normalScale.x && (t.normalScale.x !== t.normalScale.y && console.warn("THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X."), h.scale = t.normalScale.x), b(h, t.normalMap), e.normalTexture = h
                        }
                        if (t.aoMap) {
                            var p = {
                                index: T(t.aoMap),
                                texCoord: 1
                            };
                            1 !== t.aoMapIntensity && (p.strength = t.aoMapIntensity), b(p, t.aoMap), e.occlusionTexture = p
                        }
                        t.transparent ? e.alphaMode = "BLEND" : t.alphaTest > 0 && (e.alphaMode = "MASK", e.alphaCutoff = t.alphaTest), t.side === H && (e.doubleSided = !0), "" !== t.name && (e.name = t.name), x(t, e), s.materials.push(e);
                        var m = s.materials.length - 1;
                        return d.materials.set(t, m), m
                    }

                    function A(t) {
                        var e = [t.geometry.uuid];
                        if (Array.isArray(t.material))
                            for (var n = 0, i = t.material.length; n < i; n++) e.push(t.material[n].uuid);
                        else e.push(t.material.uuid);
                        var r = e.join(":");
                        if (d.meshes.has(r)) return d.meshes.get(r);
                        var o, a = t.geometry;
                        o = t.isLineSegments ? Qw.LINES : t.isLineLoop ? Qw.LINE_LOOP : t.isLine ? Qw.LINE_STRIP : t.isPoints ? Qw.POINTS : t.material.wireframe ? Qw.LINES : Qw.TRIANGLES, a.isBufferGeometry || (console.warn("GLTFExporter: Exporting THREE.Geometry will increase file size. Use BufferGeometry instead."), a = (new Nr).setFromObject(t));
                        var l = {},
                            c = {},
                            h = [],
                            u = [],
                            p = {
                                uv: "TEXCOORD_0",
                                uv2: "TEXCOORD_1",
                                color: "COLOR_0",
                                skinWeight: "WEIGHTS_0",
                                skinIndex: "JOINTS_0"
                            },
                            m = a.getAttribute("normal");
                        void 0 === m || function(t) {
                            if (d.attributesNormalized.has(t)) return !1;
                            for (var e = new Hn, n = 0, i = t.count; n < i; n++)
                                if (Math.abs(e.fromArray(t.array, 3 * n).length() - 1) > 5e-4) return !1;
                            return !0
                        }(m) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), a.setAttribute("normal", function(t) {
                            if (d.attributesNormalized.has(t)) return d.attributesNormalized.get(t);
                            for (var e = t.clone(), n = new Hn, i = 0, r = e.count; i < r; i++) n.fromArray(e.array, 3 * i), 0 === n.x && 0 === n.y && 0 === n.z ? n.setX(1) : n.normalize(), n.toArray(e.array, 3 * i);
                            return d.attributesNormalized.set(t, e), e
                        }(m)));
                        var g = null;
                        for (var v in a.attributes)
                            if ("morph" !== v.substr(0, 5)) {
                                var y = a.attributes[v];
                                v = p[v] || v.toUpperCase();
                                if (/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(v) || (v = "_" + v), d.attributes.has(f(y))) c[v] = d.attributes.get(f(y));
                                else {
                                    g = null;
                                    var b = y.array;
                                    "JOINTS_0" !== v || b instanceof Uint16Array || b instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), g = new fr(new Uint16Array(b), y.itemSize, y.normalized));
                                    var _ = w(g || y, a);
                                    null !== _ && (c[v] = _, d.attributes.set(f(y), _))
                                }
                            }
                        if (void 0 !== m && a.setAttribute("normal", m), 0 === Object.keys(c).length) return null;
                        if (void 0 !== t.morphTargetInfluences && t.morphTargetInfluences.length > 0) {
                            var M = [],
                                S = [],
                                T = {};
                            if (void 0 !== t.morphTargetDictionary)
                                for (var A in t.morphTargetDictionary) T[t.morphTargetDictionary[A]] = A;
                            for (n = 0; n < t.morphTargetInfluences.length; ++n) {
                                var L = {},
                                    R = !1;
                                for (var v in a.morphAttributes)
                                    if ("position" === v || "normal" === v) {
                                        y = a.morphAttributes[v][n];
                                        var P = v.toUpperCase(),
                                            C = a.attributes[v];
                                        if (d.attributes.has(f(y))) L[P] = d.attributes.get(f(y));
                                        else {
                                            var O = y.clone();
                                            if (!a.morphTargetsRelative)
                                                for (var I = 0, N = y.count; I < N; I++) O.setXYZ(I, y.getX(I) - C.getX(I), y.getY(I) - C.getY(I), y.getZ(I) - C.getZ(I));
                                            L[P] = w(O, a), d.attributes.set(f(C), L[P])
                                        }
                                    } else R || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), R = !0);
                                u.push(L), M.push(t.morphTargetInfluences[n]), void 0 !== t.morphTargetDictionary && S.push(T[n])
                            }
                            l.weights = M, S.length > 0 && (l.extras = {}, l.extras.targetNames = S)
                        }
                        var D = Array.isArray(t.material);
                        if (D && 0 === a.groups.length) return null;
                        for (var F = D ? t.material : [t.material], U = D ? a.groups : [{
                                materialIndex: 0,
                                start: void 0,
                                count: void 0
                            }], z = (n = 0, U.length); n < z; n++) {
                            var k = {
                                mode: o,
                                attributes: c
                            };
                            if (x(a, k), u.length > 0 && (k.targets = u), null !== a.index) {
                                var B = f(a.index);
                                void 0 === U[n].start && void 0 === U[n].count || (B += ":" + U[n].start + ":" + U[n].count), d.attributes.has(B) ? k.indices = d.attributes.get(B) : (k.indices = w(a.index, a, U[n].start, U[n].count), d.attributes.set(B, k.indices)), null === k.indices && delete k.indices
                            }
                            var H = E(F[U[n].materialIndex]);
                            null !== H && (k.material = H), h.push(k)
                        }
                        l.primitives = h, s.meshes || (s.meshes = []), s.meshes.push(l);
                        var G = s.meshes.length - 1;
                        return d.meshes.set(r, G), G
                    }

                    function L(t, e) {
                        s.animations || (s.animations = []);
                        for (var n = (t = nM.Utils.mergeMorphTargetTracks(t.clone(), e)).tracks, i = [], r = [], o = 0; o < n.length; ++o) {
                            var a = n[o],
                                l = uu.parseTrackName(a.name),
                                h = uu.findNode(e, l.nodeName),
                                u = eM[l.propertyName];
                            if ("bones" === l.objectName && (h = !0 === h.isSkinnedMesh ? h.skeleton.getBoneByName(l.objectIndex) : void 0), !h || !u) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', a.name), null;
                            var d, p = a.values.length / a.times.length;
                            u === eM.morphTargetInfluences && (p /= h.morphTargetInfluences.length), !0 === a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (d = "CUBICSPLINE", p /= 3) : d = a.getInterpolation() === rn ? "STEP" : "LINEAR", r.push({
                                input: w(new fr(a.times, 1)),
                                output: w(new fr(a.values, p)),
                                interpolation: d
                            }), i.push({
                                sampler: r.length - 1,
                                target: {
                                    node: c.get(h),
                                    path: u
                                }
                            })
                        }
                        return s.animations.push({
                            name: t.name || "clip_" + s.animations.length,
                            samplers: r,
                            channels: i
                        }), s.animations.length - 1
                    }

                    function R(t) {
                        var e = s.nodes[c.get(t)],
                            n = t.skeleton;
                        if (void 0 === n) return null;
                        var i = t.skeleton.bones[0];
                        if (void 0 === i) return null;
                        for (var r = [], o = new Float32Array(16 * n.bones.length), a = 0; a < n.bones.length; ++a) r.push(c.get(n.bones[a])), n.boneInverses[a].toArray(o, 16 * a);
                        return void 0 === s.skins && (s.skins = []), s.skins.push({
                            inverseBindMatrices: w(new fr(o, 16)),
                            joints: r,
                            skeleton: c.get(i)
                        }), e.skin = s.skins.length - 1
                    }

                    function P(t) {
                        var e = {};
                        t.name && (e.name = t.name), e.color = t.color.toArray(), e.intensity = t.intensity, t.isDirectionalLight ? e.type = "directional" : t.isPointLight ? (e.type = "point", t.distance > 0 && (e.range = t.distance)) : t.isSpotLight && (e.type = "spot", t.distance > 0 && (e.range = t.distance), e.spot = {}, e.spot.innerConeAngle = (t.penumbra - 1) * t.angle * -1, e.spot.outerConeAngle = t.angle), void 0 !== t.decay && 2 !== t.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !t.target || t.target.parent === t && 0 === t.target.position.x && 0 === t.target.position.y && -1 === t.target.position.z || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.");
                        var n = s.extensions.KHR_lights_punctual.lights;
                        return n.push(e), n.length - 1
                    }

                    function C(t) {
                        s.nodes || (s.nodes = []);
                        var e = {};
                        if (n.trs) {
                            var i = t.quaternion.toArray(),
                                r = t.position.toArray(),
                                o = t.scale.toArray();
                            g(i, [0, 0, 0, 1]) || (e.rotation = i), g(r, [0, 0, 0]) || (e.translation = r), g(o, [1, 1, 1]) || (e.scale = o)
                        } else t.matrixAutoUpdate && t.updateMatrix(), g(t.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) || (e.matrix = t.matrix.elements);
                        if ("" !== t.name && (e.name = String(t.name)), x(t, e), t.isMesh || t.isLine || t.isPoints) {
                            var a = A(t);
                            null !== a && (e.mesh = a)
                        } else if (t.isCamera) e.camera = function(t) {
                            s.cameras || (s.cameras = []);
                            var e = t.isOrthographicCamera,
                                n = {
                                    type: e ? "orthographic" : "perspective"
                                };
                            return e ? n.orthographic = {
                                xmag: 2 * t.right,
                                ymag: 2 * t.top,
                                zfar: t.far <= 0 ? .001 : t.far,
                                znear: t.near < 0 ? 0 : t.near
                            } : n.perspective = {
                                aspectRatio: t.aspect,
                                yfov: Pn.degToRad(t.fov),
                                zfar: t.far <= 0 ? .001 : t.far,
                                znear: t.near < 0 ? 0 : t.near
                            }, "" !== t.name && (n.name = t.type), s.cameras.push(n), s.cameras.length - 1
                        }(t);
                        else if (t.isDirectionalLight || t.isPointLight || t.isSpotLight) u.KHR_lights_punctual || (s.extensions = s.extensions || {}, s.extensions.KHR_lights_punctual = {
                            lights: []
                        }, u.KHR_lights_punctual = !0), e.extensions = e.extensions || {}, e.extensions.KHR_lights_punctual = {
                            light: P(t)
                        };
                        else if (t.isLight) return console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", t), null;
                        if (t.isSkinnedMesh && h.push(t), t.children.length > 0) {
                            for (var l = [], d = 0, p = t.children.length; d < p; d++) {
                                var m = t.children[d];
                                if (m.visible || !1 === n.onlyVisible) {
                                    var f = C(m);
                                    null !== f && l.push(f)
                                }
                            }
                            l.length > 0 && (e.children = l)
                        }
                        s.nodes.push(e);
                        var v = s.nodes.length - 1;
                        return c.set(t, v), v
                    }

                    function O(t) {
                        s.scenes || (s.scenes = [], s.scene = 0);
                        var e = {};
                        "" !== t.name && (e.name = t.name), s.scenes.push(e);
                        for (var i = [], r = 0, o = t.children.length; r < o; r++) {
                            var a = t.children[r];
                            if (a.visible || !1 === n.onlyVisible) {
                                var l = C(a);
                                null !== l && i.push(l)
                            }
                        }
                        i.length > 0 && (e.nodes = i), x(t, e)
                    }! function(t) {
                        t = t instanceof Array ? t : [t];
                        for (var e = [], i = 0; i < t.length; i++) t[i] instanceof Pa ? O(t[i]) : e.push(t[i]);
                        for (e.length > 0 && function(t) {
                                var e = new Pa;
                                e.name = "AuxScene";
                                for (var n = 0; n < t.length; n++) e.children.push(t[n]);
                                O(e)
                            }(e), i = 0; i < h.length; ++i) R(h[i]);
                        for (i = 0; i < n.animations.length; ++i) L(n.animations[i], t[0])
                    }(t), Promise.all(l).then((function() {
                        var t = new Blob(a, {
                                type: "application/octet-stream"
                            }),
                            i = Object.keys(u);
                        if (i.length > 0 && (s.extensionsUsed = i), s.buffers && s.buffers.length > 0 && (s.buffers[0].byteLength = t.size), !0 === n.binary) {
                            (r = new window.FileReader).readAsArrayBuffer(t), r.onloadend = function() {
                                var t = y(r.result),
                                    n = new DataView(new ArrayBuffer(8));
                                n.setUint32(0, t.byteLength, !0), n.setUint32(4, 5130562, !0);
                                var i = y(function(t) {
                                        if (void 0 !== window.TextEncoder) return (new TextEncoder).encode(t).buffer;
                                        for (var e = new Uint8Array(new ArrayBuffer(t.length)), n = 0, i = t.length; n < i; n++) {
                                            var r = t.charCodeAt(n);
                                            e[n] = r > 255 ? 32 : r
                                        }
                                        return e.buffer
                                    }(JSON.stringify(s)), 32),
                                    o = new DataView(new ArrayBuffer(8));
                                o.setUint32(0, i.byteLength, !0), o.setUint32(4, 1313821514, !0);
                                var a = new ArrayBuffer(12),
                                    l = new DataView(a);
                                l.setUint32(0, 1179937895, !0), l.setUint32(4, 2, !0);
                                var c = 12 + o.byteLength + i.byteLength + n.byteLength + t.byteLength;
                                l.setUint32(8, c, !0);
                                var h = new Blob([a, o, i, n, t], {
                                        type: "application/octet-stream"
                                    }),
                                    u = new window.FileReader;
                                u.readAsArrayBuffer(h), u.onloadend = function() {
                                    e(u.result)
                                }
                            }
                        } else {
                            var r;
                            if (s.buffers && s.buffers.length > 0)(r = new window.FileReader).readAsDataURL(t), r.onloadend = function() {
                                var t = r.result;
                                s.buffers[0].uri = t, e(s)
                            };
                            else e(s)
                        }
                    }))
                }
            }, nM.Utils = {
                insertKeyframe: function(t, e) {
                    var n, i = t.getValueSize(),
                        r = new t.TimeBufferType(t.times.length + 1),
                        s = new t.ValueBufferType(t.values.length + i),
                        o = t.createInterpolant(new t.ValueBufferType(i));
                    if (0 === t.times.length) {
                        r[0] = e;
                        for (var a = 0; a < i; a++) s[a] = 0;
                        n = 0
                    } else if (e < t.times[0]) {
                        if (Math.abs(t.times[0] - e) < .001) return 0;
                        r[0] = e, r.set(t.times, 1), s.set(o.evaluate(e), 0), s.set(t.values, i), n = 0
                    } else if (e > t.times[t.times.length - 1]) {
                        if (Math.abs(t.times[t.times.length - 1] - e) < .001) return t.times.length - 1;
                        r[r.length - 1] = e, r.set(t.times, 0), s.set(t.values, 0), s.set(o.evaluate(e), t.values.length), n = r.length - 1
                    } else
                        for (a = 0; a < t.times.length; a++) {
                            if (Math.abs(t.times[a] - e) < .001) return a;
                            if (t.times[a] < e && t.times[a + 1] > e) {
                                r.set(t.times.slice(0, a + 1), 0), r[a + 1] = e, r.set(t.times.slice(a + 1), a + 2), s.set(t.values.slice(0, (a + 1) * i), 0), s.set(o.evaluate(e), (a + 1) * i), s.set(t.values.slice((a + 1) * i), (a + 2) * i), n = a + 1;
                                break
                            }
                        }
                    return t.times = r, t.values = s, n
                },
                mergeMorphTargetTracks: function(t, e) {
                    for (var n = [], i = {}, r = t.tracks, s = 0; s < r.length; ++s) {
                        var o = r[s],
                            a = uu.parseTrackName(o.name),
                            l = uu.findNode(e, a.nodeName);
                        if ("morphTargetInfluences" === a.propertyName && void 0 !== a.propertyIndex) {
                            if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) {
                                if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
                                console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), (o = o.clone()).setInterpolation(2301)
                            }
                            var c, h = l.morphTargetInfluences.length,
                                u = l.morphTargetDictionary[a.propertyIndex];
                            if (void 0 === u) throw new Error("THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex);
                            if (void 0 !== i[l.uuid]) {
                                var d = o.createInterpolant(new o.ValueBufferType(1));
                                c = i[l.uuid];
                                for (f = 0; f < c.times.length; f++) c.values[f * h + u] = d.evaluate(c.times[f]);
                                for (f = 0; f < o.times.length; f++) {
                                    var p = this.insertKeyframe(c, o.times[f]);
                                    c.values[p * h + u] = o.values[f]
                                }
                            } else {
                                for (var m = new((c = o.clone()).ValueBufferType)(h * c.times.length), f = 0; f < c.times.length; f++) m[f * h + u] = c.values[f];
                                c.name = a.nodeName + ".morphTargetInfluences", c.values = m, i[l.uuid] = c, n.push(c)
                            }
                        } else n.push(o)
                    }
                    return t.tracks = n, t
                }
            };
            var iM = function(t, e, n, i) {
                for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)(r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
                return s > 3 && o && Object.defineProperty(e, n, o), o
            };
            const rM = Symbol("updateThreeSide"),
                sM = Symbol("currentGLTF"),
                oM = Symbol("modelGraft"),
                aM = Symbol("mainPort"),
                lM = Symbol("threePort"),
                cM = Symbol("manipulator"),
                hM = Symbol("modelKernel"),
                uM = Symbol("onModelChange"),
                dM = Symbol("onModelGraftMutation");
            var pM = function(t, e, n, i) {
                for (var r, s = arguments.length, o = s < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i, a = t.length - 1; a >= 0; a--)(r = t[a]) && (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
                return s > 3 && o && Object.defineProperty(e, n, o), o
            };
            const mM = Math.PI / 32,
                fM = 3e3,
                gM = {
                    basis: [Fd(Ed(mM, "rad"))],
                    keywords: {
                        auto: [null]
                    }
                },
                vM = Symbol("autoRotateStartTime"),
                yM = Symbol("radiansPerSecond"),
                xM = Symbol("syncRotationRate"),
                bM = Symbol("cameraChangeHandler"),
                _M = Symbol("onCameraChange"),
                wM = (t => {
                    var e, n, i, r;
                    return class extends t {
                        constructor(...t) {
                            super(...t), this[e] = new Td, this[n] = new Map, this[i] = t => {
                                t.forEach(t => {
                                    t instanceof MutationRecord && "childList" !== t.type || (t.addedNodes.forEach(t => {
                                        this[vv](t)
                                    }), t.removedNodes.forEach(t => {
                                        this[yv](t)
                                    }), this[Zg]())
                                })
                            }, this[r] = new MutationObserver(this[fv]);
                            const {
                                domElement: s
                            } = this[pv], {
                                style: o
                            } = s;
                            o.display = "none", o.pointerEvents = "none", o.position = "absolute", o.top = "0", this.shadowRoot.querySelector(".default").appendChild(s)
                        }
                        connectedCallback() {
                            super.connectedCallback();
                            for (let e = 0; e < this.children.length; ++e) this[vv](this.children[e]);
                            const {
                                ShadyDOM: t
                            } = self;
                            null == t ? this[gv].observe(this, {
                                childList: !0
                            }) : this[gv] = t.observeChildren(this, this[fv])
                        }
                        disconnectedCallback() {
                            super.disconnectedCallback();
                            const {
                                ShadyDOM: t
                            } = self;
                            null == t ? this[gv].disconnect() : t.unobserveChildren(this[gv])
                        }
                        updateHotspot(t) {
                            const e = this[mv].get(t.name);
                            null != e && (e.updatePosition(t.position), e.updateNormal(t.normal))
                        }
                        positionAndNormalFromPoint(t, e) {
                            const n = this[Jg],
                                {
                                    width: i,
                                    height: r,
                                    model: s
                                } = n;
                            xv.set(t / i, e / r).multiplyScalar(2).subScalar(1), xv.y *= -1;
                            const o = n.positionAndNormalFromPoint(xv);
                            if (null == o) return null;
                            bv.getInverse(s.matrixWorld);
                            const a = av(o.position.applyMatrix4(bv));
                            return _v.getNormalMatrix(bv), {
                                position: a,
                                normal: av(o.normal.applyNormalMatrix(_v))
                            }
                        }[(e = pv, n = mv, i = fv, r = gv, Kg)](t, e) {
                            super[Kg](t, e);
                            const n = this[Jg],
                                i = n.getCamera();
                            n.isDirty && (n.model.updateHotspots(i.position), this[pv].domElement.style.display = "", this[pv].render(n, i))
                        }[Qg](t) {
                            super[Qg](t), this[pv].setSize(t.width, t.height)
                        }[vv](t) {
                            if (!(t instanceof HTMLElement && 0 === t.slot.indexOf("hotspot"))) return;
                            let e = this[mv].get(t.slot);
                            null != e ? e.increment() : (e = new kd({
                                name: t.slot,
                                position: t.dataset.position,
                                normal: t.dataset.normal
                            }), this[mv].set(t.slot, e), this[Jg].model.addHotspot(e), this[pv].domElement.appendChild(e.element)), this[Jg].isDirty = !0
                        }[yv](t) {
                            if (!(t instanceof HTMLElement)) return;
                            const e = this[mv].get(t.slot);
                            e && (e.decrement() && (this[Jg].model.removeHotspot(e), this[mv].delete(t.slot)), this[Jg].isDirty = !0)
                        }
                    }
                })((t => {
                    var e, n, i, r, s, o, a, l;
                    class c extends t {
                        constructor() {
                            super(...arguments), this[l] = null, this[e] = null, this[n] = null, this[i] = null, this[r] = null, this[s] = null, this[o] = t => {
                                const {
                                    data: e
                                } = t;
                                if (e && e.type === Fb.MODEL_CHANGE) {
                                    const t = e.model,
                                        n = this[hM];
                                    if (null != n) n.deactivate();
                                    else if (null == t) return;
                                    this[hM] = null != t ? new B_(e.port, t) : null, this.dispatchEvent(new CustomEvent("scene-graph-ready", {
                                        detail: {
                                            url: t ? t.modelUri : null
                                        }
                                    }))
                                }
                            }, this[a] = t => {
                                this[Zg]()
                            }
                        }
                        get model() {
                            const t = this[hM];
                            return t ? t.model : void 0
                        }
                        connectedCallback() {
                            super.connectedCallback();
                            const {
                                port1: t,
                                port2: e
                            } = new MessageChannel;
                            t.start(), e.start(), this[aM] = t, this[lM] = e, this[aM].onmessage = this[uM]
                        }
                        disconnectedCallback() {
                            super.disconnectedCallback(), this[aM].close(), this[lM].close(), this[aM] = null, this[lM] = null, null != this[cM] && this[cM].dispose(), null != this[hM] && this[hM].deactivate()
                        }
                        updated(t) {
                            if (super.updated(t), t.has(oM)) {
                                const e = t.get(oM);
                                null != e && e.removeEventListener("mutation", this[dM]);
                                const n = this[oM];
                                null != n && n.addEventListener("mutation", this[dM])
                            }
                        }[(l = oM, e = sM, n = aM, i = lM, r = cM, s = hM, $g)]() {
                            super[$g](), this[rM]()
                        }[rM]() {
                            const t = this[Jg],
                                {
                                    model: e
                                } = t,
                                {
                                    currentGLTF: n
                                } = e;
                            let i = null,
                                r = null;
                            if (null != n) {
                                const {
                                    correlatedSceneGraph: t
                                } = n, s = this[oM], o = this[cM];
                                if (null != t) {
                                    if (null != o && o.dispose(), null != s && n === this[sM]) return;
                                    i = new $w(e.url || "", t);
                                    let a = null;
                                    null != i && null != i.model ? (a = new MessageChannel, r = new W_(i, a.port1), this[lM].postMessage({
                                        type: Fb.MODEL_CHANGE,
                                        model: i.model.toJSON(),
                                        port: a.port2
                                    }, [a.port2])) : this[lM].postMessage({
                                        type: Fb.MODEL_CHANGE,
                                        model: null,
                                        port: null
                                    })
                                }
                            }
                            this[oM] = i, this[cM] = r, this[sM] = n
                        }
                        async exportScene(t) {
                            const {
                                model: e
                            } = this[Jg];
                            return new Promise(async (n, i) => {
                                if (null == e) return i("Model missing or not yet loaded");
                                const r = {
                                    binary: !0,
                                    onlyVisible: !0,
                                    maxTextureSize: 1 / 0,
                                    forcePowerOfTwoTextures: !1,
                                    includeCustomExtensions: !1,
                                    embedImages: !0
                                };
                                Object.assign(r, t), r.animations = e.animations, r.truncateDrawRange = !0;
                                const s = e[$d];
                                let o = !1;
                                null != s && (o = s.visible, s.visible = !1), (new nM).parse(e.modelContainer, t => n(new Blob([r.binary ? t : JSON.stringify(t)], {
                                    type: r.binary ? "application/octet-stream" : "application/json"
                                })), r), null != s && (s.visible = o)
                            })
                        }
                    }
                    return o = uM, a = dM, iM([f({
                        type: Object
                    })], c.prototype, l, void 0), c
                })((t => {
                    var e, n, i;
                    class r extends t {
                        constructor() {
                            super(...arguments), this.autoRotate = !1, this.autoRotateDelay = fM, this.rotationPerSecond = "auto", this[e] = performance.now(), this[n] = 0, this[i] = t => this[_M](t)
                        }
                        connectedCallback() {
                            super.connectedCallback(), this.addEventListener("camera-change", this[bM]), this[vM] = performance.now()
                        }
                        disconnectedCallback() {
                            super.disconnectedCallback(), this.removeEventListener("camera-change", this[bM]), this[vM] = performance.now()
                        }
                        updated(t) {
                            super.updated(t), t.has("autoRotate") && (this[vM] = performance.now())
                        }[(e = vM, n = yM, i = bM, xM)](t) {
                            this[yM] = t[0]
                        }[Kg](t, e) {
                            if (super[Kg](t, e), !this.autoRotate || !this[ov]() || this[tv].isPresenting) return;
                            const n = Math.min(e, t - this[vM] - this.autoRotateDelay);
                            n > 0 && (this[Jg].yaw = this.turntableRotation + this[yM] * n * .001)
                        }[_M](t) {
                            this.autoRotate && "user-interaction" === t.detail.source && (this[vM] = performance.now())
                        }
                        get turntableRotation() {
                            return this[Jg].yaw
                        }
                        resetTurntableRotation(t = 0) {
                            this[Jg].yaw = t
                        }
                    }
                    return pM([f({
                        type: Boolean,
                        attribute: "auto-rotate"
                    })], r.prototype, "autoRotate", void 0), pM([f({
                        type: Number,
                        attribute: "auto-rotate-delay"
                    })], r.prototype, "autoRotateDelay", void 0), pM([Py({
                        intrinsics: gM,
                        updateHandler: xM
                    }), f({
                        type: String,
                        attribute: "rotation-per-second"
                    })], r.prototype, "rotationPerSecond", void 0), r
                })((t => {
                    var e, n, i;
                    class r extends t {
                        constructor() {
                            super(...arguments), this.environmentImage = null, this.skyboxImage = null, this.shadowIntensity = Xx, this.shadowSoftness = Yx, this.exposure = Jx, this[e] = null, this[n] = null, this[i] = t => {
                                t.element === this && this[$x]()
                            }
                        }
                        connectedCallback() {
                            super.connectedCallback(), this[tv].loader.addEventListener("preload", this[tb])
                        }
                        disconnectedCallback() {
                            super.disconnectedCallback(), this[tv].loader.removeEventListener("preload", this[tb])
                        }
                        updated(t) {
                            super.updated(t), t.has("shadowIntensity") && (this[Jg].setShadowIntensity(this.shadowIntensity * qx), this[Zg]()), t.has("shadowSoftness") && (this[Jg].setShadowSoftness(this.shadowSoftness), this[Zg]()), t.has("exposure") && (this[Jg].exposure = this.exposure, this[Zg]()), (t.has("environmentImage") || t.has("skyboxImage")) && this[rv]() && this[$x]()
                        }[(e = Zx, n = Qx, i = tb, $g)]() {
                            super[$g](), null != this[Zx] && this[Kx](this[Zx])
                        }
                        async [$x]() {
                            const {
                                skyboxImage: t,
                                environmentImage: e
                            } = this;
                            null != this[Qx] && (this[Qx](), this[Qx] = null);
                            const {
                                textureUtils: n
                            } = this[tv];
                            if (null != n) try {
                                const {
                                    environmentMap: i,
                                    skybox: r
                                } = await new Promise(async (i, r) => {
                                    const s = n.generateEnvironmentMapAndSkybox(fp(t), fp(e), {
                                        progressTracker: this[ev]
                                    });
                                    this[Qx] = () => r(s), i(await s)
                                }), s = i.texture;
                                this[Jg].background = null != r ? r.userData.url === s.userData.url ? s : r : null, this[Kx](i.texture), this[Jg].model.dispatchEvent({
                                    type: "envmap-update"
                                })
                            } catch (i) {
                                if (i instanceof Error) throw this[Kx](null), i
                            }
                        }[Kx](t) {
                            this[Zx] = t, this[Jg].environment = this[Zx], this.dispatchEvent(new CustomEvent("environment-change")), this[Zg]()
                        }
                    }
                    return Wx([f({
                        type: String,
                        attribute: "environment-image"
                    })], r.prototype, "environmentImage", void 0), Wx([f({
                        type: String,
                        attribute: "skybox-image"
                    })], r.prototype, "skyboxImage", void 0), Wx([f({
                        type: Number,
                        attribute: "shadow-intensity"
                    })], r.prototype, "shadowIntensity", void 0), Wx([f({
                        type: Number,
                        attribute: "shadow-softness"
                    })], r.prototype, "shadowSoftness", void 0), Wx([f({
                        type: Number
                    })], r.prototype, "exposure", void 0), r
                })((t => {
                    var e, n, i, r, s, o, a, l, c, h, u, d, p, m, g, v, y;
                    class x extends t {
                        constructor() {
                            super(...arguments), this.cameraControls = !1, this.cameraOrbit = Wy, this.cameraTarget = qy, this.fieldOfView = Xy, this.minCameraOrbit = "auto", this.maxCameraOrbit = "auto", this.minFieldOfView = "auto", this.maxFieldOfView = "auto", this.interactionPromptThreshold = Ky, this.interactionPromptStyle = tx.WIGGLE, this.interactionPrompt = Qy.AUTO, this.interactionPolicy = ex.ALWAYS_ALLOW, this.orbitSensitivity = 1, this.touchAction = nx.PAN_Y, this[e] = this.shadowRoot.querySelector(".interaction-prompt"), this[n] = this.shadowRoot.querySelector(".interaction-prompt > .animated-container"), this[i] = 1 / 0, this[r] = 0, this[s] = 1 / 0, this[o] = !1, this[a] = !1, this[l] = new Uy(this[Jg].camera, this[Xg]), this[c] = 0, this[h] = new bu, this[u] = !1, this[d] = !1, this[p] = !1, this[m] = t => this[Ex](t), this[g] = t => this[Ax](t), this[v] = () => this[Tx](), this[y] = () => this[Sx]()
                        }
                        getCameraOrbit() {
                            const {
                                theta: t,
                                phi: e,
                                radius: n
                            } = this[Nx];
                            return {
                                theta: t,
                                phi: e,
                                radius: n
                            }
                        }
                        getCameraTarget() {
                            return av(this[Jg].getTarget())
                        }
                        getFieldOfView() {
                            return this[mx].getFieldOfView()
                        }
                        getMinimumFieldOfView() {
                            return this[mx].options.minimumFieldOfView
                        }
                        getMaximumFieldOfView() {
                            return this[mx].options.maximumFieldOfView
                        }
                        jumpCameraToGoal() {
                            this[Dx] = !0, this.requestUpdate(Dx, !1)
                        }
                        resetInteractionPrompt() {
                            this[Cx] = 0, this[Px] = 1 / 0, this[Rx] = !1, this[Lx] = this.interactionPrompt === Qy.AUTO && this.cameraControls
                        }
                        connectedCallback() {
                            super.connectedCallback(), this[mx].addEventListener("change", this[wx]), this[mx].addEventListener("pointer-change-start", this[Mx]), this[mx].addEventListener("pointer-change-end", this[Mx])
                        }
                        disconnectedCallback() {
                            super.disconnectedCallback(), this[mx].removeEventListener("change", this[wx]), this[mx].removeEventListener("pointer-change-start", this[Mx]), this[mx].removeEventListener("pointer-change-end", this[Mx])
                        }
                        updated(t) {
                            super.updated(t);
                            const e = this[mx],
                                n = this[Xg];
                            if (t.has("cameraControls") && (this.cameraControls ? (e.enableInteraction(), this.interactionPrompt === Qy.AUTO && (this[Lx] = !0), n.addEventListener("focus", this[_x]), n.addEventListener("blur", this[bx])) : (n.removeEventListener("focus", this[_x]), n.removeEventListener("blur", this[bx]), e.disableInteraction(), this[vx]())), (t.has("interactionPrompt") || t.has("cameraControls") || t.has("src")) && (this.interactionPrompt === Qy.AUTO && this.cameraControls && !this[Rx] ? this[Lx] = !0 : this[vx]()), t.has("interactionPromptStyle") && this[fx].classList.toggle("wiggle", this.interactionPromptStyle === tx.WIGGLE), t.has("interactionPolicy")) {
                                const t = this.interactionPolicy;
                                e.applyOptions({
                                    interactionPolicy: t
                                })
                            }
                            if (t.has("touchAction")) {
                                const t = this.touchAction;
                                e.applyOptions({
                                    touchAction: t
                                })
                            }
                            t.has("orbitSensitivity") && (this[mx].sensitivity = this.orbitSensitivity), !0 === this[Dx] && Promise.resolve().then(() => {
                                this[mx].jumpToGoal(), this[Jg].jumpToGoal(), this[Dx] = !1
                            })
                        }[(e = fx, n = gx, i = Ox, r = Cx, s = Px, o = Rx, a = Lx, l = mx, c = Ix, h = Nx, u = Dx, d = Fx, p = Ux, m = wx, g = Mx, v = _x, y = bx, kx)](t) {
                            this[mx].setFieldOfView(180 * t[0] / Math.PI)
                        }[zx](t) {
                            if (this[Ux]) {
                                const {
                                    theta: e,
                                    phi: n
                                } = this.getCameraOrbit();
                                t[0] = e, t[1] = n, this[Ux] = !1
                            }
                            this[mx].setOrbit(t[0], t[1], t[2])
                        }[Hx](t) {
                            this[mx].applyOptions({
                                minimumAzimuthalAngle: t[0],
                                minimumPolarAngle: t[1],
                                minimumRadius: t[2]
                            }), this.jumpCameraToGoal()
                        }[Gx](t) {
                            this[mx].applyOptions({
                                maximumAzimuthalAngle: t[0],
                                maximumPolarAngle: t[1],
                                maximumRadius: t[2]
                            }), this[xx](t[2]), this.jumpCameraToGoal()
                        }[Vx](t) {
                            this[mx].applyOptions({
                                minimumFieldOfView: 180 * t[0] / Math.PI
                            }), this.jumpCameraToGoal()
                        }[jx](t) {
                            this[mx].applyOptions({
                                maximumFieldOfView: 180 * t[0] / Math.PI
                            }), this.jumpCameraToGoal()
                        }[Bx](t) {
                            const [e, n, i] = t;
                            this[Jg].setTarget(e, n, i), this[tv].arRenderer.updateTarget()
                        }[Kg](t, e) {
                            if (super[Kg](t, e), this[tv].isPresenting || !this[ov]()) return;
                            const n = performance.now();
                            if (this[Lx]) {
                                const t = this.interactionPrompt === Qy.AUTO ? this[Vg] : this[Ox];
                                this.loaded && n > t + this.interactionPromptThreshold && (this[Xg].setAttribute("aria-label", $y), this[Lx] = !1, this[Px] = n, this[fx].classList.add("visible"))
                            }
                            if (isFinite(this[Px]) && this.interactionPromptStyle === tx.WIGGLE) {
                                const t = this[Jg],
                                    e = (n - this[Px]) / Gy % 1,
                                    i = Vy(e),
                                    r = jy(e);
                                if (this[gx].style.opacity = `${r}`, i !== this[Cx]) {
                                    const e = i * t.width * .05,
                                        n = (i - this[Cx]) * Math.PI / 16;
                                    this[gx].style.transform = `translateX(${e}px)`, this[mx].adjustOrbit(n, 0, 0), this[Cx] = i
                                }
                            }
                            this[mx].update(t, e), this[Jg].updateTarget(e)
                        }[vx]() {
                            this[Lx] = !1, this[fx].classList.remove("visible"), this[Px] = 1 / 0
                        }[xx](t) {
                            const {
                                idealCameraDistance: e
                            } = this[Jg].model, n = 2 * Math.max(e, t);
                            this[mx].updateNearFar(0, n)
                        }[yx]() {
                            const {
                                theta: t,
                                phi: e
                            } = this[Nx], {
                                theta: n,
                                phi: i
                            } = this[mx].getCameraSpherical(this[Nx]), r = this.getRootNode();
                            if (null != r && r.activeElement === this) {
                                const r = (4 + Math.floor((t % px + dx) / hx)) % 4,
                                    s = (4 + Math.floor((n % px + dx) / hx)) % 4,
                                    o = Math.floor(e / ux),
                                    a = Math.floor(i / ux);
                                if (s !== r || a !== o) {
                                    const t = Jy[s],
                                        e = `View from stage ${Zy[a]}${t}`;
                                    this[Xg].setAttribute("aria-label", e)
                                }
                            }
                        }[Qg](t) {
                            const e = this[mx],
                                n = this[Jg].framedFieldOfView;
                            super[Qg](t);
                            const i = this[Jg].framedFieldOfView,
                                r = e.getFieldOfView() / n;
                            this[Ix] = i * r, e.updateAspect(this[Jg].aspect), this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this.requestUpdate("fieldOfView", this.fieldOfView), this.jumpCameraToGoal()
                        }[$g]() {
                            super[$g]();
                            const {
                                framedFieldOfView: t
                            } = this[Jg];
                            this[Ix] = t, this[Fx] ? this[Ux] = !0 : this[Fx] = !0, this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this.requestUpdate("fieldOfView", this.fieldOfView), this.requestUpdate("minCameraOrbit", this.minCameraOrbit), this.requestUpdate("maxCameraOrbit", this.maxCameraOrbit), this.requestUpdate("cameraOrbit", this.cameraOrbit), this.requestUpdate("cameraTarget", this.cameraTarget), this.jumpCameraToGoal()
                        }[Tx]() {
                            const t = this[Xg];
                            isFinite(this[Ox]) || (this[Ox] = performance.now());
                            const e = this[Gg];
                            t.getAttribute("aria-label") !== e && t.setAttribute("aria-label", e), this.interactionPrompt !== Qy.WHEN_FOCUSED || this[Rx] || (this[Lx] = !0)
                        }[Sx]() {
                            this.interactionPrompt === Qy.WHEN_FOCUSED && (this[Lx] = !1, this[fx].classList.remove("visible"), this[Px] = 1 / 0, this[Ox] = 1 / 0)
                        }[Ex]({
                            source: t
                        }) {
                            this[yx](), this[Zg](), t === Fy.USER_INTERACTION && (this[Rx] = !0, this[vx]()), this.dispatchEvent(new CustomEvent("camera-change", {
                                detail: {
                                    source: t
                                }
                            }))
                        }[Ax](t) {
                            "pointer-change-start" === t.type ? this[qg].classList.add("pointer-tumbling") : this[qg].classList.remove("pointer-tumbling")
                        }
                    }
                    return Hy([f({
                        type: Boolean,
                        attribute: "camera-controls"
                    })], x.prototype, "cameraControls", void 0), Hy([Py({
                        intrinsics: ox,
                        observeEffects: !0,
                        updateHandler: zx
                    }), f({
                        type: String,
                        attribute: "camera-orbit",
                        hasChanged: () => !0
                    })], x.prototype, "cameraOrbit", void 0), Hy([Py({
                        intrinsics: cx,
                        observeEffects: !0,
                        updateHandler: Bx
                    }), f({
                        type: String,
                        attribute: "camera-target",
                        hasChanged: () => !0
                    })], x.prototype, "cameraTarget", void 0), Hy([Py({
                        intrinsics: ix,
                        observeEffects: !0,
                        updateHandler: kx
                    }), f({
                        type: String,
                        attribute: "field-of-view",
                        hasChanged: () => !0
                    })], x.prototype, "fieldOfView", void 0), Hy([Py({
                        intrinsics: ax,
                        updateHandler: Hx
                    }), f({
                        type: String,
                        attribute: "min-camera-orbit",
                        hasChanged: () => !0
                    })], x.prototype, "minCameraOrbit", void 0), Hy([Py({
                        intrinsics: lx,
                        updateHandler: Gx
                    }), f({
                        type: String,
                        attribute: "max-camera-orbit",
                        hasChanged: () => !0
                    })], x.prototype, "maxCameraOrbit", void 0), Hy([Py({
                        intrinsics: rx,
                        updateHandler: Vx
                    }), f({
                        type: String,
                        attribute: "min-field-of-view",
                        hasChanged: () => !0
                    })], x.prototype, "minFieldOfView", void 0), Hy([Py({
                        intrinsics: sx,
                        updateHandler: jx
                    }), f({
                        type: String,
                        attribute: "max-field-of-view",
                        hasChanged: () => !0
                    })], x.prototype, "maxFieldOfView", void 0), Hy([f({
                        type: Number,
                        attribute: "interaction-prompt-threshold"
                    })], x.prototype, "interactionPromptThreshold", void 0), Hy([f({
                        type: String,
                        attribute: "interaction-prompt-style"
                    })], x.prototype, "interactionPromptStyle", void 0), Hy([f({
                        type: String,
                        attribute: "interaction-prompt"
                    })], x.prototype, "interactionPrompt", void 0), Hy([f({
                        type: String,
                        attribute: "interaction-policy"
                    })], x.prototype, "interactionPolicy", void 0), Hy([f({
                        type: Number,
                        attribute: "orbit-sensitivity"
                    })], x.prototype, "orbitSensitivity", void 0), Hy([f({
                        type: String,
                        attribute: "touch-action"
                    })], x.prototype, "touchAction", void 0), x
                })((t => {
                    var e, n, i, r, s, o, a, l, c, h;
                    class u extends t {
                        constructor() {
                            super(...arguments), this.ar = !1, this.arScale = "auto", this.arModes = Rv, this.iosSrc = null, this.quickLookBrowsers = "safari", this[e] = !1, this[n] = this.shadowRoot.querySelector(".ar-button"), this[i] = document.createElement("a"), this[r] = new Set, this[s] = Pv.NONE, this[o] = !1, this[a] = new Set, this[l] = t => {
                                t.preventDefault(), this.activateAR()
                            }, this[c] = ({
                                status: t
                            }) => {
                                t !== _m.NOT_PRESENTING && this[tv].arRenderer.presentedScene !== this[Jg] || (this.setAttribute("ar-status", t), this.dispatchEvent(new CustomEvent("ar-status", {
                                    detail: {
                                        status: t
                                    }
                                })))
                            }, this[h] = t => {
                                "_apple_ar_quicklook_button_tapped" == t.data && this.dispatchEvent(new CustomEvent("quick-look-button-tapped"))
                            }
                        }
                        get canActivateAR() {
                            return this[Fv] !== Pv.NONE
                        }
                        connectedCallback() {
                            super.connectedCallback(), this[tv].arRenderer.addEventListener("status", this[Vv]), this.setAttribute("ar-status", _m.NOT_PRESENTING), this[Bv].addEventListener("message", this[jv])
                        }
                        disconnectedCallback() {
                            super.disconnectedCallback(), this[tv].arRenderer.removeEventListener("status", this[Vv]), this[Bv].removeEventListener("message", this[jv])
                        }
                        async update(t) {
                            super.update(t), t.has("quickLookBrowsers") && (this[kv] = Av(this.quickLookBrowsers)), (t.has("ar") || t.has("arModes") || t.has("iosSrc")) && (t.has("arModes") && (this[Uv] = Lv(this.arModes)), t.has("arScale") && (this[Jg].canScale = "fixed" !== this.arScale), this[Wv]())
                        }
                        async activateAR() {
                            switch (this[Fv]) {
                                case Pv.QUICK_LOOK:
                                    this[Nv]();
                                    break;
                                case Pv.WEBXR:
                                    await this[Ov]();
                                    break;
                                case Pv.SCENE_VIEWER:
                                    this[Iv]();
                                    break;
                                default:
                                    console.warn("No AR Mode can be activated. This is probably due to missing configuration or device capabilities")
                            }
                        }
                        async [(e = Dv, n = Cv, i = Bv, r = Uv, s = Fv, o = Hv, a = kv, l = Gv, c = Vv, h = jv, Wv)]() {
                            if (this[Fv] = Pv.NONE, this.ar) {
                                const t = [];
                                this[Uv].forEach(e => {
                                    t.push(e)
                                });
                                for (const e of t) {
                                    if ("webxr" === e && b && !Sv && await this[tv].arRenderer.supportsPresentation()) {
                                        this[Fv] = Pv.WEBXR;
                                        break
                                    }
                                    if ("scene-viewer" === e && P && !Tv) {
                                        this[Fv] = Pv.SCENE_VIEWER;
                                        break
                                    }
                                    if ("quick-look" === e && this.iosSrc && this[zv] && S) {
                                        this[Fv] = Pv.QUICK_LOOK;
                                        break
                                    }
                                }
                            }
                            if (this.canActivateAR) this[Cv].classList.add("enabled"), this[Cv].addEventListener("click", this[Gv]);
                            else if (this[Cv].classList.contains("enabled")) {
                                this[Cv].removeEventListener("click", this[Gv]), this[Cv].classList.remove("enabled");
                                const t = _m.FAILED;
                                this.setAttribute("ar-status", t), this.dispatchEvent(new CustomEvent("ar-status", {
                                    detail: {
                                        status: t
                                    }
                                }))
                            }
                        }
                        get[zv]() {
                            return L ? this[kv].has("chrome") : !!R && this[kv].has("safari")
                        }
                        async [Ov]() {
                            console.log("Attempting to present in AR..."), this[zg] || (this[Hv] = !0, this[jg](), await Sp(this, "load"), this[Hv] = !1);
                            try {
                                this[Cv].removeEventListener("click", this[Gv]), await this[tv].arRenderer.present(this[Jg])
                            } catch (t) {
                                console.warn("Error while trying to present to AR"), console.error(t), await this[tv].arRenderer.stopPresenting(), Sv = !0, await this[Wv](), this.activateAR()
                            } finally {
                                this[Wv]()
                            }
                        }[rv]() {
                            return super[rv]() || this[Hv]
                        }[Iv]() {
                            const t = this.src.replace("?", "&"),
                                e = self.location.toString(),
                                n = new URL(e),
                                i = new URL(t, e);
                            n.hash = Ev;
                            let r = `?file=${i.toString()}&mode=ar_only`;
                            t.includes("&link=") || (r += `&link=${e}`), t.includes("&title=") || (r += `&title=${encodeURIComponent(this.alt||"")}`), "fixed" === this.arScale && (r += "&resizable=false");
                            const s = `intent://arvr.google.com/scene-viewer/1.0${r}#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(n.toString())};end;`;
                            self.addEventListener("hashchange", () => {
                                self.location.hash === Ev && (Tv = !0, self.history.back(), this[Wv]())
                            }, {
                                once: !0
                            }), this[Bv].setAttribute("href", s), this[Bv].click()
                        }[Nv]() {
                            const t = new URL(this.iosSrc, self.location.toString());
                            "fixed" === this.arScale && (t.hash = "allowsContentScaling=0");
                            const e = this[Bv];
                            e.setAttribute("rel", "ar");
                            const n = document.createElement("img");
                            e.appendChild(n), e.setAttribute("href", t.toString()), e.click(), e.removeChild(n)
                        }
                    }
                    return Mv([f({
                        type: Boolean,
                        attribute: "ar"
                    })], u.prototype, "ar", void 0), Mv([f({
                        type: String,
                        attribute: "ar-scale"
                    })], u.prototype, "arScale", void 0), Mv([f({
                        type: String,
                        attribute: "ar-modes"
                    })], u.prototype, "arModes", void 0), Mv([f({
                        type: String,
                        attribute: "ios-src"
                    })], u.prototype, "iosSrc", void 0), Mv([f({
                        type: String,
                        attribute: "quick-look-browsers"
                    })], u.prototype, "quickLookBrowsers", void 0), u
                })((t => {
                    var e, n, i, r, s, o, a, l, c, h, u, d, p;
                    class m extends t {
                        constructor(...t) {
                            super(...t), this.poster = null, this.reveal = mb.AUTO, this.loading = fb.AUTO, this[e] = !1, this[n] = !1, this[i] = 0, this[r] = null, this[s] = this.shadowRoot.querySelector(".slot.poster"), this[o] = this.shadowRoot.querySelector("#default-poster"), this[a] = this.shadowRoot.querySelector("#default-progress-bar > .bar"), this[l] = this.shadowRoot.querySelector("#default-progress-bar > .mask"), this[c] = this[_b].getAttribute("aria-label"), this[h] = () => this[Ib](), this[u] = t => this[Nb](t), this[d] = t => this[Db](t), this[p] = yp(t => {
                                const e = this[yb].parentNode;
                                requestAnimationFrame(() => {
                                    this[xb].style.opacity = `${(1-t)*hb}`, this[yb].style.transform = `scaleX(${t})`, 0 === t && (e.removeChild(this[yb]), e.appendChild(this[yb])), 1 === t ? this[yb].classList.add("hide") : this[yb].classList.remove("hide")
                                })
                            }, cb);
                            const m = (self.ModelViewerElement || {}).dracoDecoderLocation || ub;
                            vd.setDRACODecoderLocation(m)
                        }
                        static set dracoDecoderLocation(t) {
                            vd.setDRACODecoderLocation(t)
                        }
                        static get dracoDecoderLocation() {
                            return vd.getDRACODecoderLocation()
                        }
                        static mapURLs(t) {
                            ig.singleton.loader[md].manager.setURLModifier(t)
                        }
                        dismissPoster() {
                            this[sv]() ? this[Sb]() : (this[wb] = gb.INTERACTION, this[jg]())
                        }
                        getDimensions() {
                            return av(this[Jg].model.size)
                        }
                        connectedCallback() {
                            super.connectedCallback(), this[bb].addEventListener("click", this[Pb]), this[bb].addEventListener("keydown", this[Cb]), this[ev].addEventListener("progress", this[Ob]), vb.registerInstance(this)
                        }
                        disconnectedCallback() {
                            super.disconnectedCallback(), this[bb].removeEventListener("click", this[Pb]), this[bb].removeEventListener("keydown", this[Cb]), this[ev].removeEventListener("progress", this[Ob]), vb.unregisterInstance(this)
                        }
                        async updated(t) {
                            super.updated(t), t.has("poster") && null != this.poster && (this[_b].style.backgroundImage = `url(${this.poster})`), t.has("alt") && this[_b].setAttribute("aria-label", `${this[Gg]}. ${this[Rb]}`), (t.has("reveal") || t.has("loaded")) && (this[sv]() || this[jg]())
                        }[(e = Tb, n = Lb, i = Ab, r = wb, s = bb, o = _b, a = yb, l = xb, c = Rb, h = Pb, u = Cb, d = Ob, p = Eb, Ib)]() {
                            this.reveal !== mb.MANUAL && this.dismissPoster()
                        }[Nb](t) {
                            if (this.reveal !== mb.MANUAL) switch (t.keyCode) {
                                case db:
                                case pb:
                                    this.dismissPoster()
                            }
                        }[Db](t) {
                            const e = t.detail.totalProgress;
                            this[Ab] = Math.max(e, this[Ab]), 1 === e && (this[Eb].flush(), !this[sv]() || null == this[wb] && this.reveal !== mb.AUTO || this[Sb]()), this[Eb](e), this.dispatchEvent(new CustomEvent("progress", {
                                detail: {
                                    totalProgress: e
                                }
                            }))
                        }[rv]() {
                            return !!this.src && (null != this[wb] || this.loading === fb.EAGER || this.reveal === mb.AUTO && this[Bg])
                        }[sv]() {
                            const {
                                src: t
                            } = this;
                            return !!t && super[sv]() && 1 === this[Ab]
                        }[Mb]() {
                            const t = this[bb],
                                e = this[_b];
                            e.removeAttribute("tabindex"), e.removeAttribute("aria-hidden"), t.classList.add("show");
                            const n = this.modelIsVisible;
                            this[Tb] = !1, this[Hg](n), this[Lb] = !1
                        }[Sb]() {
                            this[wb] = null;
                            const t = this[bb],
                                e = this[_b];
                            if (t.classList.contains("show")) {
                                t.classList.remove("show");
                                const n = this.modelIsVisible;
                                this[Tb] = !0, this[Hg](n), t.addEventListener("transitionend", () => {
                                    requestAnimationFrame(() => {
                                        this[Lb] = !0;
                                        const t = this.getRootNode();
                                        t && t.activeElement === this && this[Xg].focus(), e.setAttribute("aria-hidden", "true"), e.tabIndex = -1, this.dispatchEvent(new CustomEvent("poster-dismissed"))
                                    })
                                }, {
                                    once: !0
                                })
                            }
                        }[iv]() {
                            return super[iv]() && this[Tb]
                        }[ov]() {
                            return super[ov]() && this[Lb]
                        }
                        async [jg]() {
                            this[Ab] = 0, null != this[Jg].model.currentGLTF && null != this.src && this[rv]() || this[Mb](), await super[jg]()
                        }
                    }
                    return lb([f({
                        type: String
                    })], m.prototype, "poster", void 0), lb([f({
                        type: String
                    })], m.prototype, "reveal", void 0), lb([f({
                        type: String
                    })], m.prototype, "loading", void 0), m
                })((t => {
                    var e;
                    class n extends t {
                        constructor() {
                            super(...arguments), this.autoplay = !1, this.animationName = void 0, this.animationCrossfadeDuration = 300, this[e] = !0
                        }
                        get availableAnimations() {
                            return this.loaded ? this[Jg].model.animationNames : []
                        }
                        get paused() {
                            return this[dv]
                        }
                        get currentTime() {
                            return this[Jg].model.animationTime
                        }
                        set currentTime(t) {
                            this[Jg].model.animationTime = t, this[tv].threeRenderer.shadowMap.needsUpdate = !0, this[Zg]()
                        }
                        pause() {
                            this[dv] || (this[dv] = !0, this[tv].threeRenderer.shadowMap.autoUpdate = !1, this.dispatchEvent(new CustomEvent("pause")))
                        }
                        play() {
                            this[dv] && this.availableAnimations.length > 0 && (this[dv] = !1, this[tv].threeRenderer.shadowMap.autoUpdate = !0, this[Jg].model.hasActiveAnimation || this[uv](), this.dispatchEvent(new CustomEvent("play")))
                        }[(e = dv, $g)]() {
                            super[$g](), this[dv] = !0, this.autoplay && (this[uv](), this.play())
                        }[Kg](t, e) {
                            if (super[Kg](t, e), this[dv] || !this[ov]()) return;
                            const {
                                model: n
                            } = this[Jg];
                            n.updateAnimation(e / hv), this[Zg]()
                        }
                        updated(t) {
                            super.updated(t), t.has("autoplay") && this.autoplay && this.play(), t.has("animationName") && this[uv]()
                        }
                        async [jg]() {
                            return this[Jg].model.stopAnimation(), super[jg]()
                        }[uv]() {
                            const {
                                model: t
                            } = this[Jg];
                            t.playAnimation(this.animationName, this.animationCrossfadeDuration / hv), this[dv] && (t.updateAnimation(0), this[Zg]())
                        }
                    }
                    return cv([f({
                        type: Boolean
                    })], n.prototype, "autoplay", void 0), cv([f({
                        type: String,
                        attribute: "animation-name"
                    })], n.prototype, "animationName", void 0), cv([f({
                        type: Number,
                        attribute: "animation-crossfade-duration"
                    })], n.prototype, "animationCrossfadeDuration", void 0), n
                })((t => {
                    var e;
                    const n = t => {
                            if (null == t.shadowRoot || t.hasAttribute("data-js-focus-visible")) return () => {};
                            if (!self.applyFocusVisiblePolyfill) {
                                const e = () => {
                                    self.applyFocusVisiblePolyfill(t.shadowRoot)
                                };
                                return self.addEventListener("focus-visible-polyfill-ready", e, {
                                    once: !0
                                }), () => {
                                    self.removeEventListener("focus-visible-polyfill-ready", e)
                                }
                            }
                            return self.applyFocusVisiblePolyfill(t.shadowRoot), () => {}
                        },
                        i = Symbol("endPolyfillCoordination");
                    return e = i, class extends t {
                        constructor() {
                            super(...arguments), this[e] = null
                        }
                        connectedCallback() {
                            super.connectedCallback && super.connectedCallback(), null == this[i] && (this[i] = n(this))
                        }
                        disconnectedCallback() {
                            super.disconnectedCallback && super.disconnectedCallback(), null != this[i] && (this[i](), this[i] = null)
                        }
                    }
                })(lv)))))))));
            customElements.define("model-viewer", wM)
        }
    }
]);